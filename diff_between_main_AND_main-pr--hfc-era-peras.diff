diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 2dc56f962..84237616a 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -156,7 +156,7 @@ jobs:
 
     - name: Test
       if: matrix.test-set == 'all'
-      run: cabal test all -j --test-show-details=streaming
+      run: cabal test all -j --test-show-details=streaming --test-options '--hide-successes'
 
     - name: Test (NoThunks-safe tests only)
       if: matrix.test-set == 'no-thunks-safe'
@@ -167,7 +167,7 @@ jobs:
         cp $(cabal list-bin mempool-bench) mempool-bench
 
     - name: Upload benchmark executables
-      uses: actions/upload-artifact@v4
+      uses: actions/upload-artifact@v5
       with:
         name: benchmark-exes-${{ runner.os }}-${{ matrix.ghc }}
         path: mempool-bench
@@ -195,7 +195,7 @@ jobs:
         github.event_name == 'push'
         && github.ref == 'refs/heads/main'
         && matrix.ghc=='9.10.2'
-      uses: actions/upload-artifact@v4
+      uses: actions/upload-artifact@v5
       with:
         name: haddocks
         path: haddocks.tgz
@@ -220,7 +220,7 @@ jobs:
         use-sodium-vrf: false
 
     - name: Download benchmark executables
-      uses: actions/download-artifact@v5
+      uses: actions/download-artifact@v6
       with:
         name: benchmark-exes-${{ runner.os }}-${{ matrix.ghc }}
 
@@ -258,7 +258,7 @@ jobs:
     # TODO: this will be necessary when we publish the benchmarks results.
     # - name: Upload mempool benchmark baseline results
     #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
-    #   uses: actions/upload-artifact@v4
+    #   uses: actions/upload-artifact@v5
     #   with:
     #     name: baseline-mempool-benchmarks
     #     path: baseline-mempool-benchmarks.csv
@@ -291,7 +291,7 @@ jobs:
     steps:
       - uses: actions/checkout@v5
 
-      - uses: actions/setup-node@v5
+      - uses: actions/setup-node@v6
         with:
           node-version: 18
           cache: yarn
@@ -308,7 +308,7 @@ jobs:
           cp -r --no-preserve=mode,ownership result/ static/pdfs
 
       - name: Download haddocks
-        uses: actions/download-artifact@v5
+        uses: actions/download-artifact@v6
         with:
           name: haddocks
 
diff --git a/.github/workflows/documentation.yml b/.github/workflows/documentation.yml
index b164d6c85..1b539d13d 100644
--- a/.github/workflows/documentation.yml
+++ b/.github/workflows/documentation.yml
@@ -27,7 +27,7 @@ jobs:
 
     steps:
       - uses: actions/checkout@v5
-      - uses: actions/setup-node@v5
+      - uses: actions/setup-node@v6
         with:
           node-version: 18
           cache: yarn
diff --git a/CODEOWNERS b/CODEOWNERS
index 4391f58fc..89e04c15c 100644
--- a/CODEOWNERS
+++ b/CODEOWNERS
@@ -1,4 +1,4 @@
 # Ouroboros-Consensus
 
 # These owners will be the default owners for everything in the repository.
-* @nfrisby @jasagredo @amesgen @fraser-iohk @dnadales @geo2a
+* @nfrisby @jasagredo @amesgen @fraser-iohk @dnadales @geo2a @bladyjoker
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 135547e56..6331a1572 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -409,6 +409,8 @@ The core contributors to consensus codebase are:
 
 -   [Georgy Lukyanov](https://github.com/geo2a)
 
+-   [Drazen Popovic](https://github.com/bladyjoker)
+
 # Code of conduct
 
 See [Cardano engineering
diff --git a/README.md b/README.md
index 1d77047e7..b6af7c5ad 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,10 @@
 # Ouroboros Consensus
 
-[![consensus](https://img.shields.io/badge/ouroboros--consensus-0.27.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-0.27.0.0/)
-[![diffusion](https://img.shields.io/badge/ouroboros--consensus--diffusion-0.23.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-diffusion-0.23.0.0/)
-[![protocol](https://img.shields.io/badge/ouroboros--consensus--protocol-0.12.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-protocol-0.12.0.0/)
-[![cardano](https://img.shields.io/badge/ouroboros--consensus--cardano-0.25.1.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-cardano-0.25.1.0/)
-[![sop-extras](https://img.shields.io/badge/sop--extras-0.4.0.0-blue)](https://chap.intersectmbo.org/package/sop-extras-0.4.0.0/)
+[![consensus](https://img.shields.io/badge/ouroboros--consensus-0.28.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-0.28.0.0/)
+[![diffusion](https://img.shields.io/badge/ouroboros--consensus--diffusion-0.24.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-diffusion-0.24.0.0/)
+[![protocol](https://img.shields.io/badge/ouroboros--consensus--protocol-0.13.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-protocol-0.13.0.0/)
+[![cardano](https://img.shields.io/badge/ouroboros--consensus--cardano-0.26.0.0-blue)](https://chap.intersectmbo.org/package/ouroboros-consensus-cardano-0.26.0.0/)
+[![sop-extras](https://img.shields.io/badge/sop--extras-0.4.1.0-blue)](https://chap.intersectmbo.org/package/sop-extras-0.4.1.0/)
 [![strict-sop-core](https://img.shields.io/badge/strict--sop--core-0.1.3.0-blue)](https://chap.intersectmbo.org/package/strict-sop-core-0.1.3.0/)
 
 
diff --git a/SECURITY.md b/SECURITY.md
index 684e298f8..e70cc8d85 100644
--- a/SECURITY.md
+++ b/SECURITY.md
@@ -1,19 +1,107 @@
-# Security Policy
+# Security Vulnerability Disclosure Policy
 
-## Reporting a Vulnerability
+## Introduction
 
-Please report (suspected) security vulnerabilities to security@intersectmbo.org. You will receive a
-response from us within 48 hours. If the issue is confirmed, we will release a patch as soon
-as possible.
+The Cardano open source project (ouroboros-consensus) is committed to ensuring the security of
+its software and the privacy of its users. We value the contributions
+of the security community in helping us identify and address
+vulnerabilities in our code. This Security Vulnerability Disclosure
+Policy outlines how security vulnerabilities should be reported and
+how we will respond to and remediate such reports.
 
-Please provide a clear and concise description of the vulnerability, including:
+## Security Vulnerability Handling Process
 
-* the affected version(s) of OSC-documentation,
-* steps that can be followed to exercise the vulnerability,
-* any workarounds or mitigations
+### Reporting a Vulnerability
 
-If you have developed any code or utilities that can help demonstrate the suspected
-vulnerability, please mention them in your email but ***DO NOT*** attempt to include them as
-attachments as this may cause your Email to be blocked by spam filters.
+If you discover a security vulnerability in xxxx, we encourage you to
+responsibly disclose it to us. To report a vulnerability, please use
+the [private reporting form on
+GitHub](https://github.com/IntersectMBO/ouroboros-consensus/security/advisories/new)
+to draft a new _Security advisory_.
 
-See the security file in the [Cardano engineering handbook](https://github.com/input-output-hk/cardano-engineering-handbook/blob/main/SECURITY.md).
+Please include as much details as needed to clearly qualify the issue:
+
+- A description of the vulnerability and its potential impact.
+- Steps to reproduce the vulnerability.
+- The version of `xxxx` package where the vulnerability exists.
+- Any relevant proof-of-concept or exploit code (if applicable).
+
+### Processing Vulnerability
+
+1. **Acknowledgment**: The team acknowledges the receipt of your report
+   within 3 business days by commenting on the issue reporting it or replying to email.
+
+2. **Validation**: The team investigates the issue and either _reject_ or _validate_ the
+   reported vulnerability.
+
+   a. **Rejection**: If the team rejects the report, detailed explanations will be provided by email or commenting on the relevant issue and the latter will be made public and closed as `Won't fix`.
+
+   b. **Acceptance**: If the team accepts the report, a CVE identifier will be requested through GitHub and a [private fork](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/collaborating-in-a-temporary-private-fork-to-resolve-a-repository-security-vulnerability) opened to work on a fix to the issue
+
+3. **Resolution**: The team works to resolve the vulnerability in a
+   timely manner. The timeline for resolution will depend on the
+   complexity and severity of the vulnerability, but we will strive to
+   address critical vulnerabilities as quickly as possible.
+
+4. **Collaboration**: While working on a fix, the team maintains open and transparent
+   communication with the reporter throughout the process, providing
+   updates on the status of the vulnerability and any steps taken to
+   remediate it. In particular this means that the reporter will be asked to review any proposed fix and to advise on the timing for public disclosure.
+
+5. **Fixing Issue**: The team agrees on the fix, the announcement, and the release schedule with the reporter. If the reporter is not responsive in a reasonable time frame this should not block the team from moving to the next steps particularly in the face of a high impact or high severity issue.
+
+   a. **Mitigation**: Depending on the severity and criticity of the issue, the team can decide to disclose the issue publicly in the absence of a fix _if and only if_ a clear, simple, and effective mitigation plan is defined. This _must_ include instructions for users and operators of the software, and a time horizon at which the issue will be properly fixed (eg. version number).
+
+   b. **Fix**: When a fix is available and approved, it should be merged and made available as quickly as possible:
+
+   - All commits to the private repository are squashed into a single commit whose description _should not_ make any reference it relates to a security vulnerability
+   - A new Pull Request is created with this single commit
+   - This PR's review and merging is expedited as all the work as already been done
+
+6. **Release**: The team creates and publish a release that includes the fix
+
+7. **Announcement**: Concomitant to the release announcement, the team announces the security vulnerability by making the GitHub issue public. This is the first point that any information regarding the vulnerability is made public.
+
+   a. **Credit**: The team publicly acknowledges the contributions of the
+   reporter once the vulnerability is resolved, subject to the
+   reporter's preferences for attribution.
+
+8. **Disagreements**: In case of disagreements with the reporter on the fix, mitigation, timing, or announcement, the team has the final say.
+
+## Responsible Disclosure
+
+We kindly request that reporters adhere to responsible disclosure
+practices, which include:
+
+- **Do not disclose the vulnerability publicly**: Please refrain from
+  posting details of the vulnerability on public forums or social
+  media until it has been resolved.
+- **Do not exploit the vulnerability**: Do not attempt to exploit the
+  vulnerability to cause harm or gain unauthorized access to systems.
+- **Work with us**: Allow us a reasonable amount of time to
+  investigate and address the vulnerability before publicly disclosing
+  any details.
+
+## Legal Protections
+
+We will not pursue legal action against individuals who
+report security vulnerabilities to us.
+
+## Contact Information
+
+To report a security vulnerability, please use [GitHub
+form](https://github.com/IntersectMBO/ouroboros-consensus/security/advisories/new). Should you experience any issues reporting via GitHub or have other questions, Please contact [Security](mailto:security@intersectmbo.org).
+
+## Revision of Policy
+
+This Security Vulnerability Disclosure Policy may be updated or
+revised as necessary. Please check the latest version of this policy
+on the [ouroboros-consensus repository](https://github.com/IntersectMBO/ouroboros-consensus).
+
+## Conclusion
+
+The ouroboros-consensus project greatly appreciates the assistance of the security
+community in helping us maintain the security of our software while
+upholding the highest standards of privacy. Together, we can work to
+identify and address vulnerabilities, ensuring a safer and more secure
+experience for all users.
diff --git a/cabal.project b/cabal.project
index 216241016..0bc6f2b8e 100644
--- a/cabal.project
+++ b/cabal.project
@@ -14,9 +14,9 @@ repository cardano-haskell-packages
 -- update either of these.
 index-state:
   -- Bump this if you need newer packages from Hackage
-  , hackage.haskell.org 2025-07-22T09:13:54Z
+  , hackage.haskell.org 2025-09-26T20:57:57Z
   -- Bump this if you need newer packages from CHaP
-  , cardano-haskell-packages 2025-08-21T09:41:03Z
+  , cardano-haskell-packages 2025-10-07T11:20:00Z
 
 packages:
   ouroboros-consensus
@@ -45,48 +45,55 @@ if os (windows)
   constraints:
     bitvec -simd
 
-if impl (ghc >= 9.12)
+if impl (ghc >= 9.10)
   allow-newer:
-    -- https://github.com/kapralVV/Unique/issues/11
-    , Unique:hashable
-
-allow-newer:
-    -- https://github.com/phadej/vec/issues/121
-    , ral:QuickCheck
-    , fin:QuickCheck
-    , bin:QuickCheck
+    -- https://github.com/phadej/regression-simple/pull/14
+    , regression-simple:base
 
 source-repository-package
   type: git
   location: https://github.com/IntersectMBO/cardano-ledger
-  tag: 640fb66d27ac202764de0dda76621c6d57852ba9
-  --sha256: sha256-2vOUUvY19Emx5UpHNHZnIaWoqI5g3kPgjFQJGm9mVmk=
+  tag: fb09078fa55015c881303a2ddb609c024cec258f
+  --sha256: sha256-9Y9CRiyMn0AWD+C4aNVMaJgrj3FDAYfCX4VrLvtoMaI=
   subdir:
     eras/allegra/impl
     eras/alonzo/impl
     eras/alonzo/test-suite
     eras/babbage/impl
-    eras/byron/chain/executable-spec
-    eras/byron/crypto
-    eras/byron/ledger/executable-spec
-    eras/byron/ledger/impl
     eras/conway/impl
-    eras/dijkstra
+    eras/dijkstra/impl
     eras/mary/impl
     eras/shelley/impl
-    eras/shelley-ma/test-suite
     eras/shelley/test-suite
-    libs/cardano-data
+    eras/shelley-ma/test-suite
     libs/cardano-ledger-api
-    libs/cardano-ledger-binary
     libs/cardano-ledger-core
+    libs/cardano-ledger-binary
     libs/cardano-protocol-tpraos
     libs/non-integral
-    libs/set-algebra
     libs/small-steps
+    libs/cardano-data
+    libs/set-algebra
     libs/vector-map
+    eras/byron/chain/executable-spec
+    eras/byron/ledger/executable-spec
+    eras/byron/ledger/impl
+    eras/byron/crypto
 
-constraints:
-  plutus-core < 1.51,
-  plutus-ledger-api < 1.51,
-  plutus-tx < 1.51,
+allow-newer:
+    -- https://github.com/phadej/vec/issues/121
+    , ral:QuickCheck
+    , fin:QuickCheck
+    , bin:QuickCheck
+
+-- Using https://github.com/IntersectMBO/ouroboros-network/tree/peras-staging/pr-5202-v2
+source-repository-package
+   type: git
+   location: https://github.com/IntersectMBO/ouroboros-network
+   tag: 0db8669b67982cba755e80bf2e413527def41244
+   --sha256: sha256-vEO721Xab0RTVKFQFKal5VCV5y+OUzELo8+7Z8TETJQ=
+   subdir:
+     ouroboros-network
+     ouroboros-network-protocols
+     ouroboros-network-api
+     ouroboros-network
diff --git a/docs/website/README.md b/docs/website/README.md
index 64cab6d5c..63232223d 100644
--- a/docs/website/README.md
+++ b/docs/website/README.md
@@ -43,6 +43,22 @@ The order of entries in the `items` list determines their placement in the sideb
 
 # Building the website
 
+If you use `nix`, you can enter a shell with a `yarn` installation by running:
+
+
+```
+nix develop .#website
+```
+
+To omit the `.website` part in `nix develop`, you can add an `.envrc` file in `docs/website` containing:
+
+```
+use flake .#website
+```
+
+
+If you don't use `nix`, please refer to the `yarn` installation instructions online.
+
 To install the required packages for the documentation site, run:
 
 ```
diff --git a/docs/website/contents/explanations/design_goals.md b/docs/website/contents/explanations/design_goals.md
index 0c5e02d03..9ae55ccdb 100644
--- a/docs/website/contents/explanations/design_goals.md
+++ b/docs/website/contents/explanations/design_goals.md
@@ -1 +1,63 @@
 # Design Goals
+
+The components that make up `ouroboros-consensus` were designed with the following goals in mind.
+
+## Multiple Consensus Protocols
+
+The design must support different consensus algorithms, requiring abstraction over the specific choice of consensus protocol.
+From the project's inception, it was evident that multiple protocols would be required.
+The [Byron era](../references/glossary.md#byron-era) of Cardano utilizes the [PBFT](../references/glossary.md#permissive-bft-pbft) protocol, while the [Shelley era](../references/glossary.md#shelley-based-eras) transitioned to [TPraos](../references/glossary.md#tpraos), and [Praos](../references/glossary.md#ouroboros-praos) has been used since the [Babbage](../references/glossary.md#babbage-era) era.
+The consensus component must support not only the current era but also past eras, requiring the ability to compose protocols.
+Additionally, we must ensure support for integrating new consensus protocols.
+
+## Support for Multiple Ledgers
+
+Similar to the need for multiple consensus protocols, our implementation must support multiple ledger implementations.
+This is crucial for accommodating ledger changes as improvements are made.
+Abstracting over the ledger implementation enables the consensus layer to work with various ledgers.
+
+## Decoupling Consensus Protocol from Ledger
+
+The consensus protocol is designed to be independent of any specific ledger implementation.
+Since multiple ledgers (such as Shelley and its Shelley-based successors) can utilize the same consensus protocol (TPraos or Praos), the consensus protocol is defined based on what it expects or requires from the ledger rather than being tightly coupled to a specific one.
+This approach makes the consensus protocol abstract and reusable across different ledgers.
+
+## Testability
+
+Ensuring the thorough testability of the consensus layer is a critical design goal.
+As a core component of the Cardano Node, which manages the cryptocurrency, the consensus layer must adhere to strict correctness standards.
+Currently, we extensively employ property-based testing.
+Whenever possible, we should abstract over `IO`, enabling simulations of various failures (such as disk or network errors) to verify system recovery capabilities[^1].
+Additionally, to leverage the property-based methodology, tests must be relatively inexpensive.
+The design should also support testing rare but expected scenarios (such as multiple slot leaders in Praos) by allowing overrides in protocol or ledger behavior at specific points.
+Furthermore, the system should facilitate the isolated testing of individual components.
+
+## Adaptability and Maintainability
+
+The consensus layer was developed as a replacement for a [previous implementation](https://github.com/input-output-hk/cardano-sl), with the immediate goal of transitioning from Byron/BFT to Shelley/Praos while supporting future ledger and protocol changes.
+This called for a flexible and adaptable design.
+Abstracting both the consensus algorithm and the ledger plays a crucial role in achieving this.
+Working with abstract interfaces prevents developers from making assumptions that may hold for one ledger but not others, avoiding costly fixes later.
+This abstraction also allows the consensus layer to be reused in other blockchain projects.
+Most importantly, an abstract design enables extensive testing with simpler mock ledgers, which are easier to set up and reason about compared to the complex real ledger.
+Abstraction is considered good engineering practice, enhancing clarity, reducing dependencies, and making the system easier to understand and maintain.
+
+## Composability
+
+Given the complexity and scale of the consensus layer codebase, it is essential to divide it into smaller, manageable components that can be understood and modified independently.
+Composability is a key technique employed to achieve this.
+A prime example is the [Hard Fork Combinator](../references/glossary.md#hard-fork-combinator) (HFC), which enables the combination of different consensus protocols (such as BFT and Praos) and ledgers (such as Byron and Shelley) into a unified composite protocol or ledger for the hybrid chain.
+
+## Predictable Performance
+
+This goal ensures that node operators can configure nodes for "normal circumstances" without the network failing during infrequent but expected events.
+It aims to make node performance predictable, ensuring that the average-case scenario aligns with the worst-case scenario in terms of resource requirements—not only for security but also to maintain network stability with honest nodes.
+
+## Protection Against DoS Attacks
+
+The consensus layer must help safeguard the network against disruptions, making denial-of-service (DoS) attacks prohibitively expensive for adversaries.
+This involves design decisions that prevent attackers from easily causing a node to perform extensive, wasteful computations.
+For example, validating headers before downloading block bodies prevents attackers from forcing nodes to process potentially invalid blocks.
+The design often seeks a balance between the cost for an attacker to induce work and the cost for a node to defend against it.
+
+[^1]: See the `IOSim` monad and the `io-classes` package of [`io-sim`](https://input-output-hk.github.io/io-sim/).
diff --git a/docs/website/contents/explanations/index.md b/docs/website/contents/explanations/index.md
index e10b99d01..bb3fb58af 100644
--- a/docs/website/contents/explanations/index.md
+++ b/docs/website/contents/explanations/index.md
@@ -1 +1,14 @@
 # Introduction
+
+Welcome to the documentation for the [`ouroboros-consensus`](https://github.com/IntersectMBO/ouroboros-consensus) repository.
+This repository houses the Haskell implementation of three crucial components utilized by the [`cardano-node`](https://github.com/IntersectMBO/cardano-node): Consensus, Storage, and Mempool.
+- The [Consensus component](https://cardano-scaling.github.io/cardano-blueprint/consensus/index.html) implements the [Ouroboros](https://iohk.io/en/research/library/papers/ouroboros-a-provably-secure-proof-of-stake-blockchain-protocol/) family of Proof-of-Stake protocols.
+- The [Storage component](https://cardano-scaling.github.io/cardano-blueprint/storage/index.html) is responsible for providing efficient access to the blockchain data, as well as maintaining the current and recent past ledger states, and storing ledger state snapshots.
+- The [Mempool component](https://cardano-scaling.github.io/cardano-blueprint/mempool/index.html) serves as a buffer for valid transactions that are waiting to be included in a block. It is used by the Consensus component when forging a block and by the Network layer's transaction submission mini-protocol to diffuse transactions among nodes.
+
+A core design principle in the implementation of these components is the abstraction from specific ledger and protocol implementations.
+The aim is to decouple the consensus protocol from the ledger and to support multiple consensus algorithms and ledgers for improved adaptability and maintainability.
+This design allows different ledgers (like the Byron or Shelley ledgers) and different Ouroboros protocol instances (like Praos or TPraos) to be integrated into the abstract consensus framework.
+To reflect this design, the repository is structured into different sub-repositories.
+- The polymorphic implementations and abstract classes, which define the core consensus logic independently of specific ledger or protocol details, can be found in the [`ouroboros-consensus`](https://github.com/IntersectMBO/ouroboros-consensus/tree/main/ouroboros-consensus) sub-directory.
+- The Cardano specific instantiations, which provide the concrete implementations, reside in the [`ouroboros-consensus-cardano`](https://github.com/IntersectMBO/ouroboros-consensus/tree/main/ouroboros-consensus-cardano) sub-directory.
diff --git a/docs/website/contents/howtos/benchmarks.md b/docs/website/contents/howtos/benchmarks.md
new file mode 100644
index 000000000..94ce7fc0c
--- /dev/null
+++ b/docs/website/contents/howtos/benchmarks.md
@@ -0,0 +1,32 @@
+# Consensus benchmarks
+
+We are in the process of adding component level microbenchmarks for Consensus.
+
+We check for regressions in performance on CI.
+
+## Mempool Benchmark
+
+We started with microbenchmarks for adding transactions to the mempool. The
+mempool benchmarks can be run using the following command.
+
+```sh
+cabal new-run ouroboros-consensus:mempool-bench
+```
+
+## ChainSync Client Benchmark
+
+To aid the refactoring of the ChainSync client, we added a benchmark for it in [PR#823](https://github.com/IntersectMBO/ouroboros-consensus/pull/823). The benchmark could be invoked as follows:
+
+```sh
+cabal new-run ouroboros-consensus:ChainSync-client-bench -- 10 10
+```
+
+## PerasCertDB Benchmark
+
+We have a microbenchmark for the boosted chain fragment weight calculation, which could be run as follows:
+
+```sh
+cabal run ouroboros-consensus:PerasCertDB-bench -- +RTS -T -A32m -RTS
+```
+
+We request GHC runtime system statistics with `-T` to get a memory usage estimate, and also request a large nursery with `-A32m` to minimise garbage collection. See `tasty-bench` [documentation](https://github.com/Bodigrim/tasty-bench?tab=readme-ov-file#troubleshooting) for more tips.
diff --git a/docs/website/contents/howtos/versioning_a_new_query.md b/docs/website/contents/howtos/versioning_a_new_query.md
index fef82dd88..ff92c9144 100644
--- a/docs/website/contents/howtos/versioning_a_new_query.md
+++ b/docs/website/contents/howtos/versioning_a_new_query.md
@@ -106,7 +106,7 @@ The golden tests only generate golden files for queries that have examples. So i
 
 Old pull-requests that added new queries serve as good reference material when adding new queries. For instance see [#191](https://github.com/IntersectMBO/ouroboros-consensus/pull/191). Be aware that these PRs they can get out of date. If you detect this please delete old links and add those corresponding to newer pull requests.
 
-[n2c]: https://ouroboros-network.cardano.intersectmbo.org/ouroboros-network/cardano-diffusion/Cardano-Network-NodeToClient.html#t:NodeToClientVersion
+[n2c]: https://ouroboros-network.cardano.intersectmbo.org/cardano-diffusion/api/Cardano-Network-NodeToClient-Version.html#t:NodeToClientVersion
 [network-spec]: https://ouroboros-network.cardano.intersectmbo.org/pdfs/network-spec/network-spec.pdf
 [shelley-n2c]: https://github.com/IntersectMBO/ouroboros-consensus/blob/35e444f1440cef34e0989519f025231241397674/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/NetworkProtocolVersion.hs#L17
 [cardano-n2c]: https://github.com/IntersectMBO/ouroboros-consensus/blob/35e444f1440cef34e0989519f025231241397674/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Node.hs#L341-L527
diff --git a/docs/website/contents/references/glossary.md b/docs/website/contents/references/glossary.md
index 3035ccae6..b06ef6c3c 100644
--- a/docs/website/contents/references/glossary.md
+++ b/docs/website/contents/references/glossary.md
@@ -31,6 +31,12 @@ Security analyses typically assume the worst-case, ie the behavior of all advers
 
 A chain fragment always has an anchor point, which is the predecessor of the oldest header/block on the fragment.
 
+## ;Babbage era
+
+The Babbage era is a major phase of the Cardano blockchain, identified as a [Shelley-based era](#shelley-based-eras), that succeeded the Alonzo era.
+On mainnet, it corresponds to least major protocol version 7 and ends when the version increments past 8.
+It uses the Ouroboros [Praos](#ouroboros-praos) consensus protocol.
+
 ## ;Block
 
 In some slots, the protocol allows a block-producing node to contribute to the chain; it does so by minting a new block.
@@ -58,6 +64,11 @@ A valid block satisfies the ledger rules in the context of the ledger state that
 
 Trusted honest caught-up peers that are used for syncing before a Genesis-capable node is released. By default, these are public root peers.
 
+## ;Byron era
+
+The Byron era refers to the first implementation of the Cardano blockchain, which was introduced in September 2017.
+On the [first implementation](https://github.com/input-output-hk/cardano-sl) it used the Ouroboros Classic consensus protocol. In the current Haskell implementation, the Byron Era uses the Permissive Ouroboros BFT consensus protocol, which is backwards compatible with the Ouroboros Classic protocol, relying on seven federated nodes for block production.
+
 ## ;Chain
 
 A sequence of blocks.
@@ -255,6 +266,12 @@ There is one at each era change but they can also happen within the same era; th
 Intra-era hard forks are mostly ledger related, for instance to fix a bug of (de)serialisation of transactions, or to add a new smart contract feature.
 Recently, hard forks have been given names: Vasil is the hard fork from Alonzo to Babbage; Valentine is an intra-era hard fork within Babbage.
 
+## ;Hard-fork combinator
+
+The Hard-fork Combinator (HFC) is a core architectural component of the Consensus layer designed to enable sequential composition of multiple blockchain eras (eg Byron, Shelley, Allegra, Babbage, etc.) so they can be managed as a single, unified chain type.
+It is responsible for handling the complex logistics of transitions, including providing the necessary context for the underlying ledgers.
+It facilitates the necessary translations between successive eras, such as translating the ledger state and chain dependency state during an era boundary
+
 ## ;Header-body split
 
 The [stability window](#stability-window) enables the engineering design of nodes exchanging chains of headers before exchanging chains of the corresponding blocks.
@@ -461,6 +478,9 @@ A slight refinement of [Praos](#ouroboros-praos).
 ## ;Ouroboros Praos
 
 The protocol underlying the latest Cardano era.
+It was the first proof-of-stake protocol designed and formally proven to provide security against fully-adaptive corruption in a setting that tolerates adversarial message delays (up to Δ slots).
+Praos implements slot leader election using stake distribution and Verifiable Random Functions (VRF), and honest parties converge to a unique chain view primarily by following the longest chain rule.
+The name "Praos" means "mellow" or "gentle," derived from the protocol's use of deliberately inserted empty slots to facilitate synchronization in the semi-synchronous environment.
 
 ## ;Peer kinds
 
@@ -472,6 +492,27 @@ These kinds are maintained by the Networking layer:
 - [Public root peers](#public-root-peers).
 - [Shared peers](#shared-peers).
 
+## ;Peras ;weight ;boost
+
+Peras is an extension of Praos enabling faster settlement under optimistic conditions.
+To this end, Peras can result in a block `B` receiving a *boost*, which means that any chain containing `B` gets additional weight when being compared to other chains.
+
+Consider a chain fragment `F`:
+
+- Its ;*weight boost* is the sum of all boosts received by points on this fragment (excluding the anchor). Note that the same point can be boosted multiple times.
+
+- Its ;*total weight* is its tip block number plus its weight boost.
+
+Note that these notions are always relative to a particular anchor, so different chain fragments must have the same anchor when their total weight is to be compared.
+
+## ;Permissive BFT (PBFT)
+
+Ouroboros Permissive BFT (PBFT) is a simple, deterministic, Byzantine Fault Tolerant (BFT) consensus protocol derived from Ouroboros-BFT, typically designed to ensure consistency and liveness against `t < n/3` Byzantine faults.
+The protocol is deemed "permissive" because it relaxes the strict requirement that blocks must be signed according to a predetermined round-robin schedule.
+Instead, blocks are merely required to be signed by any of the known core nodes.
+However, this permissiveness is still bounded: the protocol limits the number of signatures a given node can contribute within a window of blocks.
+
+
 ## ;Phases
 
 Byron, Shelley, Goguen (current one as of August 2023), Basho, Voltaire.
@@ -552,6 +593,11 @@ Some entity that maintains/controls one or multiple stake pools.
 
 The process of becoming synchronized with the system, either from scratch or due to a temporary restart/crash/local network outage.
 
+## ;TPraos
+
+TPraos (Transitional Praos) is a Proof-of-Stake consensus protocol used in the early decentralized eras of Cardano (specifically Shelley, Allegra, and Mary).
+It was designed to manage the transition from the initial federated system by using a decentralization parameter (`d`) which controls the ratio of slots produced by legacy bootstrap keys (OBFT slots) versus those produced by stake pools selected via Ouroboros Praos, allowing for a smooth shift toward full decentralization.
+
 ## ;Transactions
 
 If a slot has multiple leaders or if the leader of a slot hadn't received the latest block, then they will issue multiple blocks that all claim to have the same predecessor.A [block body](#header-and-body) is just a sequence of transactions.
diff --git a/docs/website/contents/references/miscellaneous/utxo-hd/migrating.mdx b/docs/website/contents/references/miscellaneous/utxo-hd/migrating.mdx
index 0cd568960..bcfe52c3b 100644
--- a/docs/website/contents/references/miscellaneous/utxo-hd/migrating.mdx
+++ b/docs/website/contents/references/miscellaneous/utxo-hd/migrating.mdx
@@ -142,7 +142,7 @@ follows:
 </Tabs>
 </div>
 
-## Convert the existing Ledger snapshots with `snapshot-converter`
+## Upgrading a Ledger snapshots from 10.4.x to 10.5.x
 
 :::warning
 
@@ -157,8 +157,29 @@ chain from Genesis, however this can take some hours.
 
 We provide the `snapshot-converter` tool which can load a snapshot in the Legacy
 format and write it either in the in-memory or on-disk formats for
-UTxO-HD. Supposing you have copied a legacy snapshot to
-`<tmpdir>/snapshots/<slotno>` you can run the following command:
+UTxO-HD.
+
+:::info
+
+On cardano-node 10.6 there was a change in serialization unrelated to the
+UTxO-HD changes. This means that going from 10.4.x to 10.5.x can benefit from
+this doing a quick conversion using `snapshot-converter` as explained here, but
+it won't work when the target is 10.6 or newer. Such a format update can
+only be done via a replay of the chain.
+
+The `snapshot-converter` tool still exists in the repository and will convert
+between the different UTxO-HD formats but it will no longer be able to load a
+snapshot older than 10.6, and therefore it won't be able to "upgrade" a Legacy
+snapshot to a UTxO-HD snapshot anymore.
+
+For this reason, the process below is only useful for upgrading from 10.4.x to
+10.5.x, and **it must be performed with the `snapshot-converter` version that
+was released with nodes 10.5.x**.
+
+:::
+
+Supposing you have copied a legacy snapshot to `<tmpdir>/snapshots/<slotno>` you
+can run the following command:
 
 <div class="tabsblock">
 <Tabs>
diff --git a/flake.lock b/flake.lock
index 70f4df31e..4feaa3947 100644
--- a/flake.lock
+++ b/flake.lock
@@ -3,11 +3,11 @@
     "CHaP": {
       "flake": false,
       "locked": {
-        "lastModified": 1755770112,
-        "narHash": "sha256-BE9+swBBPBi9iRQNqsUNUjS02nyRF+OwfCkhIjted6I=",
+        "lastModified": 1759837865,
+        "narHash": "sha256-g8SMcVN1v51Muz6a+xJkB92mPx1jsg+sjHKvQ3Wj/jY=",
         "owner": "intersectmbo",
         "repo": "cardano-haskell-packages",
-        "rev": "7af503772adf627cd23be5431440a0ffae74de52",
+        "rev": "9a46cacd941c108492cd4cee5d29735e8cd8ee65",
         "type": "github"
       },
       "original": {
@@ -270,11 +270,11 @@
     "hackageNix": {
       "flake": false,
       "locked": {
-        "lastModified": 1755004253,
-        "narHash": "sha256-LPPqtFJEbeJHwnnTR0ir0XNw/4YPHBkJsZTAlFH6pfI=",
+        "lastModified": 1759314141,
+        "narHash": "sha256-eioqBX8q8H9lIj6bcG7JhwfN7Kg+OdpV1lkz7GS+/GI=",
         "owner": "input-output-hk",
         "repo": "hackage.nix",
-        "rev": "2cb556e80a10e46cd47651d3601a889416af0eb3",
+        "rev": "a58ee1f20b5db10c09beffc6d18505b6a253b84a",
         "type": "github"
       },
       "original": {
diff --git a/nix/haskell.nix b/nix/haskell.nix
index 9965d3937..a342ce058 100644
--- a/nix/haskell.nix
+++ b/nix/haskell.nix
@@ -28,11 +28,11 @@ let
         ghcOptions = [ "-Werror" ];
       }))
       {
-        # Options related to tasty-golden:
+        # Options related to tasty and tasty-golden:
         packages.ouroboros-consensus-cardano.components.tests =
           lib.listToAttrs (builtins.map
             (n: lib.nameValuePair "${n}-test" {
-              testFlags = lib.mkForce [ "--no-create" ];
+              testFlags = lib.mkForce [ "--no-create --hide-successes" ];
               extraSrcFiles = [ "golden/${n}/**/*" ];
             }) [ "byron" "shelley" "cardano" ]);
       }
@@ -89,9 +89,13 @@ in
     nativeBuildInputs = [
       final.fd
       final.cabal-docspec
-      (hsPkgs.ghcWithPackages
-        (ps: [ ps.latex-svg-image ] ++ lib.filter (p: p ? components.library)
-          (lib.attrValues (haskell-nix.haskellLib.selectProjectPackages ps))))
+      (hsPkgs.shellFor {
+        withHoogle = false;
+        exactDeps = true;
+        packages = _: [ ];
+        additional = (ps: [ ps.latex-svg-image ] ++ lib.filter (p: p ? components.library)
+          (lib.attrValues (haskell-nix.haskellLib.selectProjectPackages ps)));
+      }).ghc
       final.texliveFull
     ];
 
diff --git a/ouroboros-consensus-cardano/CHANGELOG.md b/ouroboros-consensus-cardano/CHANGELOG.md
index 0543b9ae0..698d3c960 100644
--- a/ouroboros-consensus-cardano/CHANGELOG.md
+++ b/ouroboros-consensus-cardano/CHANGELOG.md
@@ -2,6 +2,57 @@
 
 # Changelog entries
 
+<a id='changelog-0.26.0.0'></a>
+## 0.26.0.0 -- 2025-09-29
+
+### Patch
+
+- Adapted to changes related to `SelectView`.
+
+  Concretely, this changes the structure of `SelectView (BlockProtocol (CardanoBlock c))`, but it still contains the same data as before.
+
+- Bump `cardano-protocol-tpraos` to 1.4.1
+
+- Use the new `queryPoolState` ledger state query from ledger instead of extracting it from `NewEpochState`.
+
+- Fix LedgerTables deserialization for Byron snapshots.
+
+### Non-Breaking
+
+- Move `BlockProtocol (ShelleyBlock proto era)` instance to `Ouroboros.Consensus.Shelley.Ledger.Block`
+
+- Vendor Ledger's serialization of `PParams` and `ShelleyGenesis` prior to `ShelleyNodeToClientVersion12`.
+
+- Added `ShelleyNodeToClientVersion14` which adds SRV support in `GetBigLedgerPeerSnapshot` query.
+- Added `CardanoNodeToClientVersion18` which maps to `ShelleyNodeToClientVersion14`.
+
+### Breaking
+
+- Use new mlocked KES API for all internal KES sign key handling.
+- Add finalizers to all block forgings (required by `ouroboros-consensus`).
+- Change `ShelleyLeaderCredentials` to not contain the KES sign key itself
+  anymore. Instead, the `CanBeLeader` data structure now contains a
+  `praosCanBeLeaderCredentialsSource` field, which specifies how to obtain the
+  actual credentials (OpCert and KES SignKey).
+
+- Define new Node-To-Client versions `CardanoNodeToClientVersion17`, `ShelleyNodeToClientVersion13`.
+
+- Deprecate `GetPoolDistr` in favor of `GetPoolDistr2` (new in `NodeToClientV_21`).
+- Deprecate `GetStakeDistribution` in favor of `GetStakeDistribution2` (new in `NodeToClientV_21`).
+
+- Expose new query `GetMaxMajorProtocolVersion` as a Shelley query, for getting
+  the max known protocol version for a node.
+
+- Add Dijkstra era
+- Add dependency on the new Dijkstra Ledger package:
+  - `cardano-ledger-dijkstra`: `^>=0.1`
+
+- Delete the now unnecessary `Ouroboros.Consensus.Shelley.Eras.WrapTx` newtype wrapper.
+
+- Return full map instead of empty map from GetFilteredVoteDelegatees in the case where an empty set is passed.
+
+- `Tx Size` is now a `Word32` instead of an `Integer`, therefore `maxTxSizeUTxO` changed to expect `Word32`s.
+
 <a id='changelog-0.25.1.0'></a>
 ## 0.25.1.0 -- 2025-05-15
 
diff --git a/ouroboros-consensus-cardano/README.md b/ouroboros-consensus-cardano/README.md
index 5db3429ac..1c23387d8 100644
--- a/ouroboros-consensus-cardano/README.md
+++ b/ouroboros-consensus-cardano/README.md
@@ -20,6 +20,8 @@ This package also contains a few executables:
 
 * `app/immdb-server.hs`: serve an immutable DB via ChainSync and BlockFetch.
 
+* `app/snapshot-converter.hs`: converts snapshots among different storage formats.
+
 ### Assertions
 
 Our top level `cabal.project` enables assertions in both our local packages
@@ -369,12 +371,41 @@ The ChainSync miniprotocol will terminate with an exception when it receives a `
 To point a node to a running ImmDB server, use a topology file like
 ```json
 {
-  "Producers": [
+  "bootstrapPeers": [],
+  "localRoots": [
     {
-      "addr": "127.0.0.1",
-      "port": 3001,
+      "accessPoints": [
+        {
+          "address": "127.0.0.1",
+          "port": 3001
+        }
+      ],
+      "advertise": false,
+      "trustable": true,
       "valency": 1
     }
-  ]
+  ],
+  "publicRoots": []
 }
 ```
+
+See https://developers.cardano.org/docs/operate-a-stake-pool/node-operations/topology/ for more details.
+
+## snapshot-converter
+
+## About
+
+This tool converts snapshots among the different backends supported by the node.
+
+## Running the tool
+
+Invoking the tool follows the same simple pattern always:
+
+```sh
+cabal run snapshot-converter -- <IN> <OUT> --config /path/to/cardano/config.json
+```
+
+The `<IN>` and `<OUT>` parameters depend on the input and output format, receiving options:
+- `--mem-in PATH`/`--mem-out PATH` for InMemory
+- `--lmdb-in PATH`/`--lmdb-out PATH` for LMDB
+- `--lsm-database-in DB_PATH --lsm-snapshot-in PATH`/`--lsm-database-out DB_PATH --lsm-snapshot-out PATH` for LSM-trees.
diff --git a/ouroboros-consensus-cardano/app/DBAnalyser/Parsers.hs b/ouroboros-consensus-cardano/app/DBAnalyser/Parsers.hs
index 1b3587289..2253d623e 100644
--- a/ouroboros-consensus-cardano/app/DBAnalyser/Parsers.hs
+++ b/ouroboros-consensus-cardano/app/DBAnalyser/Parsers.hs
@@ -43,21 +43,21 @@ parseDBAnalyserConfig =
     <*> parseAnalysis
     <*> parseLimit
     <*> Foldable.asum
-      [ flag' V1InMem $
-          mconcat
-            [ long "v1-in-mem"
-            , help "use v1 in-memory backing store"
-            ]
-      , flag' V1LMDB $
+      [ flag' V1LMDB $
           mconcat
             [ long "lmdb"
             , help "use v1 LMDB backing store"
             ]
       , flag' V2InMem $
           mconcat
-            [ long "v2-in-mem"
+            [ long "in-mem"
             , help "use v2 in-memory backend"
             ]
+      , flag' V2LSM $
+          mconcat
+            [ long "lsm"
+            , help "use v2 LSM backend"
+            ]
       ]
 
 parseSelectDB :: Parser SelectDB
diff --git a/ouroboros-consensus-cardano/app/DBSynthesizer/Parsers.hs b/ouroboros-consensus-cardano/app/DBSynthesizer/Parsers.hs
index a4cb4ab76..4aee21cdc 100644
--- a/ouroboros-consensus-cardano/app/DBSynthesizer/Parsers.hs
+++ b/ouroboros-consensus-cardano/app/DBSynthesizer/Parsers.hs
@@ -71,7 +71,7 @@ parseOperationalCertFilePath =
   strOption
     ( long "shelley-operational-certificate"
         <> metavar "FILE"
-        <> help "Path to the delegation certificate"
+        <> help "Path to the delegation certificate (in JSON TextEnvelope format)"
         <> completer (bashCompleter "file")
     )
 
@@ -80,7 +80,7 @@ parseKesKeyFilePath =
   strOption
     ( long "shelley-kes-key"
         <> metavar "FILE"
-        <> help "Path to the KES signing key"
+        <> help "Path to the KES signing key (in JSON TextEnvelope format)"
         <> completer (bashCompleter "file")
     )
 
@@ -89,7 +89,7 @@ parseVrfKeyFilePath =
   strOption
     ( long "shelley-vrf-key"
         <> metavar "FILE"
-        <> help "Path to the VRF signing key"
+        <> help "Path to the VRF signing key (in JSON TextEnvelope format)"
         <> completer (bashCompleter "file")
     )
 
@@ -98,7 +98,8 @@ parseBulkFilePath =
   strOption
     ( long "bulk-credentials-file"
         <> metavar "FILE"
-        <> help "Path to the bulk credentials file"
+        <> help
+          "Path to the bulk credentials file (a JSON file containing an array of arrays containing 3 TextEnvelope objects for the opcert, VRF Signing key, KES signing key)"
         <> completer (bashCompleter "file")
     )
 
diff --git a/ouroboros-consensus-cardano/app/Ouroboros/Consensus/Cardano/StreamingLedgerTables.hs b/ouroboros-consensus-cardano/app/Ouroboros/Consensus/Cardano/StreamingLedgerTables.hs
new file mode 100644
index 000000000..693ae277b
--- /dev/null
+++ b/ouroboros-consensus-cardano/app/Ouroboros/Consensus/Cardano/StreamingLedgerTables.hs
@@ -0,0 +1,114 @@
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeOperators #-}
+
+module Ouroboros.Consensus.Cardano.StreamingLedgerTables
+  ( mkInMemYieldArgs
+  , mkInMemSinkArgs
+  ) where
+
+import Cardano.Ledger.Binary
+import Cardano.Ledger.Core (ByronEra, Era, eraDecoder, toEraCBOR)
+import qualified Cardano.Ledger.Shelley.API as SL
+import qualified Cardano.Ledger.Shelley.LedgerState as SL
+import qualified Cardano.Ledger.State as SL
+import qualified Codec.CBOR.Encoding
+import Control.ResourceRegistry
+import Data.Proxy
+import Data.SOP.BasicFunctors
+import Data.SOP.Functors
+import Data.SOP.Strict
+import qualified Data.SOP.Telescope as Telescope
+import Lens.Micro
+import Ouroboros.Consensus.Byron.Ledger
+import Ouroboros.Consensus.Cardano.Block
+import Ouroboros.Consensus.Cardano.Ledger
+import Ouroboros.Consensus.HardFork.Combinator
+import Ouroboros.Consensus.HardFork.Combinator.State
+import Ouroboros.Consensus.Ledger.Abstract
+import Ouroboros.Consensus.Shelley.Ledger
+import Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol ()
+import Ouroboros.Consensus.Storage.LedgerDB.API
+import Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as V2
+import System.Directory
+import System.FS.API
+import System.FS.IO
+
+type L = LedgerState (CardanoBlock StandardCrypto)
+
+mkInMemYieldArgs :: FilePath -> L EmptyMK -> ResourceRegistry IO -> IO (YieldArgs IO V2.Mem L)
+mkInMemYieldArgs fp (HardForkLedgerState (HardForkState idx)) _ =
+  let
+    np ::
+      NP
+        (Current (Flip LedgerState EmptyMK) -.-> K (Decoders L))
+        (CardanoEras StandardCrypto)
+    np =
+      (Fn $ const $ K $ error "Byron")
+        :* (Fn $ K . fromEra ShelleyTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra AllegraTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra MaryTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra AlonzoTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra BabbageTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra ConwayTxOut . unFlip . currentState)
+        :* (Fn $ K . fromEra DijkstraTxOut . unFlip . currentState)
+        :* Nil
+   in
+    pure $
+      YieldInMemory
+        (SomeHasFS . ioHasFS)
+        fp
+        (hcollapse $ hap np $ Telescope.tip idx)
+ where
+  fromEra ::
+    forall proto era.
+    ShelleyCompatible proto era =>
+    (TxOut (LedgerState (ShelleyBlock proto era)) -> CardanoTxOut StandardCrypto) ->
+    LedgerState (ShelleyBlock proto era) EmptyMK ->
+    Decoders L
+  fromEra toCardanoTxOut st =
+    let certInterns =
+          internsFromMap $
+            shelleyLedgerState st
+              ^. SL.nesEsL
+                . SL.esLStateL
+                . SL.lsCertStateL
+                . SL.certDStateL
+                . SL.accountsL
+                . SL.accountsMapL
+     in Decoders
+          (eraDecoder @era decodeMemPack)
+          (eraDecoder @era $ toCardanoTxOut <$> decShareCBOR certInterns)
+
+mkInMemSinkArgs ::
+  FilePath ->
+  L EmptyMK ->
+  ResourceRegistry IO ->
+  IO (SinkArgs IO V2.Mem L)
+mkInMemSinkArgs fp (HardForkLedgerState (HardForkState idx)) _ = do
+  currDir <- getCurrentDirectory
+  let
+    np =
+      (Fn $ const $ K $ encOne (Proxy @ByronEra))
+        :* (Fn $ const $ K $ encOne (Proxy @ShelleyEra))
+        :* (Fn $ const $ K $ encOne (Proxy @AllegraEra))
+        :* (Fn $ const $ K $ encOne (Proxy @MaryEra))
+        :* (Fn $ const $ K $ encOne (Proxy @AlonzoEra))
+        :* (Fn $ const $ K $ encOne (Proxy @BabbageEra))
+        :* (Fn $ const $ K $ encOne (Proxy @ConwayEra))
+        :* (Fn $ const $ K $ encOne (Proxy @DijkstraEra))
+        :* Nil
+  pure $
+    uncurry
+      (SinkInMemory 1000)
+      (hcollapse $ hap np $ Telescope.tip idx)
+      (SomeHasFS $ ioHasFS $ MountPoint currDir)
+      fp
+ where
+  encOne ::
+    forall era.
+    Era era =>
+    Proxy era ->
+    (TxIn L -> Codec.CBOR.Encoding.Encoding, TxOut L -> Codec.CBOR.Encoding.Encoding)
+  encOne _ =
+    (toEraCBOR @era . encodeMemPack, toEraCBOR @era . eliminateCardanoTxOut (const encodeMemPack))
diff --git a/ouroboros-consensus-cardano/app/snapshot-converter.hs b/ouroboros-consensus-cardano/app/snapshot-converter.hs
index 7c3eba6b4..6802074a0 100644
--- a/ouroboros-consensus-cardano/app/snapshot-converter.hs
+++ b/ouroboros-consensus-cardano/app/snapshot-converter.hs
@@ -1,9 +1,12 @@
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE TupleSections #-}
+{-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE ViewPatterns #-}
 
 module Main (main) where
@@ -13,261 +16,554 @@ import Cardano.Tools.DBAnalyser.HasAnalysis (mkProtocolInfo)
 import Codec.Serialise
 import qualified Control.Monad as Monad
 import Control.Monad.Except
-import qualified Control.Monad.Trans as Trans (lift)
-import Control.ResourceRegistry (ResourceRegistry)
-import qualified Control.ResourceRegistry as RR
-import Control.Tracer (nullTracer)
+import Control.Monad.Trans (lift)
+import Control.ResourceRegistry
 import DBAnalyser.Parsers
 import Data.Bifunctor
-import qualified Data.ByteString.Builder as BS
-import qualified Data.SOP.Dict as Dict
+import Data.Char (toLower)
+import qualified Data.Text.Lazy as T
 import Main.Utf8
 import Options.Applicative
+import Options.Applicative.Help (Doc, line)
 import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Cardano.Block
+import Ouroboros.Consensus.Cardano.StreamingLedgerTables
 import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.Ledger.Basics
 import Ouroboros.Consensus.Ledger.Extended
-import Ouroboros.Consensus.Ledger.SupportsProtocol
-import Ouroboros.Consensus.Ledger.Tables.Utils
 import Ouroboros.Consensus.Node.ProtocolInfo
-import Ouroboros.Consensus.Storage.LedgerDB
+import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Args as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.DbChangelog as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Lock as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as V2
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq as V2
+import Ouroboros.Consensus.Storage.LedgerDB.V2.LSM
 import Ouroboros.Consensus.Util.CRC
-import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.IOLike hiding (yield)
+import System.Console.ANSI
+import qualified System.Directory as D
+import System.Exit
 import System.FS.API
-import System.FS.API.Lazy
 import System.FS.CRC
 import System.FS.IO
-import System.FilePath (splitFileName)
-import System.IO.Temp
+import System.FilePath (splitDirectories)
+import qualified System.FilePath as F
+import System.IO
+import System.ProgressBar
+import System.Random
 
 data Format
-  = Legacy
-  | Mem
-  | LMDB
+  = Mem FilePath
+  | LMDB FilePath
+  | LSM FilePath FilePath
   deriving (Show, Read)
 
 data Config = Config
   { from :: Format
   -- ^ Which format the input snapshot is in
-  , inpath :: FilePath
-  -- ^ Path to the input snapshot
   , to :: Format
   -- ^ Which format the output snapshot must be in
-  , outpath :: FilePath
-  -- ^ Path to the output snapshot
   }
 
 getCommandLineConfig :: IO (Config, CardanoBlockArgs)
 getCommandLineConfig =
   execParser $
     info
-      ((,) <$> parseConfig <*> parseCardanoArgs <**> helper)
-      (fullDesc <> progDesc "Utility for converting snapshots to and from UTxO-HD")
-
-parseConfig :: Parser Config
-parseConfig =
-  Config
-    <$> argument
-      auto
-      ( mconcat
-          [ help "From format (Legacy, Mem or LMDB)"
-          , metavar "FORMAT-IN"
-          ]
-      )
-    <*> strArgument
-      ( mconcat
-          [ help "Input dir/file. Use relative paths like ./100007913"
-          , metavar "PATH-IN"
-          ]
+      ((,) <$> (Config <$> parseConfig In <*> parseConfig Out) <*> parseCardanoArgs <**> helper)
+      ( fullDesc
+          <> header "Utility for converting snapshots among the different snapshot formats used by cardano-node."
+          <> progDescDoc programDescription
       )
-    <*> argument
-      auto
-      ( mconcat
-          [ help "To format (Legacy, Mem or LMDB)"
-          , metavar "FORMAT-OUT"
+
+programDescription :: Maybe Doc
+programDescription =
+  Just $
+    mconcat
+      [ "The input snapshot must correspond to a snapshot that was produced by "
+      , "a cardano-node, and thus follows the naming convention used in the node."
+      , line
+      , "This means in particular that the filepath to the snapshot must have as "
+      , "the last fragment a directory named after the slot number of the ledger "
+      , "state snapshotted, plus an optional suffix, joined by an underscore."
+      , line
+      , line
+      , "For the output, the same convention is enforced, so that the produced "
+      , "snapshot can be loaded right away by a cardano-node."
+      , line
+      , line
+      , "Note that snapshots that have a suffix will be preserved by the node. "
+      , "If you produce a snapshot with a suffix and you start a node with it, "
+      , "the node will take as many more snapshots as it is configured to take, "
+      , "but it will never delete your snapshot, because it has a suffix on the name."
+      , line
+      , "Therefore, for the most common use case it is advisable to create a "
+      , "snapshot without a suffix, as in:"
+      , line
+      , line
+      , "```"
+      , line
+      , "$ mkdir out"
+      , line
+      , "$ snapshot-converter --<fmt>-in <some-path>/<slot> --<fmt>-out out/<slot> --config <path-to-config.json>"
+      , line
+      , "```"
+      ]
+
+data InOut = In | Out
+
+inoutForGroup :: InOut -> String
+inoutForGroup In = "Input arguments:"
+inoutForGroup Out = "Output arguments:"
+
+inoutForHelp :: InOut -> String -> Bool -> String
+inoutForHelp In s b =
+  mconcat $
+    ("Input " <> s)
+      : if b
+        then
+          [ ". Must be a filepath where the last fragment is named after the "
+          , "slot of the snapshotted state plus an optional suffix. Example: `1645330287_suffix`."
           ]
-      )
-    <*> strArgument
-      ( mconcat
-          [ help "Output dir/file Use relative paths like ./100007913"
-          , metavar "PATH-OUT"
+        else []
+inoutForHelp Out s b =
+  mconcat $
+    ("Output " <> s)
+      : if b
+        then
+          [ ". Must be a filepath where the last fragment is named after the "
+          , "slot of the snapshotted state plus an optional suffix. Example: `1645330287_suffix`."
           ]
-      )
+        else []
 
--- Helpers
+inoutForCommand :: InOut -> String -> String
+inoutForCommand In = (++ "-in")
+inoutForCommand Out = (++ "-out")
 
-pathToDiskSnapshot :: FilePath -> Maybe (SomeHasFS IO, FsPath, DiskSnapshot)
-pathToDiskSnapshot path = (SomeHasFS $ ioHasFS $ MountPoint dir,mkFsPath [file],) <$> snapshotFromPath file
- where
-  (dir, file) = splitFileName path
+parseConfig :: InOut -> Parser Format
+parseConfig io =
+  ( Mem
+      <$> parserOptionGroup
+        (inoutForGroup io)
+        (parsePath (inoutForCommand io "mem") (inoutForHelp io "snapshot dir" True))
+  )
+    <|> ( LMDB
+            <$> parserOptionGroup
+              (inoutForGroup io)
+              (parsePath (inoutForCommand io "lmdb") (inoutForHelp io "snapshot dir" True))
+        )
+    <|> ( LSM
+            <$> parserOptionGroup
+              (inoutForGroup io)
+              (parsePath (inoutForCommand io "lsm-snapshot") (inoutForHelp io "snapshot dir" True))
+            <*> parserOptionGroup
+              (inoutForGroup io)
+              (parsePath (inoutForCommand io "lsm-database") (inoutForHelp io "LSM database" False))
+        )
 
-defaultLMDBLimits :: V1.LMDBLimits
-defaultLMDBLimits =
-  V1.LMDBLimits
-    { V1.lmdbMapSize = 16 * 1024 * 1024 * 1024
-    , V1.lmdbMaxDatabases = 10
-    , V1.lmdbMaxReaders = 16
-    }
+parsePath :: String -> String -> Parser FilePath
+parsePath optName strHelp =
+  strOption
+    ( mconcat
+        [ long optName
+        , help strHelp
+        , metavar "PATH"
+        ]
+    )
 
 data Error blk
   = SnapshotError (SnapshotFailure blk)
-  | TablesCantDeserializeError DeserialiseFailure
-  | TablesTrailingBytes
-  | SnapshotFormatMismatch Format String
-  | ReadSnapshotCRCError FsPath CRCError
+  | BadDirectoryName FilePath
+  | WrongSlotDirectoryName FilePath SlotNo
+  | InvalidMetadata String
+  | BackendMismatch SnapshotBackend SnapshotBackend
+  | CRCMismatch CRC CRC
+  | ReadTablesError DeserialiseFailure
+  | Cancelled
   deriving Exception
 
 instance StandardHash blk => Show (Error blk) where
   show (SnapshotError err) =
     "Couldn't deserialize the snapshot. Are you running the same node version that created the snapshot? "
       <> show err
-  show (TablesCantDeserializeError err) = "Couldn't deserialize the tables: " <> show err
-  show TablesTrailingBytes = "Malformed tables, there are trailing bytes!"
-  show (SnapshotFormatMismatch expected err) =
-    "The input snapshot does not seem to correspond to the input format:\n\t"
-      <> show expected
-      <> "\n\tThe provided path "
-      <> err
-  show (ReadSnapshotCRCError fp err) = "An error occurred while reading the snapshot checksum at " <> show fp <> ": \n\t" <> show err
-
-checkSnapshotFileStructure :: Format -> FsPath -> SomeHasFS IO -> ExceptT (Error blk) IO ()
-checkSnapshotFileStructure m p (SomeHasFS fs) = case m of
-  Legacy -> want (doesFileExist fs) p "is NOT a file"
-  Mem -> newFormatCheck "tvar"
-  LMDB -> newFormatCheck "data.mdb"
- where
-  want :: (FsPath -> IO Bool) -> FsPath -> String -> ExceptT (Error blk) IO ()
-  want fileType path err = do
-    exists <- Trans.lift $ fileType path
-    Monad.unless exists $ throwError $ SnapshotFormatMismatch m err
-
-  isDir = (doesDirectoryExist, [], "is NOT a directory")
-  hasTablesDir = (doesDirectoryExist, ["tables"], "DOES NOT contain a \"tables\" directory")
-  hasState = (doesFileExist, ["state"], "DOES NOT contain a \"state\" file")
-  hasTables tb = (doesFileExist, ["tables", tb], "DOES NOT contain a \"tables/" <> tb <> "\" file")
-
-  newFormatCheck tb =
-    mapM_
-      (\(doCheck, extra, err) -> want (doCheck fs) (p </> mkFsPath extra) err)
-      [ isDir
-      , hasTablesDir
-      , hasState
-      , hasTables tb
+  show (BadDirectoryName fp) =
+    mconcat
+      [ "Filepath "
+      , fp
+      , " is not an snapshot. The last fragment on the path should be"
+      , " named after the slot number of the state it contains and an"
+      , " optional suffix, such as `163470034` or `163470034_my-suffix`."
+      ]
+  show (InvalidMetadata s) = "Metadata is invalid: " <> s
+  show (BackendMismatch b1 b2) =
+    mconcat
+      [ "Mismatched backend in snapshot. Reading as "
+      , show b1
+      , " but snapshot is "
+      , show b2
       ]
+  show (WrongSlotDirectoryName fp sl) =
+    mconcat
+      [ "The name of the snapshot (\""
+      , fp
+      , "\") does not correspond to the slot number of the state ("
+      , (show . unSlotNo $ sl)
+      , ")."
+      ]
+  show (CRCMismatch c1 c2) =
+    mconcat
+      [ "The input snapshot seems corrupted. Metadata has CRC "
+      , show c1
+      , " but reading it gives CRC "
+      , show c2
+      ]
+  show (ReadTablesError df) =
+    mconcat
+      ["Error when reading entries in the UTxO tables: ", show df]
+  show Cancelled = "Cancelled"
+
+data InEnv backend = InEnv
+  { inState :: LedgerState (CardanoBlock StandardCrypto) EmptyMK
+  , inFilePath :: FilePath
+  , inStream ::
+      LedgerState (CardanoBlock StandardCrypto) EmptyMK ->
+      ResourceRegistry IO ->
+      IO (SomeBackend YieldArgs)
+  , inProgressMsg :: String
+  , inCRC :: CRC
+  , inSnapReadCRC :: Maybe CRC
+  }
 
-load ::
-  forall blk.
-  ( CanStowLedgerTables (LedgerState blk)
-  , LedgerSupportsProtocol blk
-  , LedgerSupportsLedgerDB blk
-  ) =>
-  Config ->
-  ResourceRegistry IO ->
-  CodecConfig blk ->
-  FilePath ->
-  ExceptT (Error blk) IO (ExtLedgerState blk EmptyMK, LedgerTables (ExtLedgerState blk) ValuesMK)
-load config@Config{inpath = pathToDiskSnapshot -> Just (fs@(SomeHasFS hasFS), path, ds)} rr ccfg tempFP =
-  case from config of
-    Legacy -> do
-      checkSnapshotFileStructure Legacy path fs
-      (st, checksumAsRead) <-
-        first unstowLedgerTables
-          <$> withExceptT
-            (SnapshotError . InitFailureRead . ReadSnapshotFailed)
-            (readExtLedgerState fs (decodeDiskExtLedgerState ccfg) decode path)
-      let crcPath = path <.> "checksum"
-      crcFileExists <- Trans.lift $ doesFileExist hasFS crcPath
-      Monad.when crcFileExists $ do
-        snapshotCRC <-
-          withExceptT (ReadSnapshotCRCError crcPath) $
-            readCRC hasFS crcPath
-        Monad.when (checksumAsRead /= snapshotCRC) $
-          throwError $
-            SnapshotError $
-              InitFailureRead ReadSnapshotDataCorruption
-      pure (forgetLedgerTables st, projectLedgerTables st)
-    Mem -> do
-      checkSnapshotFileStructure Mem path fs
-      (ls, _) <- withExceptT SnapshotError $ V2.loadSnapshot nullTracer rr ccfg fs ds
-      let h = V2.currentHandle ls
-      (V2.state h,) <$> Trans.lift (V2.readAll (V2.tables h))
-    LMDB -> do
-      checkSnapshotFileStructure LMDB path fs
-      ((dbch, k, bstore), _) <-
-        withExceptT SnapshotError $
-          V1.loadSnapshot
-            nullTracer
-            (V1.LMDBBackingStoreArgs tempFP defaultLMDBLimits Dict.Dict)
-            ccfg
-            (V1.SnapshotsFS fs)
-            rr
-            ds
-      values <- Trans.lift (V1.bsReadAll bstore (V1.changelogLastFlushedState dbch))
-      _ <- Trans.lift $ RR.release k
-      pure (V1.current dbch, values)
-load _ _ _ _ = error "Malformed input path!"
-
-store ::
-  ( CanStowLedgerTables (LedgerState blk)
-  , LedgerSupportsProtocol blk
-  , LedgerSupportsLedgerDB blk
-  ) =>
-  Config ->
-  CodecConfig blk ->
-  (ExtLedgerState blk EmptyMK, LedgerTables (ExtLedgerState blk) ValuesMK) ->
-  SomeHasFS IO ->
-  IO ()
-store config@Config{outpath = pathToDiskSnapshot -> Just (fs@(SomeHasFS hasFS), path, DiskSnapshot _ suffix)} ccfg (state, tbs) tempFS =
-  case to config of
-    Legacy -> do
-      crc <-
-        writeExtLedgerState
-          fs
-          (encodeDiskExtLedgerState ccfg)
-          path
-          (stowLedgerTables $ state `withLedgerTables` tbs)
-      withFile hasFS (path <.> "checksum") (WriteMode MustBeNew) $ \h ->
-        Monad.void $ hPutAll hasFS h . BS.toLazyByteString . BS.word32HexFixed $ getCRC crc
-    Mem -> do
-      lseq <- V2.empty state tbs $ V2.newInMemoryLedgerTablesHandle nullTracer fs
-      let h = V2.currentHandle lseq
-      Monad.void $ V2.implTakeSnapshot ccfg nullTracer fs suffix h
-    LMDB -> do
-      chlog <- newTVarIO (V1.empty state)
-      lock <- V1.mkLedgerDBLock
-      bs <-
-        V1.newLMDBBackingStore
-          nullTracer
-          defaultLMDBLimits
-          (V1.LiveLMDBFS tempFS)
-          (V1.SnapshotsFS fs)
-          (V1.InitFromValues (pointSlot $ getTip state) state tbs)
-      Monad.void $ V1.withReadLock lock $ do
-        V1.implTakeSnapshot chlog ccfg nullTracer (V1.SnapshotsFS fs) bs suffix
-store _ _ _ _ = error "Malformed output path!"
+data SomeBackend c where
+  SomeBackend ::
+    StreamingBackend IO backend (LedgerState (CardanoBlock StandardCrypto)) =>
+    c IO backend (LedgerState (CardanoBlock StandardCrypto)) -> SomeBackend c
+
+data OutEnv backend = OutEnv
+  { outFilePath :: FilePath
+  , outStream ::
+      LedgerState (CardanoBlock StandardCrypto) EmptyMK ->
+      ResourceRegistry IO ->
+      IO (SomeBackend SinkArgs)
+  , outCreateExtra :: Maybe FilePath
+  , outDeleteExtra :: Maybe FilePath
+  , outProgressMsg :: String
+  , outBackend :: SnapshotBackend
+  }
 
 main :: IO ()
 main = withStdTerminalHandles $ do
-  cryptoInit
-  uncurry run =<< getCommandLineConfig
+  eRes <- runExceptT main'
+  case eRes of
+    Left err -> do
+      putStrLn $ show err
+      exitFailure
+    Right () -> exitSuccess
  where
-  run conf args = do
-    ccfg <- configCodec . pInfoConfig <$> mkProtocolInfo args
-    withSystemTempDirectory "lmdb" $ \dir -> do
-      let tempFS = SomeHasFS $ ioHasFS $ MountPoint dir
-      RR.withRegistry $ \rr -> do
-        putStrLn "Loading snapshot..."
-        state <- either throwIO pure =<< runExceptT (load conf rr ccfg dir)
-        putStrLn "Loaded snapshot"
-        putStrLn "Writing snapshot..."
-        store conf ccfg state tempFS
-        putStrLn "Written snapshot"
+  main' = do
+    lift $ cryptoInit
+    (conf, args) <- lift $ getCommandLineConfig
+    ccfg <- lift $ configCodec . pInfoConfig <$> mkProtocolInfo args
+
+    InEnv{..} <- getInEnv ccfg (from conf)
+
+    o@OutEnv{..} <- getOutEnv inState (to conf)
+
+    wipeOutputPaths o
+
+    lift $ putStr "Copying state file..." >> hFlush stdout
+    lift $ D.copyFile (inFilePath F.</> "state") (outFilePath F.</> "state")
+    lift $ putColored Green True "Done"
+
+    lift $ putStr "Streaming ledger tables..." >> hFlush stdout >> saveCursor
+
+    tid <- lift $ niceAnimatedProgressBar inProgressMsg outProgressMsg
+
+    eRes <- lift $ runExceptT (stream inState inStream outStream)
+
+    case eRes of
+      Left err -> throwError $ ReadTablesError err
+      Right (mCRCIn, mCRCOut) -> do
+        lift $ maybe (pure ()) cancel tid
+        lift $ clearLine >> restoreCursor >> cursorUp 1 >> putColored Green True "Done"
+        let crcIn = maybe inCRC (crcOfConcat inCRC) mCRCIn
+        maybe
+          ( lift $
+              putColored Yellow True "The metadata file is missing, the snapshot is not guaranteed to be correct!"
+          )
+          ( \cs ->
+              Monad.when (cs /= crcIn) $ throwError $ CRCMismatch cs crcIn
+          )
+          inSnapReadCRC
+
+        let crcOut = maybe inCRC (crcOfConcat inCRC) mCRCOut
+
+        lift $ putStr "Generating new metadata file..." >> hFlush stdout
+        putMetadata outFilePath (SnapshotMetadata outBackend crcOut TablesCodecVersion1)
+
+        lift $ putColored Green True "Done"
+
+  wipeOutputPaths OutEnv{..} = do
+    wipePath outFilePath
+    lift $ maybe (pure ()) (D.createDirectory . (outFilePath F.</>)) outCreateExtra
+    maybe
+      (pure ())
+      wipePath
+      outDeleteExtra
+
+  getState ccfg fp@(pathToHasFS -> fs) = do
+    eState <- lift $ do
+      putStr $ "Reading ledger state from " <> (fp F.</> "state") <> "..."
+      hFlush stdout
+      runExceptT (readExtLedgerState fs (decodeDiskExtLedgerState ccfg) decode (mkFsPath ["state"]))
+    case eState of
+      Left err ->
+        throwError . SnapshotError . InitFailureRead @(CardanoBlock StandardCrypto) . ReadSnapshotFailed $
+          err
+      Right st -> lift $ do
+        putColored Green True " Done"
+        pure . first ledgerState $ st
+
+  getMetadata fp bknd = do
+    (fs, ds) <- toDiskSnapshot fp
+    mtd <-
+      lift $ runExceptT $ loadSnapshotMetadata fs ds
+    (,ds)
+      <$> either
+        ( \case
+            MetadataFileDoesNotExist -> pure Nothing
+            MetadataInvalid s -> throwError $ InvalidMetadata s
+            MetadataBackendMismatch -> error "impossible"
+        )
+        ( \mtd' -> do
+            if bknd /= snapshotBackend mtd'
+              then throwError $ BackendMismatch bknd (snapshotBackend mtd')
+              else pure $ Just $ snapshotChecksum mtd'
+        )
+        mtd
+
+  putMetadata fp bknd = do
+    (fs, ds) <- toDiskSnapshot fp
+    lift $ writeSnapshotMetadata fs ds bknd
+
+  getInEnv ccfg = \case
+    Mem fp -> do
+      (mtd, ds) <- getMetadata fp UTxOHDMemSnapshot
+      (st, c) <- getState ccfg fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              ( withOrigin
+                  ( error
+                      "Impossible! the snapshot seems to be at Genesis but cardano-node would never create such an snapshot!"
+                  )
+                  id
+                  $ pointSlot (getTip st)
+              )
+        )
+
+      pure $
+        InEnv
+          st
+          fp
+          (\a b -> SomeBackend <$> mkInMemYieldArgs (fp F.</> "tables") a b)
+          ("InMemory@[" <> fp <> "]")
+          c
+          mtd
+    LMDB fp -> do
+      (mtd, ds) <- getMetadata fp UTxOHDLMDBSnapshot
+      (st, c) <- getState ccfg fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              (withOrigin undefined id $ pointSlot (getTip st))
+        )
+
+      pure $
+        InEnv
+          st
+          fp
+          (\a b -> SomeBackend <$> V1.mkLMDBYieldArgs (fp F.</> "tables") defaultLMDBLimits a b)
+          ("LMDB@[" <> fp <> "]")
+          c
+          mtd
+    LSM fp lsmDbPath -> do
+      (mtd, ds) <- getMetadata fp UTxOHDLSMSnapshot
+      (st, c) <- getState ccfg fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              (withOrigin undefined id $ pointSlot (getTip st))
+        )
+
+      pure $
+        InEnv
+          st
+          fp
+          ( \a b ->
+              SomeBackend <$> mkLSMYieldArgs lsmDbPath (last $ splitDirectories fp) stdMkBlockIOFS newStdGen a b
+          )
+          ("LSM@[" <> lsmDbPath <> "]")
+          c
+          mtd
+
+  getOutEnv st = \case
+    Mem fp -> do
+      (_, ds) <- toDiskSnapshot fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              (withOrigin undefined id $ pointSlot (getTip st))
+        )
+      pure $
+        OutEnv
+          fp
+          (\a b -> SomeBackend <$> mkInMemSinkArgs (fp F.</> "tables") a b)
+          (Just "tables")
+          (Nothing)
+          ("InMemory@[" <> fp <> "]")
+          UTxOHDMemSnapshot
+    LMDB fp -> do
+      (_, ds) <- toDiskSnapshot fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              (withOrigin undefined id $ pointSlot (getTip st))
+        )
+      pure $
+        OutEnv
+          fp
+          (\a b -> SomeBackend <$> V1.mkLMDBSinkArgs fp defaultLMDBLimits a b)
+          Nothing
+          Nothing
+          ("LMDB@[" <> fp <> "]")
+          UTxOHDLMDBSnapshot
+    LSM fp lsmDbPath -> do
+      (_, ds) <- toDiskSnapshot fp
+      Monad.when
+        ((unSlotNo <$> pointSlot (getTip st)) /= NotOrigin (dsNumber ds))
+        ( throwError $
+            WrongSlotDirectoryName
+              (snapshotToDirName ds)
+              (withOrigin undefined id $ pointSlot (getTip st))
+        )
+      pure $
+        OutEnv
+          fp
+          ( \a b ->
+              SomeBackend <$> mkLSMSinkArgs lsmDbPath (last $ splitDirectories fp) stdMkBlockIOFS newStdGen a b
+          )
+          Nothing
+          (Just lsmDbPath)
+          ("LSM@[" <> lsmDbPath <> "]")
+          UTxOHDLSMSnapshot
+
+stream ::
+  LedgerState (CardanoBlock StandardCrypto) EmptyMK ->
+  ( LedgerState (CardanoBlock StandardCrypto) EmptyMK ->
+    ResourceRegistry IO ->
+    IO (SomeBackend YieldArgs)
+  ) ->
+  ( LedgerState (CardanoBlock StandardCrypto) EmptyMK ->
+    ResourceRegistry IO ->
+    IO (SomeBackend SinkArgs)
+  ) ->
+  ExceptT DeserialiseFailure IO (Maybe CRC, Maybe CRC)
+stream st mYieldArgs mSinkArgs =
+  ExceptT $
+    withRegistry $ \reg -> do
+      (SomeBackend (yArgs :: YieldArgs IO backend1 l)) <- mYieldArgs st reg
+      (SomeBackend (sArgs :: SinkArgs IO backend2 l)) <- mSinkArgs st reg
+      runExceptT $ yield (Proxy @backend1) yArgs st $ sink (Proxy @backend2) sArgs st
+
+-- Helpers
+
+-- UI
+niceAnimatedProgressBar :: String -> String -> IO (Maybe (Async IO ()))
+niceAnimatedProgressBar inMsg outMsg = do
+  stdoutSupportsANSI <- hNowSupportsANSI stdout
+  if stdoutSupportsANSI
+    then do
+      putStrLn ""
+      pb <-
+        newProgressBar
+          defStyle{stylePrefix = msg (T.pack inMsg), stylePostfix = msg (T.pack outMsg)}
+          10
+          (Progress 1 100 ())
+
+      fmap Just $
+        async $
+          let loop = do
+                threadDelay 0.2
+                updateProgress pb (\prg -> prg{progressDone = (progressDone prg + 4) `mod` 100})
+           in Monad.forever loop
+    else pure Nothing
+
+putColored :: Color -> Bool -> String -> IO ()
+putColored c b s = do
+  stdoutSupportsANSI <- hNowSupportsANSI stdout
+  Monad.when stdoutSupportsANSI $ setSGR [SetColor Foreground Vivid c]
+  if b
+    then
+      putStrLn s
+    else
+      putStr s
+  Monad.when stdoutSupportsANSI $ setSGR [Reset]
+  hFlush stdout
+
+askForConfirmation ::
+  ExceptT (Error (CardanoBlock StandardCrypto)) IO a ->
+  String ->
+  ExceptT (Error (CardanoBlock StandardCrypto)) IO a
+askForConfirmation act infoMsg = do
+  lift $ putColored Yellow False $ "I'm going to " <> infoMsg <> ". Continue? (Y/n) "
+  answer <- lift $ getLine
+  case map toLower answer of
+    "y" -> act
+    _ -> throwError Cancelled
+
+-- | Ask before deleting
+wipePath :: FilePath -> ExceptT (Error (CardanoBlock StandardCrypto)) IO ()
+wipePath fp = do
+  exists <- lift $ D.doesDirectoryExist fp
+  ( if exists
+      then flip askForConfirmation ("wipe the path " <> fp)
+      else id
+    )
+    (lift $ D.removePathForcibly fp >> D.createDirectoryIfMissing True fp)
+
+toDiskSnapshot ::
+  FilePath -> ExceptT (Error (CardanoBlock StandardCrypto)) IO (SomeHasFS IO, DiskSnapshot)
+toDiskSnapshot fp@(F.splitFileName . maybeRemoveTrailingSlash -> (snapPath, snapName)) =
+  maybe
+    (throwError $ BadDirectoryName fp)
+    (pure . (pathToHasFS snapPath,))
+    $ snapshotFromPath snapName
+
+-- | Given a filepath pointing to a snapshot (with or without a trailing slash), produce:
+--
+-- * A HasFS at the snapshot directory
+pathToHasFS :: FilePath -> SomeHasFS IO
+pathToHasFS (maybeRemoveTrailingSlash -> path) =
+  SomeHasFS $ ioHasFS $ MountPoint path
+
+maybeRemoveTrailingSlash :: String -> String
+maybeRemoveTrailingSlash s = case last s of
+  '/' -> init s
+  '\\' -> init s
+  _ -> s
+
+defaultLMDBLimits :: V1.LMDBLimits
+defaultLMDBLimits =
+  V1.LMDBLimits
+    { V1.lmdbMapSize = 16 * 1024 * 1024 * 1024
+    , V1.lmdbMaxDatabases = 10
+    , V1.lmdbMaxReaders = 16
+    }
diff --git a/ouroboros-consensus-cardano/cddl/base.cddl b/ouroboros-consensus-cardano/cddl/base.cddl
index 78e539d37..cf808f45d 100644
--- a/ouroboros-consensus-cardano/cddl/base.cddl
+++ b/ouroboros-consensus-cardano/cddl/base.cddl
@@ -31,7 +31,6 @@ slotno = word64
 stake = rational
 
 withOrigin<v> = [] / [v]
-withOriginTH<v> = [0] / [1, v]
 
 ;; Collections
 either<x, y> = [0, x] / [1, y]
diff --git a/ouroboros-consensus-cardano/cddl/disk/ledger/tpraos.cddl b/ouroboros-consensus-cardano/cddl/disk/ledger/tpraos.cddl
index db34ccb67..e9cec4a3e 100644
--- a/ouroboros-consensus-cardano/cddl/disk/ledger/tpraos.cddl
+++ b/ouroboros-consensus-cardano/cddl/disk/ledger/tpraos.cddl
@@ -1,5 +1,5 @@
 versionedTPraosState =
-  [serializationFormat1, [withOriginTH<slotno>, tpraosState]]
+  [serializationFormat1, [withOrigin<slotno>, tpraosState]]
 
 tpraosState = [prtclState, ticknState, nonce]
 
@@ -9,4 +9,4 @@ ticknState = [nonce, nonce]
 
 serializationFormat1 = 1
 
-;# import withOriginTH, slotno, keyhash, word64, nonce from base
+;# import withOrigin, slotno, keyhash, word64, nonce from base
diff --git a/ouroboros-consensus-cardano/changelog.d/20250528_163220_javier.sagredo_blockprotocol.md b/ouroboros-consensus-cardano/changelog.d/20250528_163220_javier.sagredo_blockprotocol.md
deleted file mode 100644
index 98dfd0e16..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250528_163220_javier.sagredo_blockprotocol.md
+++ /dev/null
@@ -1,23 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-
-### Non-Breaking
-
-- Move `BlockProtocol (ShelleyBlock proto era)` instance to `Ouroboros.Consensus.Shelley.Ledger.Block`
-
-<!--
-### Breaking
-
-- A bullet item for the Breaking category.
-
--->
diff --git a/ouroboros-consensus-cardano/changelog.d/20250602_165324_jasataco_newer_ledger.md b/ouroboros-consensus-cardano/changelog.d/20250602_165324_jasataco_newer_ledger.md
deleted file mode 100644
index 7b2fff474..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250602_165324_jasataco_newer_ledger.md
+++ /dev/null
@@ -1,20 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
-For top level release notes, leave all the headers commented out.
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-### Non-Breaking
-
-- Vendor Ledger's serialization of `PParams` and `ShelleyGenesis` prior to `ShelleyNodeToClientVersion12`.
-
-### Breaking
-
-- Define new Node-To-Client versions `CardanoNodeToClientVersion17`, `ShelleyNodeToClientVersion13`.
diff --git a/ouroboros-consensus-cardano/changelog.d/20250603_143238_javier.sagredo_delete_deprecate_query.md b/ouroboros-consensus-cardano/changelog.d/20250603_143238_javier.sagredo_delete_deprecate_query.md
deleted file mode 100644
index 6da8dd297..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250603_143238_javier.sagredo_delete_deprecate_query.md
+++ /dev/null
@@ -1,23 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Deprecate `GetPoolDistr` in favor of `GetPoolDistr2` (new in `NodeToClientV_21`).
-- Deprecate `GetStakeDistribution` in favor of `GetStakeDistribution2` (new in `NodeToClientV_21`).
diff --git a/ouroboros-consensus-cardano/changelog.d/20250616_122911_javier.sagredo_query_max_major_prot_ver.md b/ouroboros-consensus-cardano/changelog.d/20250616_122911_javier.sagredo_query_max_major_prot_ver.md
deleted file mode 100644
index 9f13b1c0d..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250616_122911_javier.sagredo_query_max_major_prot_ver.md
+++ /dev/null
@@ -1,23 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Expose new query `GetMaxMajorProtocolVersion` as a Shelley query, for getting
-  the max known protocol version for a node.
diff --git a/ouroboros-consensus-cardano/changelog.d/20250707_101854_georgy.lukyanov_issue1544_dijkstra_era.md b/ouroboros-consensus-cardano/changelog.d/20250707_101854_georgy.lukyanov_issue1544_dijkstra_era.md
deleted file mode 100644
index 3133a7f75..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250707_101854_georgy.lukyanov_issue1544_dijkstra_era.md
+++ /dev/null
@@ -1,18 +0,0 @@
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Add Dijkstra era
-- Add dependency on the new Dijkstra Ledger package:
-  - `cardano-ledger-dijkstra`: `^>=0.1`
diff --git a/ouroboros-consensus-cardano/changelog.d/20250716_190309_alexander.esgen_tiebreaker_view.md b/ouroboros-consensus-cardano/changelog.d/20250716_190309_alexander.esgen_tiebreaker_view.md
deleted file mode 100644
index 34a455eb0..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250716_190309_alexander.esgen_tiebreaker_view.md
+++ /dev/null
@@ -1,5 +0,0 @@
-### Patch
-
-- Adapted to changes related to `SelectView`.
-
-  Concretely, this changes the structure of `SelectView (BlockProtocol (CardanoBlock c))`, but it still contains the same data as before.
diff --git a/ouroboros-consensus-cardano/changelog.d/20250723_133823_javier.sagredo_ledger_10_6.md b/ouroboros-consensus-cardano/changelog.d/20250723_133823_javier.sagredo_ledger_10_6.md
deleted file mode 100644
index 283de3303..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250723_133823_javier.sagredo_ledger_10_6.md
+++ /dev/null
@@ -1,20 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
--->
-### Breaking
-
-- Delete the now unnecessary `Ouroboros.Consensus.Shelley.Eras.WrapTx` newtype wrapper.
-
diff --git a/ouroboros-consensus-cardano/changelog.d/20250728_115320_coot_cardano_diffusion_integration.md b/ouroboros-consensus-cardano/changelog.d/20250728_115320_coot_cardano_diffusion_integration.md
deleted file mode 100644
index 0459a161f..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250728_115320_coot_cardano_diffusion_integration.md
+++ /dev/null
@@ -1,4 +0,0 @@
-### Non-Breaking
-
-- Added `ShelleyNodeToClientVersion14` which adds SRV support in `GetBigLedgerPeerSnapshot` query.
-- Added `CardanoNodeToClientVersion18` which maps to `ShelleyNodeToClientVersion14`.
diff --git a/ouroboros-consensus-cardano/changelog.d/20250826_131450_javier.sagredo_remove_shelley_byron.md b/ouroboros-consensus-cardano/changelog.d/20250729_124022_javier.sagredo_lsm1.md
similarity index 100%
rename from ouroboros-consensus-cardano/changelog.d/20250826_131450_javier.sagredo_remove_shelley_byron.md
rename to ouroboros-consensus-cardano/changelog.d/20250729_124022_javier.sagredo_lsm1.md
diff --git a/ouroboros-consensus-cardano/changelog.d/20250806_150924_georgy.lukyanov_update_ledger.md b/ouroboros-consensus-cardano/changelog.d/20250806_150924_georgy.lukyanov_update_ledger.md
deleted file mode 100644
index d302d8160..000000000
--- a/ouroboros-consensus-cardano/changelog.d/20250806_150924_georgy.lukyanov_update_ledger.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Patch
-
-- Bump `cardano-protocol-tpraos` to 1.4.1
diff --git a/ouroboros-consensus/changelog.d/20250822_163712_jasataco_lmdb.md b/ouroboros-consensus-cardano/changelog.d/20250919_095938_thomas.bagrel_object_diffusion.md
similarity index 81%
rename from ouroboros-consensus/changelog.d/20250822_163712_jasataco_lmdb.md
rename to ouroboros-consensus-cardano/changelog.d/20250919_095938_thomas.bagrel_object_diffusion.md
index ee880667c..9efe00d43 100644
--- a/ouroboros-consensus/changelog.d/20250822_163712_jasataco_lmdb.md
+++ b/ouroboros-consensus-cardano/changelog.d/20250919_095938_thomas.bagrel_object_diffusion.md
@@ -20,4 +20,4 @@ For top level release notes, leave all the headers commented out.
 
 ### Breaking
 
-- `forkerRangeRead` now returns also the maximal key found in the backend.
+- Added support for `NodeToNodeV_16`
diff --git a/ouroboros-consensus-cardano/changelog.d/20250919_101630_thomas.bagrel_hfc_era_peras.md b/ouroboros-consensus-cardano/changelog.d/20250919_101630_thomas.bagrel_hfc_era_peras.md
new file mode 100644
index 000000000..043efd495
--- /dev/null
+++ b/ouroboros-consensus-cardano/changelog.d/20250919_101630_thomas.bagrel_hfc_era_peras.md
@@ -0,0 +1,29 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Add `eraPerasRoundLength` parameters to `{Byron,Shelley}EraParams` structs.
+
+
+### Non-Breaking
+
+- The `EraSummary`, while not modified directly, is now Peras-aware via `EraParams`
+  - in a valid summary, Peras round length must divide the epoch size.
diff --git a/ouroboros-consensus-cardano/changelog.d/20251002_112515_javier.sagredo_lsm1.md b/ouroboros-consensus-cardano/changelog.d/20251002_112515_javier.sagredo_lsm1.md
new file mode 100644
index 000000000..3d15ee73f
--- /dev/null
+++ b/ouroboros-consensus-cardano/changelog.d/20251002_112515_javier.sagredo_lsm1.md
@@ -0,0 +1,29 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+### Patch
+
+- Bump ledger dependencies:
+  - `cardano-ledger-allegra` 1.8 → 1.9
+  - `cardano-ledger-alonzo` 1.14 → 1.15
+  - `cardano-ledger-api` 1.12 → 1.13
+  - `cardano-ledger-conway` 1.20 → 1.21
+  - `cardano-ledger-core` 1.18 → 1.19
+  - `cardano-ledger-dijkstra` 0.1 → 0.2
+
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+<!--
+### Breaking
+
+- A bullet item for the Breaking category.
+
+-->
diff --git a/ouroboros-consensus-cardano/changelog.d/20251010_111741_javier.sagredo_version_tables.md b/ouroboros-consensus-cardano/changelog.d/20251010_111741_javier.sagredo_version_tables.md
new file mode 100644
index 000000000..3707a1939
--- /dev/null
+++ b/ouroboros-consensus-cardano/changelog.d/20251010_111741_javier.sagredo_version_tables.md
@@ -0,0 +1,26 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Flip serialization of `TxIx` in Mempack, to ensure lexicographic order on the
+  serialized form matches the Haskell Ord, allowing for incremental streaming of
+  values among backends. Note this happens at the same time as the versioning of
+  the LedgerTables codec which will induce a replay of the chain.
diff --git a/ouroboros-consensus-cardano/changelog.d/20251010_121135_javier.sagredo_extract_2.md b/ouroboros-consensus-cardano/changelog.d/20251010_121135_javier.sagredo_extract_2.md
new file mode 100644
index 000000000..1a6055e7f
--- /dev/null
+++ b/ouroboros-consensus-cardano/changelog.d/20251010_121135_javier.sagredo_extract_2.md
@@ -0,0 +1,3 @@
+<!--
+EMPTY as all changes belong to db-analyser and snapshot-converter
+-->
diff --git a/ouroboros-consensus-cardano/changelog.d/byron-bugfix.md b/ouroboros-consensus-cardano/changelog.d/byron-bugfix.md
deleted file mode 100644
index cfaf56aa5..000000000
--- a/ouroboros-consensus-cardano/changelog.d/byron-bugfix.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Patch
-
-- Fix LedgerTables deserialization for Byron snapshots.
diff --git a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Header_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Header_Dijkstra
index 6c7e2226f..6991fda39 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Header_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/CardanoNodeToNodeVersion2/Header_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion12/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion13/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion14/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion2/CardanoNodeToClientVersion15/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion16/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion17/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Block_Dijkstra
index 53b7df5b7..17a5ca643 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTxId_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTxId_Dijkstra
index db785f94a..58cd6ad89 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTxId_Dijkstra
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTxId_Dijkstra
@@ -1 +1 @@
-X K8aLs,а^"5J
\ No newline at end of file
+X #NDB~Dpa1Ux1
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTx_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTx_Dijkstra
index deec95d4f..aa3285276 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTx_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/GenTx_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/LedgerConfig b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/LedgerConfig
index c6e93ae4c..095e470a3 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/LedgerConfig and b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/LedgerConfig differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Result_Dijkstra_LedgerTip b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Result_Dijkstra_LedgerTip
index 2eeba1fbb..8473d9e26 100644
--- a/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Result_Dijkstra_LedgerTip
+++ b/ouroboros-consensus-cardano/golden/cardano/QueryVersion3/CardanoNodeToClientVersion18/Result_Dijkstra_LedgerTip
@@ -1 +1 @@
-	X M7!SYǭdGfp;
\ No newline at end of file
+	X @-X؆8<إʔ/N6is!!6E!6
\ No newline at end of file
diff --git a/ouroboros-consensus-cardano/golden/cardano/disk/Block_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/disk/Block_Dijkstra
index f64860070..bdf909949 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/disk/Block_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/disk/Block_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Alonzo b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Alonzo
index 711ac926d..e0d2a9ff8 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Alonzo and b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Alonzo differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Babbage b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Babbage
index 40ac2a6b0..16698aa6f 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Babbage and b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Babbage differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Conway b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Conway
index 40ac2a6b0..16698aa6f 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Conway and b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Conway differ
diff --git a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Dijkstra b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Dijkstra
index 40ac2a6b0..16698aa6f 100644
Binary files a/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Dijkstra and b/ouroboros-consensus-cardano/golden/cardano/disk/LedgerTables_Dijkstra differ
diff --git a/ouroboros-consensus-cardano/ouroboros-consensus-cardano.cabal b/ouroboros-consensus-cardano/ouroboros-consensus-cardano.cabal
index 47472f1d8..399435917 100644
--- a/ouroboros-consensus-cardano/ouroboros-consensus-cardano.cabal
+++ b/ouroboros-consensus-cardano/ouroboros-consensus-cardano.cabal
@@ -1,6 +1,6 @@
 cabal-version: 3.0
 name: ouroboros-consensus-cardano
-version: 0.25.1.0
+version: 0.26.0.0
 synopsis:
   The instantation of the Ouroboros consensus layer used by Cardano
 
@@ -139,15 +139,15 @@ library
     cardano-crypto,
     cardano-crypto-class ^>=2.2,
     cardano-crypto-wrapper,
-    cardano-ledger-allegra ^>=1.8,
-    cardano-ledger-alonzo ^>=1.14,
-    cardano-ledger-api ^>=1.12,
+    cardano-ledger-allegra ^>=1.9,
+    cardano-ledger-alonzo ^>=1.15,
+    cardano-ledger-api ^>=1.13,
     cardano-ledger-babbage ^>=1.12,
     cardano-ledger-binary ^>=1.7,
     cardano-ledger-byron ^>=1.2,
-    cardano-ledger-conway ^>=1.20,
-    cardano-ledger-core ^>=1.18,
-    cardano-ledger-dijkstra ^>=0.1,
+    cardano-ledger-conway ^>=1.21,
+    cardano-ledger-core ^>=1.19,
+    cardano-ledger-dijkstra ^>=0.2,
     cardano-ledger-mary ^>=1.9,
     cardano-ledger-shelley ^>=1.17,
     cardano-prelude,
@@ -156,6 +156,7 @@ library
     cardano-strict-containers,
     cborg ^>=0.2.2,
     containers >=0.5 && <0.8,
+    contra-tracer,
     crypton,
     deepseq,
     formatting >=6.3 && <7.3,
@@ -164,8 +165,8 @@ library
     microlens,
     mtl,
     nothunks,
-    ouroboros-consensus ^>=0.27,
-    ouroboros-consensus-protocol ^>=0.12,
+    ouroboros-consensus ^>=0.28,
+    ouroboros-consensus-protocol ^>=0.13,
     ouroboros-network-api ^>=0.16,
     serialise ^>=0.2,
     singletons ^>=3.0,
@@ -207,7 +208,7 @@ library unstable-byronspec
     containers >=0.5 && <0.8,
     mtl,
     nothunks,
-    ouroboros-consensus ^>=0.27,
+    ouroboros-consensus ^>=0.28,
     serialise ^>=0.2,
     small-steps,
     transformers,
@@ -312,7 +313,6 @@ library unstable-shelley-testlib
     cardano-crypto-class,
     cardano-data,
     cardano-ledger-allegra:cardano-ledger-allegra,
-    cardano-ledger-alonzo:cardano-ledger-alonzo,
     cardano-ledger-alonzo-test,
     cardano-ledger-babbage:testlib,
     cardano-ledger-conway:testlib,
@@ -326,6 +326,9 @@ library unstable-shelley-testlib
     cardano-slotting,
     cardano-strict-containers,
     containers,
+    contra-tracer,
+    kes-agent <1,
+    kes-agent-crypto <1,
     microlens,
     mtl,
     ouroboros-consensus:{ouroboros-consensus, unstable-consensus-testlib},
@@ -365,8 +368,10 @@ test-suite shelley-test
     cborg,
     constraints,
     containers,
+    contra-tracer,
     filepath,
     measures,
+    mempack,
     microlens,
     ouroboros-consensus:{ouroboros-consensus, unstable-consensus-testlib},
     ouroboros-consensus-cardano,
@@ -416,6 +421,7 @@ library unstable-cardano-testlib
     cardano-strict-containers,
     cborg,
     containers,
+    contra-tracer,
     mempack,
     microlens,
     mtl,
@@ -560,6 +566,7 @@ library unstable-cardano-tools
     cardano-ledger-byron,
     cardano-ledger-conway,
     cardano-ledger-core,
+    cardano-ledger-dijkstra,
     cardano-ledger-mary,
     cardano-ledger-shelley,
     cardano-prelude,
@@ -580,14 +587,15 @@ library unstable-cardano-tools
     network,
     network-mux,
     nothunks,
-    ouroboros-consensus ^>=0.27,
+    ouroboros-consensus:{ouroboros-consensus, ouroboros-consensus-lmdb, ouroboros-consensus-lsm} ^>=0.28,
     ouroboros-consensus-cardano,
-    ouroboros-consensus-diffusion ^>=0.23,
-    ouroboros-consensus-protocol:{ouroboros-consensus-protocol, unstable-protocol-testlib} ^>=0.12,
+    ouroboros-consensus-diffusion ^>=0.24,
+    ouroboros-consensus-protocol:{ouroboros-consensus-protocol, unstable-protocol-testlib} ^>=0.13,
     ouroboros-network,
     ouroboros-network-api,
     ouroboros-network-framework ^>=0.19,
     ouroboros-network-protocols,
+    random,
     resource-registry,
     singletons,
     sop-core,
@@ -687,23 +695,35 @@ executable immdb-server
 executable snapshot-converter
   import: common-exe
   hs-source-dirs: app
+  other-modules:
+    Ouroboros.Consensus.Cardano.StreamingLedgerTables
+
   main-is: snapshot-converter.hs
   build-depends:
+    ansi-terminal,
     base,
-    bytestring,
     cardano-crypto-class,
-    contra-tracer,
+    cardano-ledger-binary,
+    cardano-ledger-core,
+    cardano-ledger-shelley,
+    cborg,
+    directory,
     filepath,
     fs-api,
+    microlens,
     mtl,
     optparse-applicative,
-    ouroboros-consensus,
+    ouroboros-consensus:{ouroboros-consensus, ouroboros-consensus-lmdb, ouroboros-consensus-lsm},
     ouroboros-consensus-cardano,
     ouroboros-consensus-cardano:unstable-cardano-tools,
+    random,
     resource-registry,
     serialise,
     sop-core,
-    temporary,
+    sop-extras,
+    strict-sop-core,
+    terminal-progress-bar,
+    text,
     with-utf8,
 
   other-modules:
diff --git a/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Ledger/Ledger.hs b/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Ledger/Ledger.hs
index f57756fe0..c1b7ebbf3 100644
--- a/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Ledger/Ledger.hs
+++ b/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Ledger/Ledger.hs
@@ -333,6 +333,7 @@ byronEraParams genesis =
     , eraSlotLength = fromByronSlotLength $ genesisSlotLength genesis
     , eraSafeZone = HardFork.StandardSafeZone (2 * k)
     , eraGenesisWin = GenesisWindow (2 * k)
+    , eraPerasRoundLength = HardFork.NoPerasEnabled
     }
  where
   k = unNonZero $ maxRollbacks $ genesisSecurityParam genesis
@@ -345,6 +346,7 @@ byronEraParamsNeverHardForks genesis =
     , eraSlotLength = fromByronSlotLength $ genesisSlotLength genesis
     , eraSafeZone = HardFork.UnsafeIndefiniteSafeZone
     , eraGenesisWin = GenesisWindow (2 * Gen.unBlockCount (Gen.configK genesis))
+    , eraPerasRoundLength = HardFork.NoPerasEnabled
     }
 
 instance HasHardForkHistory ByronBlock where
diff --git a/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Node.hs b/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Node.hs
index f1080e236..58b7587dc 100644
--- a/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Node.hs
+++ b/ouroboros-consensus-cardano/src/byron/Ouroboros/Consensus/Byron/Node.hs
@@ -143,6 +143,7 @@ byronBlockForging creds =
           slot
           tickedPBftState
     , forgeBlock = \cfg -> return ....: forgeByronBlock cfg
+    , finalize = pure ()
     }
  where
   canBeLeader = mkPBftCanBeLeader creds
diff --git a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/CanHardFork.hs b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/CanHardFork.hs
index 2be95e56c..ca4d5c03a 100644
--- a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/CanHardFork.hs
+++ b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/CanHardFork.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE EmptyCase #-}
@@ -12,7 +13,10 @@
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
-{-# OPTIONS_GHC -Wno-orphans #-}
+{-# OPTIONS_GHC -Wno-orphans -Wno-x-ord-preserving-coercions #-}
+#if __GLASGOW_HASKELL__ < 908
+{-# OPTIONS_GHC -Wno-unrecognised-warning-flags #-}
+#endif
 
 module Ouroboros.Consensus.Cardano.CanHardFork
   ( CardanoHardForkConstraints
@@ -92,7 +96,7 @@ import Ouroboros.Consensus.Shelley.Node ()
 import Ouroboros.Consensus.Shelley.Protocol.Praos ()
 import Ouroboros.Consensus.Shelley.ShelleyHFC
 import Ouroboros.Consensus.TypeFamilyWrappers
-import Ouroboros.Consensus.Util (eitherToMaybe)
+import Ouroboros.Consensus.Util (coerceMapKeys, eitherToMaybe)
 
 {-------------------------------------------------------------------------------
   CanHardFork
@@ -466,6 +470,7 @@ translateLedgerStateShelleyToAllegraWrapper =
                 LedgerTables
                   . DiffMK
                   . Diff.fromMapDeletes
+                  . coerceMapKeys
                   . Map.map SL.upgradeTxOut
                   $ avvms
 
@@ -478,6 +483,7 @@ translateLedgerStateShelleyToAllegraWrapper =
                   . withLedgerTables ls
                   . LedgerTables
                   . ValuesMK
+                  . coerceMapKeys
                   $ avvms
 
               resultingState =
diff --git a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Ledger.hs b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Ledger.hs
index 536743def..7dffcff9f 100644
--- a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Ledger.hs
+++ b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Ledger.hs
@@ -28,7 +28,6 @@ import Cardano.Ledger.Binary.Decoding hiding (Decoder)
 import Cardano.Ledger.Binary.Encoding hiding (Encoding)
 import qualified Cardano.Ledger.Conway.State as SL
 import Cardano.Ledger.Core (Era, eraDecoder, eraProtVerLow)
-import qualified Cardano.Ledger.Shelley.API as SL
 import Cardano.Ledger.Shelley.LedgerState as SL
   ( esLStateL
   , lsCertStateL
@@ -57,7 +56,8 @@ import Ouroboros.Consensus.Ledger.Tables
 import Ouroboros.Consensus.Protocol.Praos (Praos)
 import Ouroboros.Consensus.Protocol.TPraos (TPraos)
 import Ouroboros.Consensus.Shelley.Ledger
-  ( IsShelleyBlock
+  ( BigEndianTxIn
+  , IsShelleyBlock
   , ShelleyBlock
   , ShelleyCompatible
   , shelleyLedgerState
@@ -70,7 +70,7 @@ instance
   HasCanonicalTxIn (CardanoEras c)
   where
   newtype CanonicalTxIn (CardanoEras c) = CardanoTxIn
-    { getCardanoTxIn :: SL.TxIn
+    { getCardanoTxIn :: BigEndianTxIn
     }
     deriving stock (Show, Eq, Ord)
     deriving newtype NoThunks
diff --git a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Node.hs b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Node.hs
index 0edeb83eb..98093f86c 100644
--- a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Node.hs
+++ b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/Node.hs
@@ -55,14 +55,12 @@ import qualified Cardano.Ledger.Api.Transition as L
 import qualified Cardano.Ledger.BaseTypes as SL
 import qualified Cardano.Ledger.Shelley.API as SL
 import Cardano.Prelude (cborError)
-import qualified Cardano.Protocol.TPraos.OCert as Absolute
-  ( KESPeriod (..)
-  , ocertKESPeriod
-  )
+import qualified Cardano.Protocol.TPraos.OCert as Absolute (KESPeriod (..))
 import qualified Codec.CBOR.Decoding as CBOR
 import Codec.CBOR.Encoding (Encoding)
 import qualified Codec.CBOR.Encoding as CBOR
 import Control.Exception (assert)
+import qualified Control.Tracer as Tracer
 import qualified Data.ByteString.Short as Short
 import Data.Functor.These (These1 (..))
 import qualified Data.Map.Strict as Map
@@ -97,10 +95,11 @@ import Ouroboros.Consensus.Ledger.Tables.Utils (forgetLedgerTables)
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
 import Ouroboros.Consensus.Node.ProtocolInfo
 import Ouroboros.Consensus.Node.Run
-import qualified Ouroboros.Consensus.Protocol.Ledger.HotKey as HotKey
 import Ouroboros.Consensus.Protocol.Praos (Praos, PraosParams (..))
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
 import Ouroboros.Consensus.Protocol.Praos.Common
-  ( praosCanBeLeaderOpCert
+  ( PraosCanBeLeader (..)
+  , instantiatePraosCredentials
   )
 import Ouroboros.Consensus.Protocol.TPraos (TPraos, TPraosParams (..))
 import qualified Ouroboros.Consensus.Protocol.TPraos as Shelley
@@ -122,7 +121,6 @@ import qualified Ouroboros.Consensus.Shelley.Node.TPraos as TPraos
 import Ouroboros.Consensus.Storage.Serialisation
 import Ouroboros.Consensus.TypeFamilyWrappers
 import Ouroboros.Consensus.Util.Assert
-import Ouroboros.Consensus.Util.IOLike
 
 {-------------------------------------------------------------------------------
   SerialiseHFC
@@ -432,6 +430,7 @@ instance
     Map.fromList $
       [ (NodeToNodeV_14, CardanoNodeToNodeVersion2)
       , (NodeToNodeV_15, CardanoNodeToNodeVersion2)
+      , (NodeToNodeV_16, CardanoNodeToNodeVersion2)
       ]
 
   supportedNodeToClientVersions _ =
@@ -569,10 +568,12 @@ data CardanoProtocolParams c = CardanoProtocolParams
 -- for mainnet (check against @'SL.gNetworkId' == 'SL.Mainnet'@).
 protocolInfoCardano ::
   forall c m.
-  (IOLike m, CardanoHardForkConstraints c) =>
+  ( CardanoHardForkConstraints c
+  , KESAgentContext c m
+  ) =>
   CardanoProtocolParams c ->
   ( ProtocolInfo (CardanoBlock c)
-  , m [BlockForging m (CardanoBlock c)]
+  , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (CardanoBlock c)]
   )
 protocolInfoCardano paramsCardano
   | SL.Mainnet <- SL.sgNetworkId genesisShelley
@@ -585,7 +586,7 @@ protocolInfoCardano paramsCardano
             { pInfoConfig = cfg
             , pInfoInitLedger = initExtLedgerStateCardano
             }
-        , blockForging
+        , pure . mkBlockForgings
         )
  where
   CardanoProtocolParams
@@ -980,15 +981,15 @@ protocolInfoCardano paramsCardano
   -- credentials. If there are multiple Shelley credentials, we merge the
   -- Byron credentials with the first Shelley one but still have separate
   -- threads for the remaining Shelley ones.
-  blockForging :: m [BlockForging m (CardanoBlock c)]
-  blockForging = do
-    shelleyBased <- traverse blockForgingShelleyBased credssShelleyBased
-    let blockForgings :: [NonEmptyOptNP (BlockForging m) (CardanoEras c)]
+  mkBlockForgings :: Tracer.Tracer m KESAgentClientTrace -> [MkBlockForging m (CardanoBlock c)]
+  mkBlockForgings tr = do
+    let shelleyBased = blockForgingShelleyBased tr <$> credssShelleyBased
+        blockForgings :: [m (NonEmptyOptNP (BlockForging m) (CardanoEras c))]
         blockForgings = case (mBlockForgingByron, shelleyBased) of
           (Nothing, shelleys) -> shelleys
           (Just byron, []) -> [byron]
           (Just byron, shelley : shelleys) ->
-            OptNP.zipWith merge byron shelley : shelleys
+            (OptNP.zipWith merge <$> byron <*> shelley) : shelleys
            where
             -- When merging Byron with Shelley-based eras, we should never
             -- merge two from the same era.
@@ -996,30 +997,25 @@ protocolInfoCardano paramsCardano
             merge (This1 x) = x
             merge (That1 y) = y
 
-    return $ hardForkBlockForging "Cardano" <$> blockForgings
+    let mkHardForkBlockForgings ::
+          m (NonEmptyOptNP (BlockForging m) (CardanoEras c)) -> MkBlockForging m (CardanoBlock c)
+        mkHardForkBlockForgings mbfs = MkBlockForging $ do
+          bfs <- mbfs
+          mkBlockForging $ hardForkBlockForging (const "Cardano") (hmap (MkBlockForging . pure) bfs)
+
+    fmap mkHardForkBlockForgings blockForgings
 
-  mBlockForgingByron :: Maybe (NonEmptyOptNP (BlockForging m) (CardanoEras c))
+  mBlockForgingByron :: Maybe (m (NonEmptyOptNP (BlockForging m) (CardanoEras c)))
   mBlockForgingByron = do
     creds <- mCredsByron
-    return $ byronBlockForging creds `OptNP.at` IZ
+    return $ pure $ byronBlockForging creds `OptNP.at` IZ
 
   blockForgingShelleyBased ::
+    Tracer.Tracer m KESAgentClientTrace ->
     ShelleyLeaderCredentials c ->
     m (NonEmptyOptNP (BlockForging m) (CardanoEras c))
-  blockForgingShelleyBased credentials = do
-    let ShelleyLeaderCredentials
-          { shelleyLeaderCredentialsInitSignKey = initSignKey
-          , shelleyLeaderCredentialsCanBeLeader = canBeLeader
-          } = credentials
-
-    hotKey <- do
-      let maxKESEvo :: Word64
-          maxKESEvo = assert (tpraosMaxKESEvo == praosMaxKESEvo) praosMaxKESEvo
-
-          startPeriod :: Absolute.KESPeriod
-          startPeriod = Absolute.ocertKESPeriod $ praosCanBeLeaderOpCert canBeLeader
-
-      HotKey.mkHotKey @m @c initSignKey startPeriod maxKESEvo
+  blockForgingShelleyBased tr credentials = do
+    let canBeLeader = shelleyLeaderCredentialsCanBeLeader credentials
 
     let slotToPeriod :: SlotNo -> Absolute.KESPeriod
         slotToPeriod (SlotNo slot) =
@@ -1028,6 +1024,15 @@ protocolInfoCardano paramsCardano
               fromIntegral $
                 slot `div` praosSlotsPerKESPeriod
 
+        maxKESEvo :: Word64
+        maxKESEvo = assert (tpraosMaxKESEvo == praosMaxKESEvo) praosMaxKESEvo
+
+    hotKey <-
+      instantiatePraosCredentials
+        maxKESEvo
+        tr
+        (praosCanBeLeaderCredentialsSource canBeLeader)
+
     let tpraos ::
           forall era.
           ShelleyEraWithCrypto c (TPraos c) era =>
diff --git a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/QueryHF.hs b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/QueryHF.hs
index bfed11149..cc1a24847 100644
--- a/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/QueryHF.hs
+++ b/ouroboros-consensus-cardano/src/ouroboros-consensus-cardano/Ouroboros/Consensus/Cardano/QueryHF.hs
@@ -19,6 +19,7 @@
 
 module Ouroboros.Consensus.Cardano.QueryHF () where
 
+import Data.Coerce
 import Data.Functor.Product
 import Data.SOP.BasicFunctors
 import Data.SOP.Constraint
@@ -98,14 +99,14 @@ instance CardanoHardForkConstraints c => BlockSupportsHFLedgerQuery (CardanoEras
           answerShelleyLookupQueries
             (injectLedgerTables idx)
             (ejectHardForkTxOut idx)
-            (ejectCanonicalTxIn idx)
+            (coerce . ejectCanonicalTxIn idx)
       )
   answerBlockQueryHFTraverse =
     answerCardanoQueryHF
       ( \idx ->
           answerShelleyTraversingQueries
             (ejectHardForkTxOut idx)
-            (ejectCanonicalTxIn idx)
+            (coerce . ejectCanonicalTxIn idx)
             (queryLedgerGetTraversingFilter idx)
       )
 
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/HFEras.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/HFEras.hs
index 1118b3b86..23a78ea1a 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/HFEras.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/HFEras.hs
@@ -18,9 +18,10 @@ module Ouroboros.Consensus.Shelley.HFEras
   , StandardShelleyBlock
   ) where
 
+import Cardano.Protocol.Crypto
 import Ouroboros.Consensus.Protocol.Praos (Praos)
 import qualified Ouroboros.Consensus.Protocol.Praos as Praos
-import Ouroboros.Consensus.Protocol.TPraos (StandardCrypto, TPraos)
+import Ouroboros.Consensus.Protocol.TPraos (TPraos)
 import qualified Ouroboros.Consensus.Protocol.TPraos as TPraos
 import Ouroboros.Consensus.Shelley.Eras
   ( AllegraEra
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Block.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Block.hs
index 4ec5100e7..751d63ddd 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Block.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Block.hs
@@ -165,7 +165,7 @@ mkShelleyBlock ::
 mkShelleyBlock raw =
   ShelleyBlock
     { shelleyBlockRaw = raw
-    , shelleyBlockHeaderHash = pHeaderHash $ SL.bheader raw
+    , shelleyBlockHeaderHash = pHeaderHash $ SL.blockHeader raw
     }
 
 class
@@ -200,7 +200,7 @@ instance
 instance ShelleyCompatible proto era => GetHeader (ShelleyBlock proto era) where
   getHeader (ShelleyBlock rawBlk hdrHash) =
     ShelleyHeader
-      { shelleyHeaderRaw = SL.bheader rawBlk
+      { shelleyHeaderRaw = SL.blockHeader rawBlk
       , shelleyHeaderHash = hdrHash
       }
 
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Ledger.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Ledger.hs
index c096ab5d8..d3a86f21a 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Ledger.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Ledger.hs
@@ -19,7 +19,10 @@
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
-{-# OPTIONS_GHC -Wno-orphans #-}
+{-# OPTIONS_GHC -Wno-orphans -Wno-x-ord-preserving-coercions #-}
+#if __GLASGOW_HASKELL__ < 908
+{-# OPTIONS_GHC -Wno-unrecognised-warning-flags #-}
+#endif
 
 module Ouroboros.Consensus.Shelley.Ledger.Ledger
   ( LedgerState (..)
@@ -54,10 +57,11 @@ module Ouroboros.Consensus.Shelley.Ledger.Ledger
 
     -- * Low-level UTxO manipulations
   , slUtxoL
+  , BigEndianTxIn (..)
   ) where
 
 import qualified Cardano.Ledger.BHeaderView as SL (BHeaderView)
-import qualified Cardano.Ledger.BaseTypes as SL (epochInfoPure)
+import qualified Cardano.Ledger.BaseTypes as SL (TxIx (..), epochInfoPure)
 import Cardano.Ledger.BaseTypes.NonZero (unNonZero)
 import Cardano.Ledger.Binary.Decoding
   ( decShareCBOR
@@ -97,7 +101,7 @@ import Control.Arrow (left, second)
 import qualified Control.Exception as Exception
 import Control.Monad.Except
 import qualified Control.State.Transition.Extended as STS
-import Data.Coerce (coerce)
+import Data.Coerce
 import Data.Functor.Identity
 import Data.MemPack
 import qualified Data.Text as T
@@ -113,6 +117,7 @@ import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.HardFork.Abstract
 import Ouroboros.Consensus.HardFork.Combinator.PartialConfig
 import qualified Ouroboros.Consensus.HardFork.History as HardFork
+import Ouroboros.Consensus.HardFork.History.EraParams (EraParams (..))
 import Ouroboros.Consensus.HardFork.History.Util
 import Ouroboros.Consensus.HardFork.Simple
 import Ouroboros.Consensus.HeaderValidation
@@ -130,6 +135,7 @@ import Ouroboros.Consensus.Shelley.Protocol.Abstract
   , mkHeaderView
   )
 import Ouroboros.Consensus.Storage.LedgerDB
+import Ouroboros.Consensus.Util
 import Ouroboros.Consensus.Util.CBOR
   ( decodeWithOrigin
   , encodeWithOrigin
@@ -168,6 +174,9 @@ shelleyEraParams genesis =
     , eraSlotLength = mkSlotLength $ SL.fromNominalDiffTimeMicro $ SL.sgSlotLength genesis
     , eraSafeZone = HardFork.StandardSafeZone stabilityWindow
     , eraGenesisWin = GenesisWindow stabilityWindow
+    , -- TODO(geo2a): enabled Peras conditionally in the Dijkstra era
+      -- see https://github.com/tweag/cardano-peras/issues/112
+      eraPerasRoundLength = HardFork.NoPerasEnabled
     }
  where
   stabilityWindow =
@@ -183,6 +192,7 @@ shelleyEraParamsNeverHardForks genesis =
     , eraSlotLength = mkSlotLength $ SL.fromNominalDiffTimeMicro $ SL.sgSlotLength genesis
     , eraSafeZone = HardFork.UnsafeIndefiniteSafeZone
     , eraGenesisWin = GenesisWindow stabilityWindow
+    , eraPerasRoundLength = HardFork.NoPerasEnabled
     }
  where
   stabilityWindow =
@@ -317,7 +327,34 @@ shelleyLedgerTipPoint = shelleyTipToPoint . shelleyLedgerTip
 
 instance ShelleyCompatible proto era => UpdateLedger (ShelleyBlock proto era)
 
-type instance TxIn (LedgerState (ShelleyBlock proto era)) = SL.TxIn
+-- | The only purpose of this type is to modify the MemPack instance to use big
+-- endian serialization. This is necessary to ensure streaming functions of the
+-- UTxO set preserve the order of the entries, as otherwise we would get
+-- different sortings if sorting via the Serialized form and the Haskell Ord
+-- instance.
+--
+-- TODO: fix this in the Ledger. See cardano-ledger#5336.
+newtype BigEndianTxIn = BigEndianTxIn {getOriginalTxIn :: SL.TxIn}
+  deriving newtype (Eq, Show, Ord, NoThunks)
+
+newtype BigEndianTxIx = BigEndianTxIx {getOriginalTxIx :: SL.TxIx}
+
+instance MemPack BigEndianTxIx where
+  typeName = "BigEndianTxIx"
+  packedByteCount = packedByteCount . getOriginalTxIx
+  packM (BigEndianTxIx (SL.TxIx w)) = packM (byteSwap16 w)
+  unpackM = BigEndianTxIx . SL.TxIx . byteSwap16 <$> unpackM
+
+instance MemPack BigEndianTxIn where
+  typeName = "BigEndianTxIn"
+  packedByteCount = packedByteCount . getOriginalTxIn
+  packM (BigEndianTxIn (SL.TxIn txid txix)) = do
+    packM txid
+    packM (BigEndianTxIx txix)
+  unpackM = do
+    BigEndianTxIn <$> (SL.TxIn <$> unpackM <*> (getOriginalTxIx <$> unpackM))
+
+type instance TxIn (LedgerState (ShelleyBlock proto era)) = BigEndianTxIn
 type instance TxOut (LedgerState (ShelleyBlock proto era)) = Core.TxOut era
 
 instance
@@ -397,7 +434,7 @@ instance
       , shelleyLedgerTables = emptyLedgerTables
       }
    where
-    (_, shelleyLedgerState') = shelleyLedgerState `slUtxoL` SL.UTxO m
+    (_, shelleyLedgerState') = shelleyLedgerState `slUtxoL` SL.UTxO (coerceMapKeys m)
     ShelleyLedgerState
       { shelleyLedgerTip
       , shelleyLedgerState
@@ -409,7 +446,7 @@ instance
       { shelleyLedgerTip = shelleyLedgerTip
       , shelleyLedgerState = shelleyLedgerState'
       , shelleyLedgerTransition = shelleyLedgerTransition
-      , shelleyLedgerTables = LedgerTables (ValuesMK (SL.unUTxO tbs))
+      , shelleyLedgerTables = LedgerTables (ValuesMK (coerceMapKeys $ SL.unUTxO tbs))
       }
    where
     (tbs, shelleyLedgerState') = shelleyLedgerState `slUtxoL` mempty
@@ -432,7 +469,7 @@ instance
       }
    where
     (_, tickedShelleyLedgerState') =
-      tickedShelleyLedgerState `slUtxoL` SL.UTxO tbs
+      tickedShelleyLedgerState `slUtxoL` SL.UTxO (coerceMapKeys tbs)
     TickedShelleyLedgerState
       { untickedShelleyLedgerTip
       , tickedShelleyLedgerTransition
@@ -445,7 +482,7 @@ instance
       { untickedShelleyLedgerTip = untickedShelleyLedgerTip
       , tickedShelleyLedgerTransition = tickedShelleyLedgerTransition
       , tickedShelleyLedgerState = tickedShelleyLedgerState'
-      , tickedShelleyLedgerTables = LedgerTables (ValuesMK (SL.unUTxO tbs))
+      , tickedShelleyLedgerTables = LedgerTables (ValuesMK (coerceMapKeys (SL.unUTxO tbs)))
       }
    where
     (tbs, tickedShelleyLedgerState') = tickedShelleyLedgerState `slUtxoL` mempty
@@ -583,6 +620,7 @@ instance
   getBlockKeySets =
     LedgerTables
       . KeysMK
+      . coerceSet
       . Core.neededTxInsForBlock
       . shelleyBlockRaw
 
@@ -629,8 +667,8 @@ applyHelper f cfg blk stBefore = do
       globals
       tickedShelleyLedgerState
       ( let b = shelleyBlockRaw blk
-            h' = mkHeaderView (SL.bheader b)
-         in SL.Block h' (SL.bbody b)
+            h' = mkHeaderView (SL.blockHeader b)
+         in SL.Block h' (SL.blockBody b)
       )
 
   let track ::
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Mempool.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Mempool.hs
index 8ea85ed54..8871e22df 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Mempool.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Mempool.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
@@ -14,7 +15,10 @@
 {-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-}
-{-# OPTIONS_GHC -Wno-orphans #-}
+{-# OPTIONS_GHC -Wno-orphans -Wno-x-ord-preserving-coercions #-}
+#if __GLASGOW_HASKELL__ < 908
+{-# OPTIONS_GHC -Wno-unrecognised-warning-flags #-}
+#endif
 
 -- | Shelley mempool integration
 --
@@ -98,12 +102,13 @@ import Ouroboros.Consensus.Ledger.Tables.Utils
 import Ouroboros.Consensus.Shelley.Eras
 import Ouroboros.Consensus.Shelley.Ledger.Block
 import Ouroboros.Consensus.Shelley.Ledger.Ledger
-  ( ShelleyLedgerConfig (shelleyLedgerGlobals)
+  ( BigEndianTxIn (..)
+  , ShelleyLedgerConfig (shelleyLedgerGlobals)
   , Ticked (TickedShelleyLedgerState, tickedShelleyLedgerState)
   , getPParams
   )
 import Ouroboros.Consensus.Shelley.Protocol.Abstract (ProtoCrypto)
-import Ouroboros.Consensus.Util (ShowProxy (..))
+import Ouroboros.Consensus.Util (ShowProxy (..), coerceSet)
 import Ouroboros.Consensus.Util.Condense
 import Ouroboros.Network.Block (unwrapCBORinCBOR, wrapCBORinCBOR)
 
@@ -177,8 +182,9 @@ instance
 
   getTransactionKeySets (ShelleyTx _ tx) =
     LedgerTables $
-      KeysMK
-        (tx ^. bodyTxL . allInputsTxBodyF)
+      KeysMK $
+        coerceSet
+          (tx ^. bodyTxL . allInputsTxBodyF)
 
 mkShelleyTx :: forall era proto. ShelleyBasedEra era => Tx era -> GenTx (ShelleyBlock proto era)
 mkShelleyTx tx = ShelleyTx (txIdTx tx) tx
@@ -217,7 +223,7 @@ instance ShelleyBasedEra era => HasTxs (ShelleyBlock proto era) where
   extractTxs =
     map mkShelleyTx
       . blockBodyToTxList
-      . SL.bbody
+      . SL.blockBody
       . shelleyBlockRaw
    where
     blockBodyToTxList :: BlockBody era -> [Tx era]
@@ -388,19 +394,19 @@ txInBlockSize ::
 txInBlockSize st (ShelleyTx _txid tx') =
   validateMaybe (maxTxSizeUTxO txsz limit) $ do
     guard $ txsz <= limit
-    Just $ IgnoringOverflow $ ByteSize32 $ fromIntegral txsz + perTxOverhead
+    Just $ IgnoringOverflow $ ByteSize32 $ txsz + perTxOverhead
  where
   txsz = tx' ^. sizeTxF
 
   pparams = getPParams $ tickedShelleyLedgerState st
-  limit = fromIntegral (pparams ^. L.ppMaxTxSizeL) :: Integer
+  limit = pparams ^. L.ppMaxTxSizeL
 
 class MaxTxSizeUTxO era where
   maxTxSizeUTxO ::
     -- | Actual transaction size
-    Integer ->
+    Word32 ->
     -- | Maximum transaction size
-    Integer ->
+    Word32 ->
     SL.ApplyTxError era
 
 instance MaxTxSizeUTxO ShelleyEra where
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/NetworkProtocolVersion.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/NetworkProtocolVersion.hs
index c03e0e517..7003a5ce8 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/NetworkProtocolVersion.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/NetworkProtocolVersion.hs
@@ -48,6 +48,7 @@ instance SupportedNetworkProtocolVersion (ShelleyBlock proto era) where
     Map.fromList
       [ (NodeToNodeV_14, ShelleyNodeToNodeVersion1)
       , (NodeToNodeV_15, ShelleyNodeToNodeVersion1)
+      , (NodeToNodeV_16, ShelleyNodeToNodeVersion1)
       ]
   supportedNodeToClientVersions _ =
     Map.fromList
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/PeerSelection.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/PeerSelection.hs
index fae846a94..3ba52298c 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/PeerSelection.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/PeerSelection.hs
@@ -10,6 +10,7 @@ module Ouroboros.Consensus.Shelley.Ledger.PeerSelection () where
 import Cardano.Ledger.BaseTypes
 import qualified Cardano.Ledger.Keys as SL
 import qualified Cardano.Ledger.Shelley.API as SL
+import qualified Cardano.Ledger.State as SL
 import Control.DeepSeq (force)
 import Data.Bifunctor (second)
 import Data.Foldable (toList)
@@ -36,7 +37,7 @@ instance SL.EraCertState era => LedgerSupportsPeerSelection (ShelleyBlock proto
     poolDistr :: SL.PoolDistr
     poolDistr = SL.nesPd shelleyLedgerState
 
-    -- \| Sort stake pools by descending stake
+    -- Sort stake pools by descending stake
     orderByStake ::
       SL.PoolDistr ->
       [(SL.KeyHash 'SL.StakePool, PoolStake)]
@@ -46,20 +47,6 @@ instance SL.EraCertState era => LedgerSupportsPeerSelection (ShelleyBlock proto
         . Map.toList
         . SL.unPoolDistr
 
-    futurePoolParams
-      , poolParams ::
-        Map (SL.KeyHash 'SL.StakePool) SL.PoolParams
-    (futurePoolParams, poolParams) =
-      (SL.psFutureStakePoolParams pstate, SL.psStakePoolParams pstate)
-     where
-      pstate :: SL.PState era
-      pstate =
-        view SL.certPStateL
-          . SL.lsCertState
-          . SL.esLState
-          . SL.nesEs
-          $ shelleyLedgerState
-
     relayToLedgerRelayAccessPoint :: SL.StakePoolRelay -> Maybe LedgerRelayAccessPoint
     relayToLedgerRelayAccessPoint (SL.SingleHostAddr (SJust (Port port)) (SJust ipv4) _) =
       Just $ LedgerRelayAccessAddress (IPv4 ipv4) (fromIntegral port)
@@ -82,24 +69,32 @@ instance SL.EraCertState era => LedgerSupportsPeerSelection (ShelleyBlock proto
     relayToLedgerRelayAccessPoint (SL.MultiHostName dnsName) =
       Just $ LedgerRelayAccessSRVDomain (encodeUtf8 $ dnsToText dnsName)
 
-    -- \| Note that a stake pool can have multiple registered relays
+    -- Note that a stake pool can have multiple registered relays
     pparamsLedgerRelayAccessPoints ::
       (LedgerRelayAccessPoint -> StakePoolRelay) ->
-      SL.PoolParams ->
+      SL.StakePoolState ->
       Maybe (NonEmpty StakePoolRelay)
     pparamsLedgerRelayAccessPoints injStakePoolRelay =
       NE.nonEmpty
         . force
         . mapMaybe (fmap injStakePoolRelay . relayToLedgerRelayAccessPoint)
         . toList
-        . SL.ppRelays
+        . SL.spsRelays
 
-    -- \| Combine the stake pools registered in the future and the current pool
+    -- Combine the stake pools registered in the future and the current pool
     -- parameters, and remove duplicates.
     poolLedgerRelayAccessPoints ::
       Map (SL.KeyHash 'SL.StakePool) (NonEmpty StakePoolRelay)
     poolLedgerRelayAccessPoints =
       Map.unionWith
         (\futureRelays currentRelays -> NE.nub (futureRelays <> currentRelays))
-        (Map.mapMaybe (pparamsLedgerRelayAccessPoints FutureRelay) futurePoolParams)
-        (Map.mapMaybe (pparamsLedgerRelayAccessPoints CurrentRelay) poolParams)
+        (Map.mapMaybe (pparamsLedgerRelayAccessPoints FutureRelay) (SL.psStakePools pstate))
+        (Map.mapMaybe (pparamsLedgerRelayAccessPoints CurrentRelay) (SL.psFutureStakePools pstate))
+
+    pstate :: SL.PState era
+    pstate =
+      view SL.certPStateL
+        . SL.lsCertState
+        . SL.esLState
+        . SL.nesEs
+        $ shelleyLedgerState
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Query.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Query.hs
index a71fc8ec8..f27c67032 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Query.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Ledger/Query.hs
@@ -18,7 +18,10 @@
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
-{-# OPTIONS_GHC -Wno-orphans #-}
+{-# OPTIONS_GHC -Wno-orphans -Wno-x-ord-preserving-coercions #-}
+#if __GLASGOW_HASKELL__ < 908
+{-# OPTIONS_GHC -Wno-unrecognised-warning-flags #-}
+#endif
 
 module Ouroboros.Consensus.Shelley.Ledger.Query
   ( BlockQuery (..)
@@ -67,6 +70,7 @@ import qualified Codec.CBOR.Encoding as CBOR
 import Codec.Serialise (decode, encode)
 import Control.DeepSeq (NFData)
 import Data.Bifunctor (second)
+import Data.Coerce
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
 import Data.MemPack
@@ -105,7 +109,7 @@ import Ouroboros.Consensus.Shelley.Ledger.Query.Types
 import Ouroboros.Consensus.Shelley.Protocol.Abstract (ProtoCrypto)
 import Ouroboros.Consensus.Storage.LedgerDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
-import Ouroboros.Consensus.Util (ShowProxy (..))
+import Ouroboros.Consensus.Util (ShowProxy (..), coerceSet)
 import Ouroboros.Consensus.Util.IndexedMemPack
 import Ouroboros.Network.Block
   ( Serialised (..)
@@ -243,7 +247,7 @@ data instance BlockQuery (ShelleyBlock proto era) fp result where
     BlockQuery
       (ShelleyBlock proto era)
       QFNoTables
-      (SL.PState era)
+      SL.QueryPoolStateResult
   GetStakeSnapshots ::
     Maybe (Set (SL.KeyHash 'SL.StakePool)) ->
     BlockQuery
@@ -425,22 +429,11 @@ instance
       GetStakePools ->
         SL.getPools st
       GetStakePoolParams poolids ->
-        SL.getPoolParameters st poolids
+        SL.queryPoolParameters st poolids
       GetRewardInfoPools ->
         SL.getRewardInfoPools globals st
       GetPoolState mPoolIds ->
-        let certPState = view SL.certPStateL . SL.lsCertState . SL.esLState . SL.nesEs $ st
-         in case mPoolIds of
-              Just poolIds ->
-                SL.PState
-                  { SL.psStakePoolParams =
-                      Map.restrictKeys (SL.psStakePoolParams certPState) poolIds
-                  , SL.psFutureStakePoolParams =
-                      Map.restrictKeys (SL.psFutureStakePoolParams certPState) poolIds
-                  , SL.psRetiring = Map.restrictKeys (SL.psRetiring certPState) poolIds
-                  , SL.psDeposits = Map.restrictKeys (SL.psDeposits certPState) poolIds
-                  }
-              Nothing -> certPState
+        SL.queryPoolState st mPoolIds
       GetStakeSnapshots mPoolIds ->
         let SL.SnapShots
               { SL.ssStakeMark
@@ -554,9 +547,9 @@ instance
     hst = headerState ext
     st = shelleyLedgerState lst
 
-  answerBlockQueryLookup = answerShelleyLookupQueries id id id
+  answerBlockQueryLookup = answerShelleyLookupQueries id id coerce
 
-  answerBlockQueryTraverse = answerShelleyTraversingQueries id id shelleyQFTraverseTablesPredicate
+  answerBlockQueryTraverse = answerShelleyTraversingQueries id coerce shelleyQFTraverseTablesPredicate
 
   -- \| Is the given query supported by the given 'ShelleyNodeToClientVersion'?
   blockQueryIsSupportedOnVersion = \case
@@ -1242,7 +1235,7 @@ answerShelleyLookupQueries injTables ejTxOut ejTxIn cfg q forker =
     LedgerTables (ValuesMK values) <-
       LedgerDB.roforkerReadTables
         forker
-        (castLedgerTables $ injTables (LedgerTables $ KeysMK txins))
+        (castLedgerTables $ injTables (LedgerTables $ KeysMK $ coerceSet txins))
     pure $
       SL.UTxO $
         Map.mapKeys ejTxIn $
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Common.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Common.hs
index dcfbed49c..0627992c1 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Common.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Common.hs
@@ -19,12 +19,10 @@ module Ouroboros.Consensus.Shelley.Node.Common
   , shelleyBlockIssuerVKey
   ) where
 
-import Cardano.Crypto.KES (UnsoundPureSignKeyKES)
 import Cardano.Ledger.BaseTypes (unNonZero)
 import qualified Cardano.Ledger.Keys as SL
 import qualified Cardano.Ledger.Shelley.API as SL
 import Cardano.Ledger.Slot
-import Cardano.Protocol.Crypto
 import Data.Text (Text)
 import Ouroboros.Consensus.Block
   ( CannotForge
@@ -59,12 +57,7 @@ import Ouroboros.Consensus.Storage.ImmutableDB
 -------------------------------------------------------------------------------}
 
 data ShelleyLeaderCredentials c = ShelleyLeaderCredentials
-  { shelleyLeaderCredentialsInitSignKey :: UnsoundPureSignKeyKES (KES c)
-  -- ^ The unevolved signing KES key (at evolution 0).
-  --
-  -- Note that this is not inside 'ShelleyCanBeLeader' since it gets evolved
-  -- automatically, whereas 'ShelleyCanBeLeader' does not change.
-  , shelleyLeaderCredentialsCanBeLeader :: PraosCanBeLeader c
+  { shelleyLeaderCredentialsCanBeLeader :: PraosCanBeLeader c
   , shelleyLeaderCredentialsLabel :: Text
   -- ^ Identifier for this set of credentials.
   --
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Praos.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Praos.hs
index be72ed901..f5c00fa5c 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Praos.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/Praos.hs
@@ -29,9 +29,6 @@ import Ouroboros.Consensus.Protocol.Praos
   , PraosParams (..)
   , praosCheckCanForge
   )
-import Ouroboros.Consensus.Protocol.Praos.Common
-  ( PraosCanBeLeader (praosCanBeLeaderOpCert)
-  )
 import Ouroboros.Consensus.Shelley.Ledger
   ( ShelleyBlock
   , ShelleyCompatible
@@ -56,21 +53,13 @@ praosBlockForging ::
   , IOLike m
   ) =>
   PraosParams ->
+  HotKey.HotKey c m ->
   ShelleyLeaderCredentials c ->
-  m (BlockForging m (ShelleyBlock (Praos c) era))
-praosBlockForging praosParams credentials = do
-  hotKey <- HotKey.mkHotKey @m @c initSignKey startPeriod praosMaxKESEvo
-  pure $ praosSharedBlockForging hotKey slotToPeriod credentials
+  BlockForging m (ShelleyBlock (Praos c) era)
+praosBlockForging praosParams hotKey credentials =
+  praosSharedBlockForging hotKey slotToPeriod credentials
  where
-  PraosParams{praosMaxKESEvo, praosSlotsPerKESPeriod} = praosParams
-
-  ShelleyLeaderCredentials
-    { shelleyLeaderCredentialsInitSignKey = initSignKey
-    , shelleyLeaderCredentialsCanBeLeader = canBeLeader
-    } = credentials
-
-  startPeriod :: Absolute.KESPeriod
-  startPeriod = SL.ocertKESPeriod $ praosCanBeLeaderOpCert canBeLeader
+  PraosParams{praosSlotsPerKESPeriod} = praosParams
 
   slotToPeriod :: SlotNo -> Absolute.KESPeriod
   slotToPeriod (SlotNo slot) =
@@ -95,7 +84,7 @@ praosSharedBlockForging
   ShelleyLeaderCredentials
     { shelleyLeaderCredentialsCanBeLeader = canBeLeader
     , shelleyLeaderCredentialsLabel = label
-    } = do
+    } =
     BlockForging
       { forgeLabel = label <> "_" <> T.pack (L.eraName @era)
       , canBeLeader = canBeLeader
@@ -111,4 +100,5 @@ praosSharedBlockForging
             hotKey
             canBeLeader
             cfg
+      , finalize = HotKey.finalize hotKey
       }
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/TPraos.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/TPraos.hs
index f0316ba9d..a4889b98b 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/TPraos.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/Node/TPraos.hs
@@ -43,6 +43,7 @@ import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.EpochInfo
 import Cardano.Slotting.Time (mkSlotLength)
 import Control.Monad.Except (Except)
+import qualified Control.Tracer as Tracer
 import Data.Bifunctor (first)
 import qualified Data.Text as T
 import qualified Data.Text as Text
@@ -59,6 +60,7 @@ import Ouroboros.Consensus.Node.ProtocolInfo
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Protocol.Ledger.HotKey (HotKey)
 import qualified Ouroboros.Consensus.Protocol.Ledger.HotKey as HotKey
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
 import Ouroboros.Consensus.Protocol.Praos.Common
 import Ouroboros.Consensus.Protocol.TPraos
 import Ouroboros.Consensus.Shelley.Eras
@@ -91,21 +93,13 @@ shelleyBlockForging ::
   , IOLike m
   ) =>
   TPraosParams ->
+  HotKey c m ->
   ShelleyLeaderCredentials c ->
-  m (BlockForging m (ShelleyBlock (TPraos c) era))
-shelleyBlockForging tpraosParams credentials = do
-  hotKey <- HotKey.mkHotKey @m @c initSignKey startPeriod tpraosMaxKESEvo
-  pure $ shelleySharedBlockForging hotKey slotToPeriod credentials
+  BlockForging m (ShelleyBlock (TPraos c) era)
+shelleyBlockForging tpraosParams hotKey credentials = do
+  shelleySharedBlockForging hotKey slotToPeriod credentials
  where
-  TPraosParams{tpraosMaxKESEvo, tpraosSlotsPerKESPeriod} = tpraosParams
-
-  ShelleyLeaderCredentials
-    { shelleyLeaderCredentialsInitSignKey = initSignKey
-    , shelleyLeaderCredentialsCanBeLeader = canBeLeader
-    } = credentials
-
-  startPeriod :: Absolute.KESPeriod
-  startPeriod = SL.ocertKESPeriod $ praosCanBeLeaderOpCert canBeLeader
+  TPraosParams{tpraosSlotsPerKESPeriod} = tpraosParams
 
   slotToPeriod :: SlotNo -> Absolute.KESPeriod
   slotToPeriod (SlotNo slot) =
@@ -141,6 +135,7 @@ shelleySharedBlockForging hotKey slotToPeriod credentials =
           hotKey
           canBeLeader
           cfg
+    , finalize = HotKey.finalize hotKey
     }
  where
   ShelleyLeaderCredentials
@@ -173,14 +168,16 @@ validateGenesis = first errsToString . SL.validateGenesis
 protocolInfoShelley ::
   forall m c.
   ( IOLike m
+  , AgentCrypto c
   , ShelleyCompatible (TPraos c) ShelleyEra
   , TxLimits (ShelleyBlock (TPraos c) ShelleyEra)
+  , MonadKESAgent m
   ) =>
   SL.ShelleyGenesis ->
   ProtocolParamsShelleyBased c ->
   SL.ProtVer ->
   ( ProtocolInfo (ShelleyBlock (TPraos c) ShelleyEra)
-  , m [BlockForging m (ShelleyBlock (TPraos c) ShelleyEra)]
+  , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (ShelleyBlock (TPraos c) ShelleyEra)]
   )
 protocolInfoShelley
   shelleyGenesis
@@ -193,16 +190,16 @@ protocolInfoShelley
 
 protocolInfoTPraosShelleyBased ::
   forall m era c.
-  ( IOLike m
-  , ShelleyCompatible (TPraos c) era
+  ( ShelleyCompatible (TPraos c) era
   , TxLimits (ShelleyBlock (TPraos c) era)
+  , KESAgentContext c m
   ) =>
   ProtocolParamsShelleyBased c ->
   L.TransitionConfig era ->
   -- | see 'shelleyProtVer', mutatis mutandi
   SL.ProtVer ->
   ( ProtocolInfo (ShelleyBlock (TPraos c) era)
-  , m [BlockForging m (ShelleyBlock (TPraos c) era)]
+  , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (ShelleyBlock (TPraos c) era)]
   )
 protocolInfoTPraosShelleyBased
   ProtocolParamsShelleyBased
@@ -216,11 +213,24 @@ protocolInfoTPraosShelleyBased
           { pInfoConfig = topLevelConfig
           , pInfoInitLedger = initExtLedgerState
           }
-      , traverse
-          (shelleyBlockForging tpraosParams)
-          credentialss
+      , \tr -> pure $ mkBlockForging tr <$> credentialss
       )
    where
+    mkBlockForging ::
+      Tracer.Tracer m KESAgentClientTrace ->
+      ShelleyLeaderCredentials c ->
+      MkBlockForging m (ShelleyBlock (TPraos c) era)
+    mkBlockForging tr credentials = MkBlockForging $ do
+      let canBeLeader = shelleyLeaderCredentialsCanBeLeader credentials
+
+      hotKey :: HotKey c m <-
+        instantiatePraosCredentials
+          (tpraosMaxKESEvo tpraosParams)
+          tr
+          (praosCanBeLeaderCredentialsSource canBeLeader)
+
+      return $ shelleyBlockForging tpraosParams hotKey credentials
+
     genesis :: SL.ShelleyGenesis
     genesis = transitionCfg ^. L.tcShelleyGenesisL
 
diff --git a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/ShelleyHFC.hs b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/ShelleyHFC.hs
index 1ec5d58f4..f03c7320e 100644
--- a/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/ShelleyHFC.hs
+++ b/ouroboros-consensus-cardano/src/shelley/Ouroboros/Consensus/Shelley/ShelleyHFC.hs
@@ -10,7 +10,6 @@
 {-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
@@ -426,10 +425,10 @@ instance
   HasCanonicalTxIn '[ShelleyBlock proto era]
   where
   newtype CanonicalTxIn '[ShelleyBlock proto era] = ShelleyBlockHFCTxIn
-    { getShelleyBlockHFCTxIn :: SL.TxIn
+    { getShelleyBlockHFCTxIn :: BigEndianTxIn
     }
     deriving stock (Show, Eq, Ord)
-    deriving newtype NoThunks
+    deriving newtype (NoThunks, MemPack)
 
   injectCanonicalTxIn IZ txIn = ShelleyBlockHFCTxIn txIn
   injectCanonicalTxIn (IS idx') _ = case idx' of {}
@@ -437,8 +436,6 @@ instance
   ejectCanonicalTxIn IZ txIn = getShelleyBlockHFCTxIn txIn
   ejectCanonicalTxIn (IS idx') _ = case idx' of {}
 
-deriving newtype instance MemPack (CanonicalTxIn '[ShelleyBlock proto era])
-
 {-------------------------------------------------------------------------------
   HardForkTxOut
 -------------------------------------------------------------------------------}
@@ -465,14 +462,14 @@ instance
   BlockSupportsHFLedgerQuery '[ShelleyBlock proto era]
   where
   answerBlockQueryHFLookup = \case
-    IZ -> answerShelleyLookupQueries (injectLedgerTables IZ) id (ejectCanonicalTxIn IZ)
+    IZ -> answerShelleyLookupQueries (injectLedgerTables IZ) id (coerce . ejectCanonicalTxIn IZ)
     IS idx -> case idx of {}
 
   answerBlockQueryHFTraverse = \case
     IZ ->
       answerShelleyTraversingQueries
         id
-        (ejectCanonicalTxIn IZ)
+        (coerce . ejectCanonicalTxIn IZ)
         (queryLedgerGetTraversingFilter @('[ShelleyBlock proto era]) IZ)
     IS idx -> case idx of {}
 
diff --git a/ouroboros-consensus-cardano/src/unstable-byron-testlib/Ouroboros/Consensus/ByronDual/Node.hs b/ouroboros-consensus-cardano/src/unstable-byron-testlib/Ouroboros/Consensus/ByronDual/Node.hs
index 8f8255cc0..38d2cc722 100644
--- a/ouroboros-consensus-cardano/src/unstable-byron-testlib/Ouroboros/Consensus/ByronDual/Node.hs
+++ b/ouroboros-consensus-cardano/src/unstable-byron-testlib/Ouroboros/Consensus/ByronDual/Node.hs
@@ -66,6 +66,7 @@ dualByronBlockForging creds =
         fmap castForgeStateUpdateInfo .: updateForgeState (dualTopLevelConfigMain cfg)
     , checkCanForge = checkCanForge . dualTopLevelConfigMain
     , forgeBlock = return .....: forgeDualByronBlock
+    , finalize = return ()
     }
  where
   BlockForging{..} = byronBlockForging creds
diff --git a/ouroboros-consensus-cardano/src/unstable-byron-testlib/Test/ThreadNet/Infra/Byron/TrackUpdates.hs b/ouroboros-consensus-cardano/src/unstable-byron-testlib/Test/ThreadNet/Infra/Byron/TrackUpdates.hs
index defa33454..434c8b9b9 100644
--- a/ouroboros-consensus-cardano/src/unstable-byron-testlib/Test/ThreadNet/Infra/Byron/TrackUpdates.hs
+++ b/ouroboros-consensus-cardano/src/unstable-byron-testlib/Test/ThreadNet/Infra/Byron/TrackUpdates.hs
@@ -394,7 +394,7 @@ mkProtocolByronAndHardForkTxs
     TestNodeInitialization
       { tniCrucialTxs = proposals ++ votes
       , tniProtocolInfo = pInfo
-      , tniBlockForging = pure blockForging
+      , tniBlockForging = pure $ fmap (MkBlockForging . pure) blockForging
       }
    where
     ProtocolInfo{pInfoConfig} = pInfo
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/Generators.hs b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/Generators.hs
index e613b0c0f..ac35649da 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/Generators.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/Generators.hs
@@ -59,7 +59,7 @@ import Test.Consensus.Byron.Generators ()
 import Test.Consensus.Protocol.Serialisation.Generators ()
 import Test.Consensus.Shelley.Generators
 import Test.Consensus.Shelley.MockCrypto (CanMock)
-import Test.QuickCheck hiding (Some (..))
+import Test.QuickCheck (Arbitrary (..), Gen, choose, elements, frequency, oneof, vectorOf)
 import Test.Util.Orphans.Arbitrary ()
 import Test.Util.Serialisation.Roundtrip
   ( Coherent (..)
@@ -993,11 +993,11 @@ instance Arbitrary History.EraEnd where
       ]
 
 instance Arbitrary History.EraSummary where
-  arbitrary =
-    History.EraSummary
-      <$> arbitrary
-      <*> arbitrary
-      <*> arbitrary
+  -- Note: this generator may produce EraSummary with nonsensical bounds,
+  -- i.e. with existing PerasRoundNo at era start and Nothing for it at the end.
+  -- However, we only use this generator to check that the serialisation roundtrips,
+  -- and the internal structure of EraSummary is irrelevant for that.
+  arbitrary = History.EraSummary <$> arbitrary <*> arbitrary <*> arbitrary
 
 instance (Arbitrary a, SListI xs) => Arbitrary (NonEmpty xs a) where
   arbitrary = do
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/ProtocolInfo.hs b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/ProtocolInfo.hs
index a583d98f5..1f74e208f 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/ProtocolInfo.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/Consensus/Cardano/ProtocolInfo.hs
@@ -29,10 +29,11 @@ import qualified Cardano.Ledger.BaseTypes as SL
 import Cardano.Protocol.Crypto (StandardCrypto)
 import qualified Cardano.Protocol.TPraos.OCert as SL
 import qualified Cardano.Slotting.Time as Time
+import qualified Control.Tracer as Tracer
 import Data.Proxy (Proxy (..))
 import Data.SOP.Strict
 import Data.Word (Word64)
-import Ouroboros.Consensus.Block.Forging (BlockForging)
+import Ouroboros.Consensus.Block.Forging (MkBlockForging)
 import Ouroboros.Consensus.BlockchainTime (SlotLength)
 import Ouroboros.Consensus.Byron.Node
   ( ByronLeaderCredentials
@@ -60,12 +61,15 @@ import Ouroboros.Consensus.Protocol.PBFT
   ( PBftParams
   , PBftSignatureThreshold (..)
   )
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( KESAgentClientTrace
+  , KESAgentContext
+  )
 import Ouroboros.Consensus.Shelley.Node
   ( ProtocolParamsShelleyBased (..)
   , ShelleyGenesis
   , ShelleyLeaderCredentials
   )
-import Ouroboros.Consensus.Util.IOLike (IOLike)
 import qualified Test.Cardano.Ledger.Alonzo.Examples as Alonzo
 import qualified Test.Cardano.Ledger.Conway.Examples as Conway
 import qualified Test.Cardano.Ledger.Dijkstra.Examples as Dijkstra
@@ -167,7 +171,7 @@ hardForkInto Conway =
 -- more details on how to specify a value of this type.
 mkSimpleTestProtocolInfo ::
   forall c.
-  CardanoHardForkConstraints c =>
+  (CardanoHardForkConstraints c, KESAgentContext c IO) =>
   -- | Network decentralization parameter.
   Shelley.DecentralizationParam ->
   SecurityParam ->
@@ -236,7 +240,9 @@ mkSimpleTestProtocolInfo
 -- | A more generalized version of 'mkSimpleTestProtocolInfo'.
 mkTestProtocolInfo ::
   forall m c.
-  (CardanoHardForkConstraints c, IOLike m) =>
+  ( CardanoHardForkConstraints c
+  , KESAgentContext c m
+  ) =>
   -- | Id of the node for which the protocol info will be elaborated.
   (CoreNodeId, Shelley.CoreNode c) ->
   -- | These nodes will be part of the initial delegation mapping, and funds
@@ -254,7 +260,9 @@ mkTestProtocolInfo ::
   SL.ProtVer ->
   -- | Specification of the era to which the initial state should hard-fork to.
   CardanoHardForkTriggers ->
-  (ProtocolInfo (CardanoBlock c), m [BlockForging m (CardanoBlock c)])
+  ( ProtocolInfo (CardanoBlock c)
+  , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (CardanoBlock c)]
+  )
 mkTestProtocolInfo
   (coreNodeId, coreNode)
   shelleyGenesis
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/ThreadNet/Infra/ShelleyBasedHardFork.hs b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/ThreadNet/Infra/ShelleyBasedHardFork.hs
index 07b5f4b5c..7394a1651 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/ThreadNet/Infra/ShelleyBasedHardFork.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-testlib/Test/ThreadNet/Infra/ShelleyBasedHardFork.hs
@@ -12,7 +12,6 @@
 {-# LANGUAGE PatternSynonyms #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
@@ -55,6 +54,7 @@ import qualified Cardano.Ledger.Shelley.LedgerState as SL
 import Codec.CBOR.Decoding
 import Codec.CBOR.Encoding
 import Control.Monad.Except (runExcept)
+import qualified Control.Tracer as Tracer
 import Data.Coerce
 import qualified Data.Map.Strict as Map
 import Data.MemPack
@@ -69,7 +69,7 @@ import qualified Data.SOP.Telescope as Telescope
 import Data.Void (Void)
 import Lens.Micro ((^.))
 import NoThunks.Class (NoThunks)
-import Ouroboros.Consensus.Block.Forging (BlockForging)
+import Ouroboros.Consensus.Block.Forging (MkBlockForging)
 import Ouroboros.Consensus.Cardano.CanHardFork
   ( crossEraForecastAcrossShelley
   , translateChainDepStateAcrossShelley
@@ -89,6 +89,10 @@ import Ouroboros.Consensus.Ledger.SupportsProtocol
 import Ouroboros.Consensus.Ledger.Tables.Utils
 import Ouroboros.Consensus.Node
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( KESAgentClientTrace
+  , KESAgentContext
+  )
 import Ouroboros.Consensus.Protocol.TPraos
 import Ouroboros.Consensus.Shelley.Ledger
 import Ouroboros.Consensus.Shelley.Node
@@ -96,7 +100,6 @@ import Ouroboros.Consensus.Shelley.Protocol.Abstract (ProtoCrypto)
 import Ouroboros.Consensus.Storage.LedgerDB
 import Ouroboros.Consensus.TypeFamilyWrappers
 import Ouroboros.Consensus.Util (eitherToMaybe)
-import Ouroboros.Consensus.Util.IOLike (IOLike)
 import Ouroboros.Consensus.Util.IndexedMemPack
 import Test.ThreadNet.TxGen
 import Test.ThreadNet.TxGen.Shelley ()
@@ -358,7 +361,7 @@ instance
           answerShelleyLookupQueries
             (injectLedgerTables idx)
             (ejectHardForkTxOutDefault idx)
-            (ejectCanonicalTxIn idx)
+            (coerce . ejectCanonicalTxIn idx)
       )
 
   answerBlockQueryHFTraverse =
@@ -366,7 +369,7 @@ instance
       ( \idx ->
           answerShelleyTraversingQueries
             (ejectHardForkTxOutDefault idx)
-            (ejectCanonicalTxIn idx)
+            (coerce . ejectCanonicalTxIn idx)
             (queryLedgerGetTraversingFilter @('[ShelleyBlock proto1 era1, ShelleyBlock proto2 era2]) idx)
       )
 
@@ -384,14 +387,17 @@ instance
 
 protocolInfoShelleyBasedHardFork ::
   forall m proto1 era1 proto2 era2.
-  (IOLike m, ShelleyBasedHardForkConstraints proto1 era1 proto2 era2) =>
+  ( KESAgentContext (ProtoCrypto proto2) m
+  , ShelleyBasedHardForkConstraints proto1 era1 proto2 era2
+  ) =>
   ProtocolParamsShelleyBased (ProtoCrypto proto1) ->
   SL.ProtVer ->
   SL.ProtVer ->
   L.TransitionConfig era2 ->
   TriggerHardFork ->
   ( ProtocolInfo (ShelleyBasedHardForkBlock proto1 era1 proto2 era2)
-  , m [BlockForging m (ShelleyBasedHardForkBlock proto1 era1 proto2 era2)]
+  , Tracer.Tracer m KESAgentClientTrace ->
+    m [MkBlockForging m (ShelleyBasedHardForkBlock proto1 era1 proto2 era2)]
   )
 protocolInfoShelleyBasedHardFork
   protocolParamsShelleyBased
@@ -424,7 +430,8 @@ protocolInfoShelleyBasedHardFork
     genesis = transCfg2 ^. L.tcShelleyGenesisL
 
     protocolInfo1 :: ProtocolInfo (ShelleyBlock proto1 era1)
-    blockForging1 :: m [BlockForging m (ShelleyBlock proto1 era1)]
+    blockForging1 ::
+      Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (ShelleyBlock proto1 era1)]
     (protocolInfo1, blockForging1) =
       protocolInfoTPraosShelleyBased
         protocolParamsShelleyBased
@@ -446,7 +453,8 @@ protocolInfoShelleyBasedHardFork
     -- Era 2
 
     protocolInfo2 :: ProtocolInfo (ShelleyBlock proto2 era2)
-    blockForging2 :: m [BlockForging m (ShelleyBlock proto2 era2)]
+    blockForging2 ::
+      Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (ShelleyBlock proto2 era2)]
     (protocolInfo2, blockForging2) =
       protocolInfoTPraosShelleyBased
         ProtocolParamsShelleyBased
@@ -495,10 +503,10 @@ instance
   where
   newtype CanonicalTxIn (ShelleyBasedHardForkEras proto1 era1 proto2 era2)
     = ShelleyHFCTxIn
-    { getShelleyHFCTxIn :: SL.TxIn
+    { getShelleyHFCTxIn :: BigEndianTxIn
     }
     deriving stock (Show, Eq, Ord)
-    deriving newtype NoThunks
+    deriving newtype (NoThunks, MemPack)
 
   injectCanonicalTxIn IZ txIn = ShelleyHFCTxIn txIn
   injectCanonicalTxIn (IS IZ) txIn = ShelleyHFCTxIn (coerce txIn)
@@ -508,10 +516,6 @@ instance
   ejectCanonicalTxIn (IS IZ) txIn = coerce (getShelleyHFCTxIn txIn)
   ejectCanonicalTxIn (IS (IS idx')) _ = case idx' of {}
 
-deriving newtype instance
-  ShelleyBasedHardForkConstraints proto1 era1 proto2 era2 =>
-  MemPack (CanonicalTxIn (ShelleyBasedHardForkEras proto1 era1 proto2 era2))
-
 instance
   ShelleyBasedHardForkConstraints proto1 era1 proto2 era2 =>
   HasHardForkTxOut (ShelleyBasedHardForkEras proto1 era1 proto2 era2)
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Key.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Key.hs
index 9f1ba5c36..d80a781a2 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Key.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Key.hs
@@ -9,7 +9,6 @@ module Cardano.Api.Key
   , CastSigningKeyRole (..)
   , CastVerificationKeyRole (..)
   , Key (..)
-  , generateSigningKey
   ) where
 
 import Cardano.Api.Any
@@ -50,16 +49,17 @@ class
 
   verificationKeyHash :: VerificationKey keyrole -> Hash keyrole
 
--- TODO: We should move this into the Key type class, with the existing impl as the default impl.
--- For KES we can then override it to keep the seed and key in mlocked memory at all times.
-
--- | Generate a 'SigningKey' using a seed from operating system entropy.
-generateSigningKey :: Key keyrole => AsType keyrole -> IO (SigningKey keyrole)
-generateSigningKey keytype = do
-  seed <- Crypto.readSeedFromSystemEntropy seedSize
-  return $! deterministicSigningKey keytype seed
- where
-  seedSize = deterministicSigningKeySeedSize keytype
+  -- | Generate a 'SigningKey' using a seed from operating system entropy.
+  generateSigningKey :: AsType keyrole -> IO (SigningKey keyrole)
+  generateSigningKey keytype = do
+    --
+    -- For KES we can override this to keep the seed and key in mlocked memory
+    -- at all times.
+    --
+    seed <- Crypto.readSeedFromSystemEntropy seedSize
+    return $! deterministicSigningKey keytype seed
+   where
+    seedSize = deterministicSigningKeySeedSize keytype
 
 instance HasTypeProxy a => HasTypeProxy (VerificationKey a) where
   data AsType (VerificationKey a) = AsVerificationKey (AsType a)
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/KeysPraos.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/KeysPraos.hs
index 6a45a0341..98eb4efa1 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/KeysPraos.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/KeysPraos.hs
@@ -13,7 +13,7 @@
 -- | Praos consensus key types and their 'Key' class instances
 module Cardano.Api.KeysPraos
   ( -- * Key types
-    KesKey
+    UnsoundPureKesKey
   , VrfKey
 
     -- * Data family instances
@@ -39,88 +39,88 @@ import Data.String (IsString (..))
 -- KES keys
 --
 
-data KesKey
+data UnsoundPureKesKey
 
-instance HasTypeProxy KesKey where
-  data AsType KesKey = AsKesKey
-  proxyToAsType _ = AsKesKey
+instance HasTypeProxy UnsoundPureKesKey where
+  data AsType UnsoundPureKesKey = AsUnsoundPureKesKey
+  proxyToAsType _ = AsUnsoundPureKesKey
 
-instance Key KesKey where
-  newtype VerificationKey KesKey
+instance Key UnsoundPureKesKey where
+  newtype VerificationKey UnsoundPureKesKey
     = KesVerificationKey (Crypto.VerKeyKES (KES StandardCrypto))
     deriving stock Eq
-    deriving (Show, IsString) via UsingRawBytesHex (VerificationKey KesKey)
+    deriving (Show, IsString) via UsingRawBytesHex (VerificationKey UnsoundPureKesKey)
     deriving newtype (EncCBOR, DecCBOR, ToCBOR, FromCBOR)
     deriving anyclass SerialiseAsCBOR
 
-  newtype SigningKey KesKey
+  newtype SigningKey UnsoundPureKesKey
     = KesSigningKey (Crypto.UnsoundPureSignKeyKES (KES StandardCrypto))
-    deriving (Show, IsString) via UsingRawBytesHex (SigningKey KesKey)
+    deriving (Show, IsString) via UsingRawBytesHex (SigningKey UnsoundPureKesKey)
     deriving newtype (ToCBOR, FromCBOR)
     deriving anyclass (EncCBOR, DecCBOR, SerialiseAsCBOR)
 
   -- This loses the mlock safety of the seed, since it starts from a normal in-memory seed.
-  deterministicSigningKey :: AsType KesKey -> Crypto.Seed -> SigningKey KesKey
-  deterministicSigningKey AsKesKey =
+  deterministicSigningKey :: AsType UnsoundPureKesKey -> Crypto.Seed -> SigningKey UnsoundPureKesKey
+  deterministicSigningKey AsUnsoundPureKesKey =
     KesSigningKey . Crypto.unsoundPureGenKeyKES
 
-  deterministicSigningKeySeedSize :: AsType KesKey -> Word
-  deterministicSigningKeySeedSize AsKesKey =
+  deterministicSigningKeySeedSize :: AsType UnsoundPureKesKey -> Word
+  deterministicSigningKeySeedSize AsUnsoundPureKesKey =
     Crypto.seedSizeKES proxy
    where
     proxy :: Proxy (KES StandardCrypto)
     proxy = Proxy
 
-  getVerificationKey :: SigningKey KesKey -> VerificationKey KesKey
+  getVerificationKey :: SigningKey UnsoundPureKesKey -> VerificationKey UnsoundPureKesKey
   getVerificationKey (KesSigningKey sk) =
     KesVerificationKey (Crypto.unsoundPureDeriveVerKeyKES sk)
 
-  verificationKeyHash :: VerificationKey KesKey -> Hash KesKey
+  verificationKeyHash :: VerificationKey UnsoundPureKesKey -> Hash UnsoundPureKesKey
   verificationKeyHash (KesVerificationKey vkey) =
-    KesKeyHash (Crypto.hashVerKeyKES vkey)
+    UnsoundPureKesKeyHash (Crypto.hashVerKeyKES vkey)
 
-instance SerialiseAsRawBytes (VerificationKey KesKey) where
+instance SerialiseAsRawBytes (VerificationKey UnsoundPureKesKey) where
   serialiseToRawBytes (KesVerificationKey vk) =
     Crypto.rawSerialiseVerKeyKES vk
 
-  deserialiseFromRawBytes (AsVerificationKey AsKesKey) bs =
+  deserialiseFromRawBytes (AsVerificationKey AsUnsoundPureKesKey) bs =
     KesVerificationKey
       <$> Crypto.rawDeserialiseVerKeyKES bs
 
-instance SerialiseAsRawBytes (SigningKey KesKey) where
+instance SerialiseAsRawBytes (SigningKey UnsoundPureKesKey) where
   serialiseToRawBytes (KesSigningKey sk) =
     Crypto.rawSerialiseUnsoundPureSignKeyKES sk
 
-  deserialiseFromRawBytes (AsSigningKey AsKesKey) bs =
+  deserialiseFromRawBytes (AsSigningKey AsUnsoundPureKesKey) bs =
     KesSigningKey <$> Crypto.rawDeserialiseUnsoundPureSignKeyKES bs
 
-instance SerialiseAsBech32 (VerificationKey KesKey) where
+instance SerialiseAsBech32 (VerificationKey UnsoundPureKesKey) where
   bech32PrefixFor _ = "kes_vk"
   bech32PrefixesPermitted _ = ["kes_vk"]
 
-instance SerialiseAsBech32 (SigningKey KesKey) where
+instance SerialiseAsBech32 (SigningKey UnsoundPureKesKey) where
   bech32PrefixFor _ = "kes_sk"
   bech32PrefixesPermitted _ = ["kes_sk"]
 
-newtype instance Hash KesKey
-  = KesKeyHash
+newtype instance Hash UnsoundPureKesKey
+  = UnsoundPureKesKeyHash
       ( Crypto.Hash
           HASH
           (Crypto.VerKeyKES (KES StandardCrypto))
       )
   deriving stock (Eq, Ord)
-  deriving (Show, IsString) via UsingRawBytesHex (Hash KesKey)
-  deriving (ToCBOR, FromCBOR) via UsingRawBytes (Hash KesKey)
+  deriving (Show, IsString) via UsingRawBytesHex (Hash UnsoundPureKesKey)
+  deriving (ToCBOR, FromCBOR) via UsingRawBytes (Hash UnsoundPureKesKey)
   deriving anyclass SerialiseAsCBOR
 
-instance SerialiseAsRawBytes (Hash KesKey) where
-  serialiseToRawBytes (KesKeyHash vkh) =
+instance SerialiseAsRawBytes (Hash UnsoundPureKesKey) where
+  serialiseToRawBytes (UnsoundPureKesKeyHash vkh) =
     Crypto.hashToBytes vkh
 
-  deserialiseFromRawBytes (AsHash AsKesKey) bs =
-    KesKeyHash <$> Crypto.hashFromBytes bs
+  deserialiseFromRawBytes (AsHash AsUnsoundPureKesKey) bs =
+    UnsoundPureKesKeyHash <$> Crypto.hashFromBytes bs
 
-instance HasTextEnvelope (VerificationKey KesKey) where
+instance HasTextEnvelope (VerificationKey UnsoundPureKesKey) where
   textEnvelopeType _ =
     "KesVerificationKey_"
       <> fromString (Crypto.algorithmNameKES proxy)
@@ -128,7 +128,7 @@ instance HasTextEnvelope (VerificationKey KesKey) where
     proxy :: Proxy (KES StandardCrypto)
     proxy = Proxy
 
-instance HasTextEnvelope (SigningKey KesKey) where
+instance HasTextEnvelope (SigningKey UnsoundPureKesKey) where
   textEnvelopeType _ =
     "KesSigningKey_"
       <> fromString (Crypto.algorithmNameKES proxy)
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/OperationalCertificate.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/OperationalCertificate.hs
index 7be79132f..979cefa97 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/OperationalCertificate.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/OperationalCertificate.hs
@@ -96,7 +96,7 @@ instance HasTypeProxy OperationalCertificateIssueCounter where
 instance HasTextEnvelope OperationalCertificate where
   textEnvelopeType _ = "NodeOperationalCertificate"
 
-getHotKey :: OperationalCertificate -> VerificationKey KesKey
+getHotKey :: OperationalCertificate -> VerificationKey UnsoundPureKesKey
 getHotKey (OperationalCertificate cert _) = KesVerificationKey $ Shelley.ocertVkHot cert
 
 getKesPeriod :: OperationalCertificate -> Word
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Protocol/Types.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Protocol/Types.hs
new file mode 100644
index 000000000..37baa9013
--- /dev/null
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Api/Protocol/Types.hs
@@ -0,0 +1,140 @@
+{-# LANGUAGE ConstraintKinds #-}
+{-# LANGUAGE ExistentialQuantification #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
+
+-- DUPLICATE -- adapted from: cardano-api/src/Cardano/Api/Protocol/Types.hs
+
+module Cardano.Api.Protocol.Types
+  ( BlockType (..)
+  , Protocol (..)
+  , ProtocolClient (..)
+  , ProtocolClientInfoArgs (..)
+  , ProtocolInfoArgs (..)
+  ) where
+
+import Cardano.Chain.Slotting (EpochSlots)
+import qualified Control.Tracer as Tracer
+import Data.Bifunctor (bimap)
+import Ouroboros.Consensus.Block.Forging (MkBlockForging (..))
+import Ouroboros.Consensus.Byron.ByronHFC (ByronBlockHFC)
+import Ouroboros.Consensus.Cardano
+import Ouroboros.Consensus.Cardano.Block
+import Ouroboros.Consensus.Cardano.Node
+import Ouroboros.Consensus.HardFork.Combinator.Embed.Unary
+import qualified Ouroboros.Consensus.Ledger.SupportsProtocol as Consensus
+  ( LedgerSupportsProtocol
+  )
+import Ouroboros.Consensus.Node.ProtocolInfo
+  ( ProtocolClientInfo (..)
+  , ProtocolInfo (..)
+  )
+import Ouroboros.Consensus.Node.Run (RunNode)
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+import qualified Ouroboros.Consensus.Protocol.TPraos as Consensus
+import qualified Ouroboros.Consensus.Shelley.Eras as Consensus (ShelleyEra)
+import Ouroboros.Consensus.Shelley.HFEras ()
+import qualified Ouroboros.Consensus.Shelley.Ledger.Block as Consensus
+  ( ShelleyBlock
+  )
+import Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol ()
+import Ouroboros.Consensus.Shelley.ShelleyHFC (ShelleyBlockHFC)
+import Ouroboros.Consensus.Util.IOLike
+
+class (RunNode blk, IOLike m) => Protocol m blk where
+  data ProtocolInfoArgs m blk
+  protocolInfo ::
+    ProtocolInfoArgs m blk ->
+    ( ProtocolInfo blk
+    , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m blk]
+    )
+
+-- | Node client support for each consensus protocol.
+--
+-- This is like 'Protocol' but for clients of the node, so with less onerous
+-- requirements than to run a node.
+class RunNode blk => ProtocolClient blk where
+  data ProtocolClientInfoArgs blk
+  protocolClientInfo :: ProtocolClientInfoArgs blk -> ProtocolClientInfo blk
+
+-- | Run PBFT against the Byron ledger
+instance IOLike m => Protocol m ByronBlockHFC where
+  data ProtocolInfoArgs m ByronBlockHFC = ProtocolInfoArgsByron ProtocolParamsByron
+  protocolInfo (ProtocolInfoArgsByron params) =
+    ( inject $ protocolInfoByron params
+    , \_ -> pure . map (MkBlockForging . pure . inject) $ blockForgingByron params
+    )
+
+instance
+  ( CardanoHardForkConstraints StandardCrypto
+  , IOLike m
+  , MonadKESAgent m
+  ) =>
+  Protocol m (CardanoBlock StandardCrypto)
+  where
+  data ProtocolInfoArgs m (CardanoBlock StandardCrypto)
+    = ProtocolInfoArgsCardano
+        (CardanoProtocolParams StandardCrypto)
+
+  protocolInfo (ProtocolInfoArgsCardano paramsCardano) =
+    protocolInfoCardano paramsCardano
+
+instance ProtocolClient ByronBlockHFC where
+  data ProtocolClientInfoArgs ByronBlockHFC
+    = ProtocolClientInfoArgsByron EpochSlots
+  protocolClientInfo (ProtocolClientInfoArgsByron epochSlots) =
+    inject $ protocolClientInfoByron epochSlots
+
+instance CardanoHardForkConstraints StandardCrypto => ProtocolClient (CardanoBlock StandardCrypto) where
+  data ProtocolClientInfoArgs (CardanoBlock StandardCrypto)
+    = ProtocolClientInfoArgsCardano EpochSlots
+  protocolClientInfo (ProtocolClientInfoArgsCardano epochSlots) =
+    protocolClientInfoCardano epochSlots
+
+instance
+  ( IOLike m
+  , MonadKESAgent m
+  , Consensus.LedgerSupportsProtocol
+      ( Consensus.ShelleyBlock
+          (Consensus.TPraos StandardCrypto)
+          ShelleyEra
+      )
+  ) =>
+  Protocol m (ShelleyBlockHFC (Consensus.TPraos StandardCrypto) ShelleyEra)
+  where
+  data ProtocolInfoArgs m (ShelleyBlockHFC (Consensus.TPraos StandardCrypto) ShelleyEra)
+    = ProtocolInfoArgsShelley
+        ShelleyGenesis
+        (ProtocolParamsShelleyBased StandardCrypto)
+        ProtVer
+  protocolInfo (ProtocolInfoArgsShelley genesis shelleyBasedProtocolParams' protVer) =
+    bimap inject injectBlockForging $ protocolInfoShelley genesis shelleyBasedProtocolParams' protVer
+   where
+    injectBlockForging bf tr = fmap (map inject) $ bf tr
+
+instance
+  Consensus.LedgerSupportsProtocol
+    ( Consensus.ShelleyBlock
+        (Consensus.TPraos StandardCrypto)
+        Consensus.ShelleyEra
+    ) =>
+  ProtocolClient (ShelleyBlockHFC (Consensus.TPraos StandardCrypto) ShelleyEra)
+  where
+  data ProtocolClientInfoArgs (ShelleyBlockHFC (Consensus.TPraos StandardCrypto) ShelleyEra)
+    = ProtocolClientInfoArgsShelley
+  protocolClientInfo ProtocolClientInfoArgsShelley =
+    inject protocolClientInfoShelley
+
+data BlockType blk where
+  ByronBlockType :: BlockType ByronBlockHFC
+  ShelleyBlockType :: BlockType (ShelleyBlockHFC (Consensus.TPraos StandardCrypto) ShelleyEra)
+  CardanoBlockType :: BlockType (CardanoBlock StandardCrypto)
+
+deriving instance Eq (BlockType blk)
+deriving instance Show (BlockType blk)
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Cardano.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Cardano.hs
index 4dc83c8d2..8a07d7ffb 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Cardano.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Cardano.hs
@@ -20,6 +20,8 @@ import Cardano.Api.Any (Error (..))
 import qualified Cardano.Chain.Update as Byron
 import qualified Cardano.Ledger.Api.Era as L
 import qualified Cardano.Ledger.Api.Transition as SL
+import Cardano.Ledger.BaseTypes
+import Cardano.Ledger.Dijkstra.PParams
 import qualified Cardano.Node.Protocol.Alonzo as Alonzo
 import qualified Cardano.Node.Protocol.Byron as Byron
 import qualified Cardano.Node.Protocol.Conway as Conway
@@ -28,6 +30,7 @@ import qualified Cardano.Node.Protocol.Shelley as Shelley
 import Cardano.Node.Types
 import Control.Monad.Trans.Except (ExceptT)
 import Control.Monad.Trans.Except.Extra (firstExceptT)
+import Data.Maybe (fromMaybe)
 import Ouroboros.Consensus.Cardano
 import qualified Ouroboros.Consensus.Cardano as Consensus
 import Ouroboros.Consensus.Cardano.Condense ()
@@ -56,7 +59,7 @@ mkConsensusProtocolCardano ::
   NodeShelleyProtocolConfiguration ->
   NodeAlonzoProtocolConfiguration ->
   NodeConwayProtocolConfiguration ->
-  NodeDijkstraProtocolConfiguration ->
+  Maybe NodeDijkstraProtocolConfiguration ->
   NodeHardForkProtocolConfiguration ->
   Maybe ProtocolFilepaths ->
   ExceptT CardanoProtocolInstantiationError IO (CardanoProtocolParams StandardCrypto)
@@ -84,10 +87,7 @@ mkConsensusProtocolCardano
     { npcConwayGenesisFile
     , npcConwayGenesisFileHash
     }
-  NodeDijkstraProtocolConfiguration
-    { npcDijkstraGenesisFile
-    , npcDijkstraGenesisFileHash
-    }
+  npcDijkstraProtocolConfig
   NodeHardForkProtocolConfiguration
     { npcTestEnableDevelopmentHardForkEras = _
     , -- During testing of the latest unreleased era, we conditionally
@@ -133,11 +133,20 @@ mkConsensusProtocolCardano
           npcConwayGenesisFile
           npcConwayGenesisFileHash
 
-    (dijkstraGenesis, _dijkstraGenesisHash) <-
-      firstExceptT CardanoProtocolInstantiationDijkstraGenesisReadError $
-        readGenesisAny
-          npcDijkstraGenesisFile
-          npcDijkstraGenesisFileHash
+    dijkstraGenesis <- case npcDijkstraProtocolConfig of
+      Nothing -> pure emptyDijkstraGenesis
+      Just
+        ( NodeDijkstraProtocolConfiguration
+            { npcDijkstraGenesisFile
+            , npcDijkstraGenesisFileHash
+            }
+          ) -> do
+          (dijkstraGenesis, _dijkstraGenesisHash) <-
+            firstExceptT CardanoProtocolInstantiationDijkstraGenesisReadError $
+              readGenesisAny
+                npcDijkstraGenesisFile
+                npcDijkstraGenesisFileHash
+          pure dijkstraGenesis
 
     shelleyLeaderCredentials <-
       firstExceptT CardanoProtocolInstantiationPraosLeaderCredentialsError $
@@ -247,6 +256,18 @@ mkConsensusProtocolCardano
         emptyCheckpointsMap
         (ProtVer (L.eraProtVerHigh @L.LatestKnownEra) 0)
 
+-- | An empty Dijkstra genesis to be provided when none is specified in the config.
+emptyDijkstraGenesis :: SL.DijkstraGenesis
+emptyDijkstraGenesis =
+  let upgradePParamsDef =
+        UpgradeDijkstraPParams
+          { udppMaxRefScriptSizePerBlock = 1048576
+          , udppMaxRefScriptSizePerTx = 204800
+          , udppRefScriptCostStride = unsafeNonZero 25600
+          , udppRefScriptCostMultiplier = fromMaybe (error "impossible") $ boundRational 1.2
+          }
+   in SL.DijkstraGenesis{SL.dgUpgradePParams = upgradePParamsDef}
+
 ------------------------------------------------------------------------------
 -- Errors
 --
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Shelley.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Shelley.hs
index 13475e12b..5a7b56d65 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Shelley.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Node/Protocol/Shelley.hs
@@ -46,6 +46,7 @@ import qualified Data.ByteString as BS
 import qualified Data.Text as T
 import Ouroboros.Consensus.Protocol.Praos.Common
   ( PraosCanBeLeader (..)
+  , PraosCredentialsSource (..)
   )
 import Ouroboros.Consensus.Shelley.Node
   ( Nonce (..)
@@ -156,12 +157,14 @@ opCertKesKeyCheck ::
   FilePath ->
   -- | Operational certificate
   FilePath ->
-  ExceptT PraosLeaderCredentialsError IO (OperationalCertificate, SigningKey KesKey)
+  ExceptT PraosLeaderCredentialsError IO (OperationalCertificate, SigningKey UnsoundPureKesKey)
 opCertKesKeyCheck kesFile certFile = do
   opCert <-
     firstExceptT FileError (newExceptT $ readFileTextEnvelope AsOperationalCertificate certFile)
   kesSKey <-
-    firstExceptT FileError (newExceptT $ readFileTextEnvelope (AsSigningKey AsKesKey) kesFile)
+    firstExceptT
+      FileError
+      (newExceptT $ readFileTextEnvelope (AsSigningKey AsUnsoundPureKesKey) kesFile)
   let opCertSpecifiedKesKeyhash = verificationKeyHash $ getHotKey opCert
       suppliedKesKeyHash = verificationKeyHash $ getVerificationKey kesSKey
   -- Specified KES key in operational certificate should match the one
@@ -186,11 +189,11 @@ readLeaderCredentialsBulk ProtocolFilepaths{shelleyBulkCredsFile = mfp} =
   parseShelleyCredentials ::
     ShelleyCredentials ->
     ExceptT PraosLeaderCredentialsError IO (ShelleyLeaderCredentials StandardCrypto)
-  parseShelleyCredentials ShelleyCredentials{scCert, scVrf, scKes} = do
+  parseShelleyCredentials ShelleyCredentials{scCert, scVrf, scKes} =
     mkPraosLeaderCredentials
       <$> parseEnvelope AsOperationalCertificate scCert
       <*> parseEnvelope (AsSigningKey AsVrfKey) scVrf
-      <*> parseEnvelope (AsSigningKey AsKesKey) scKes
+      <*> parseEnvelope (AsSigningKey AsUnsoundPureKesKey) scKes
 
   readBulkFile ::
     Maybe FilePath ->
@@ -220,7 +223,7 @@ readLeaderCredentialsBulk ProtocolFilepaths{shelleyBulkCredsFile = mfp} =
 mkPraosLeaderCredentials ::
   OperationalCertificate ->
   SigningKey VrfKey ->
-  SigningKey KesKey ->
+  SigningKey UnsoundPureKesKey ->
   ShelleyLeaderCredentials StandardCrypto
 mkPraosLeaderCredentials
   (OperationalCertificate opcert (StakePoolVerificationKey vkey))
@@ -229,11 +232,10 @@ mkPraosLeaderCredentials
     ShelleyLeaderCredentials
       { shelleyLeaderCredentialsCanBeLeader =
           PraosCanBeLeader
-            { praosCanBeLeaderOpCert = opcert
-            , praosCanBeLeaderColdVerKey = coerceKeyRole vkey
+            { praosCanBeLeaderColdVerKey = coerceKeyRole vkey
             , praosCanBeLeaderSignKeyVRF = vrfKey
+            , praosCanBeLeaderCredentialsSource = PraosCredentialsUnsound opcert kesKey
             }
-      , shelleyLeaderCredentialsInitSignKey = kesKey
       , shelleyLeaderCredentialsLabel = "Shelley"
       }
 
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Analysis.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Analysis.hs
index 31eedd59c..a7266edc2 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Analysis.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Analysis.hs
@@ -452,6 +452,11 @@ storeLedgerStateAt slotNo ledgerAppMode env = do
         when (blockSlot blk > slotNo) $ issueWarning blk
         when ((unBlockNo $ blockNo blk) `mod` 1000 == 0) $ reportProgress blk
         LedgerDB.tryFlush initLedgerDB
+        LedgerDB.garbageCollect initLedgerDB
+          . fromWithOrigin 0
+          . pointSlot
+          . getTip
+          =<< IOLike.atomically (LedgerDB.getImmutableTip initLedgerDB)
         return (continue blk, ())
       Left err -> do
         traceWith tracer $ LedgerErrorEvent (blockPoint blk) err
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Cardano.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Cardano.hs
index f9ca9aa31..a209eae0c 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Cardano.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Cardano.hs
@@ -31,7 +31,9 @@ import qualified Cardano.Crypto.Hash.Class as CryptoClass
 import Cardano.Crypto.Raw (Raw)
 import qualified Cardano.Ledger.Api.Era as L
 import qualified Cardano.Ledger.Api.Transition as SL
+import Cardano.Ledger.BaseTypes (boundRational, unsafeNonZero)
 import Cardano.Ledger.Core (TxOut)
+import Cardano.Ledger.Dijkstra.PParams
 import qualified Cardano.Ledger.Shelley.LedgerState as Shelley.LedgerState
 import qualified Cardano.Ledger.Shelley.UTxO as Shelley.UTxO
 import Cardano.Ledger.TxIn (TxIn)
@@ -47,7 +49,7 @@ import qualified Data.ByteString as BS
 import qualified Data.Compact as Compact
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
-import Data.Maybe (fromJust)
+import Data.Maybe (fromJust, fromMaybe)
 import Data.SOP.BasicFunctors
 import Data.SOP.Functors
 import Data.SOP.Strict
@@ -157,9 +159,11 @@ instance HasProtocolInfo (CardanoBlock StandardCrypto) where
     genesisConway <-
       either (error . show) return
         =<< Aeson.eitherDecodeFileStrict' (conwayGenesisPath cc)
-    genesisDijkstra <-
-      either (error . show) return
-        =<< Aeson.eitherDecodeFileStrict' (dijkstraGenesisPath cc)
+    genesisDijkstra <- case dijkstraGenesisPath cc of
+      Nothing -> pure emptyDijkstraGenesis
+      Just fp ->
+        either (error . show) return
+          =<< Aeson.eitherDecodeFileStrict' fp
 
     let transCfg =
           SL.mkLatestTransitionConfig genesisShelley genesisAlonzo genesisConway genesisDijkstra
@@ -182,6 +186,18 @@ instance HasProtocolInfo (CardanoBlock StandardCrypto) where
         initialNonce
         (cfgHardForkTriggers cc)
 
+-- | An empty Dijkstra genesis to be provided when none is specified in the config.
+emptyDijkstraGenesis :: SL.DijkstraGenesis
+emptyDijkstraGenesis =
+  let upgradePParamsDef =
+        UpgradeDijkstraPParams
+          { udppMaxRefScriptSizePerBlock = 1048576
+          , udppMaxRefScriptSizePerTx = 204800
+          , udppRefScriptCostStride = unsafeNonZero 25600
+          , udppRefScriptCostMultiplier = fromMaybe (error "impossible") $ boundRational 1.2
+          }
+   in SL.DijkstraGenesis{SL.dgUpgradePParams = upgradePParamsDef}
+
 data CardanoConfig = CardanoConfig
   { requiresNetworkMagic :: RequiresNetworkMagic
   -- ^ @RequiresNetworkMagic@ field
@@ -197,7 +213,7 @@ data CardanoConfig = CardanoConfig
   -- ^ @AlonzoGenesisFile@ field
   , conwayGenesisPath :: FilePath
   -- ^ @ConwayGenesisFile@ field
-  , dijkstraGenesisPath :: FilePath
+  , dijkstraGenesisPath :: Maybe FilePath
   -- ^ @DijkstraGenesisFile@ field
   , cfgHardForkTriggers :: CardanoHardForkTriggers
   -- ^ @Test*HardForkAtEpoch@ for each Shelley era
@@ -210,7 +226,7 @@ instance AdjustFilePaths CardanoConfig where
       , shelleyGenesisPath = f $ shelleyGenesisPath cc
       , alonzoGenesisPath = f $ alonzoGenesisPath cc
       , conwayGenesisPath = f $ conwayGenesisPath cc
-      , dijkstraGenesisPath = f $ dijkstraGenesisPath cc
+      , dijkstraGenesisPath = f <$> dijkstraGenesisPath cc
       -- Byron, Shelley, Alonzo, and Conway are the only eras that have genesis
       -- data. The actual genesis block is a Byron block, therefore we needed a
       -- genesis file. To transition to Shelley, we needed to add some additional
@@ -241,7 +257,7 @@ instance Aeson.FromJSON CardanoConfig where
 
     conwayGenesisPath <- v Aeson..: "ConwayGenesisFile"
 
-    dijkstraGenesisPath <- v Aeson..: "DijkstraGenesisFile"
+    dijkstraGenesisPath <- v Aeson..:? "DijkstraGenesisFile"
 
     triggers <- do
       let parseTrigger ::
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Shelley.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Shelley.hs
index ec86020b9..acdd8e674 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Shelley.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Block/Shelley.hs
@@ -52,6 +52,7 @@ import Ouroboros.Consensus.Shelley.Node
   , ShelleyGenesis
   , protocolInfoShelley
   )
+import Ouroboros.Network.SizeInBytes (SizeInBytes (SizeInBytes))
 import TextBuilder (decimal)
 
 -- | Usable for each Shelley-based era
@@ -70,7 +71,7 @@ instance
   blockTxSizes blk = case Shelley.shelleyBlockRaw blk of
     SL.Block _ body ->
       toList $
-        fmap (fromIntegral @Integer @SizeInBytes . view Core.sizeTxF) (body ^. Core.txSeqBlockBodyL)
+        fmap (SizeInBytes . view Core.sizeTxF) (body ^. Core.txSeqBlockBodyL)
 
   knownEBBs = const Map.empty
 
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Run.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Run.hs
index f5dcb402e..5a2fe7776 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Run.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Run.hs
@@ -15,14 +15,15 @@ import Cardano.Tools.DBAnalyser.HasAnalysis
 import Cardano.Tools.DBAnalyser.Types
 import Control.ResourceRegistry
 import Control.Tracer (Tracer (..), nullTracer)
+import Data.Functor.Contravariant ((>$<))
 import qualified Data.SOP.Dict as Dict
 import Data.Singletons (Sing, SingI (..))
-import Data.Void
 import qualified Debug.Trace as Debug
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.HardFork.Abstract
 import Ouroboros.Consensus.Ledger.Basics
+import Ouroboros.Consensus.Ledger.Extended
 import Ouroboros.Consensus.Ledger.Inspect
 import qualified Ouroboros.Consensus.Ledger.SupportsMempool as LedgerSupportsMempool
   ( HasTxs
@@ -35,19 +36,24 @@ import qualified Ouroboros.Consensus.Storage.ChainDB as ChainDB
 import qualified Ouroboros.Consensus.Storage.ChainDB.Impl.Args as ChainDB
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
 import qualified Ouroboros.Consensus.Storage.ImmutableDB.Stream as ImmutableDB
+import Ouroboros.Consensus.Storage.LedgerDB (TraceEvent (..))
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1 as LedgerDB.V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Args as LedgerDB.V1
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as LedgerDB.V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB as LMDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots as LedgerDB.V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V2 as LedgerDB.V2
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as LedgerDB.V2
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as LedgerDB.V2
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as InMemory
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.LSM as LSM
 import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.Orphans ()
 import Ouroboros.Network.Block (genesisPoint)
+import System.FS.API
 import System.IO
+import System.Random
 import Text.Printf (printf)
 
 {-------------------------------------------------------------------------------
@@ -55,6 +61,7 @@ import Text.Printf (printf)
 -------------------------------------------------------------------------------}
 
 openLedgerDB ::
+  forall blk.
   ( LedgerSupportsProtocol blk
   , InspectLedger blk
   , HasHardForkHistory blk
@@ -65,40 +72,42 @@ openLedgerDB ::
     ( LedgerDB.LedgerDB' IO blk
     , LedgerDB.TestInternals' IO blk
     )
-openLedgerDB lgrDbArgs@LedgerDB.LedgerDbArgs{LedgerDB.lgrFlavorArgs = LedgerDB.LedgerDbFlavorArgsV1 bss} = do
-  let snapManager = LedgerDB.V1.snapshotManager lgrDbArgs
-  (ledgerDB, _, intLedgerDB) <-
-    LedgerDB.openDBInternal
-      lgrDbArgs
-      ( LedgerDB.V1.mkInitDb
-          lgrDbArgs
-          bss
-          (\_ -> error "no replay")
-          snapManager
-          (LedgerDB.praosGetVolatileSuffix $ LedgerDB.ledgerDbCfgSecParam $ LedgerDB.lgrConfig lgrDbArgs)
-      )
-      snapManager
-      emptyStream
-      genesisPoint
-  pure (ledgerDB, intLedgerDB)
-openLedgerDB lgrDbArgs@LedgerDB.LedgerDbArgs{LedgerDB.lgrFlavorArgs = LedgerDB.LedgerDbFlavorArgsV2 args} = do
-  (snapManager, bss') <- case args of
-    LedgerDB.V2.V2Args LedgerDB.V2.InMemoryHandleArgs -> pure (InMemory.snapshotManager lgrDbArgs, LedgerDB.V2.InMemoryHandleEnv)
-    LedgerDB.V2.V2Args (LedgerDB.V2.LSMHandleArgs (LedgerDB.V2.LSMArgs x)) -> absurd x
-  (ledgerDB, _, intLedgerDB) <-
-    LedgerDB.openDBInternal
-      lgrDbArgs
-      ( LedgerDB.V2.mkInitDb
-          lgrDbArgs
-          bss'
-          (\_ -> error "no replay")
-          snapManager
-          (LedgerDB.praosGetVolatileSuffix $ LedgerDB.ledgerDbCfgSecParam $ LedgerDB.lgrConfig lgrDbArgs)
-      )
-      snapManager
-      emptyStream
-      genesisPoint
-  pure (ledgerDB, intLedgerDB)
+openLedgerDB args = do
+  (ldb, _, od) <- case LedgerDB.lgrBackendArgs args of
+    LedgerDB.LedgerDbBackendArgsV1 bss ->
+      let snapManager = LedgerDB.V1.snapshotManager args
+          initDb =
+            LedgerDB.V1.mkInitDb
+              args
+              bss
+              (\_ -> pure (error "no stream"))
+              snapManager
+              (LedgerDB.praosGetVolatileSuffix $ LedgerDB.ledgerDbCfgSecParam $ LedgerDB.lgrConfig args)
+       in LedgerDB.openDBInternal args initDb snapManager emptyStream genesisPoint
+    LedgerDB.LedgerDbBackendArgsV2 (LedgerDB.V2.SomeBackendArgs bArgs) -> do
+      res <-
+        LedgerDB.V2.mkResources
+          (Proxy @blk)
+          (LedgerDBFlavorImplEvent . LedgerDB.FlavorImplSpecificTraceV2 >$< LedgerDB.lgrTracer args)
+          bArgs
+          (LedgerDB.lgrRegistry args)
+          (LedgerDB.lgrHasFS args)
+      let snapManager =
+            LedgerDB.V2.snapshotManager
+              (Proxy @blk)
+              res
+              (configCodec . getExtLedgerCfg . LedgerDB.ledgerDbCfg $ LedgerDB.lgrConfig args)
+              (LedgerDBSnapshotEvent >$< LedgerDB.lgrTracer args)
+              (LedgerDB.lgrHasFS args)
+      let initDb =
+            LedgerDB.V2.mkInitDb
+              args
+              (\_ -> pure (error "no stream"))
+              snapManager
+              (LedgerDB.praosGetVolatileSuffix $ LedgerDB.ledgerDbCfgSecParam $ LedgerDB.lgrConfig args)
+              res
+      LedgerDB.openDBInternal args initDb snapManager emptyStream genesisPoint
+  pure (ldb, od)
 
 emptyStream :: Applicative m => ImmutableDB.StreamAPI m blk a
 emptyStream = ImmutableDB.StreamAPI $ \_ k -> k $ Right $ pure ImmutableDB.NoMoreItems
@@ -128,30 +137,29 @@ analyse dbaConfig args =
     lock <- newMVar ()
     chainDBTracer <- mkTracer lock verbose
     analysisTracer <- mkTracer lock True
+    lsmSalt <- fst . genWord64 <$> newStdGen
     ProtocolInfo{pInfoInitLedger = genesisLedger, pInfoConfig = cfg} <-
       mkProtocolInfo args
     let shfs = Node.stdMkChainDbHasFS dbDir
         chunkInfo = Node.nodeImmutableDbChunkInfo (configStorage cfg)
         flavargs = case ldbBackend of
-          V1InMem ->
-            LedgerDB.LedgerDbFlavorArgsV1
-              ( LedgerDB.V1.V1Args
-                  LedgerDB.V1.DisableFlushing
-                  LedgerDB.V1.InMemoryBackingStoreArgs
-              )
           V1LMDB ->
-            LedgerDB.LedgerDbFlavorArgsV1
-              ( LedgerDB.V1.V1Args
-                  LedgerDB.V1.DisableFlushing
-                  ( LedgerDB.V1.LMDBBackingStoreArgs
-                      "lmdb"
-                      defaultLMDBLimits
-                      Dict.Dict
-                  )
-              )
+            LedgerDB.LedgerDbBackendArgsV1
+              $ LedgerDB.V1.V1Args
+                LedgerDB.V1.DisableFlushing
+              $ LedgerDB.V1.SomeBackendArgs
+              $ LMDB.LMDBBackingStoreArgs
+                "lmdb"
+                defaultLMDBLimits
+                Dict.Dict
           V2InMem ->
-            LedgerDB.LedgerDbFlavorArgsV2
-              (LedgerDB.V2.V2Args LedgerDB.V2.InMemoryHandleArgs)
+            LedgerDB.LedgerDbBackendArgsV2 $
+              LedgerDB.V2.SomeBackendArgs InMemory.InMemArgs
+          V2LSM ->
+            LedgerDB.LedgerDbBackendArgsV2 $
+              LedgerDB.V2.SomeBackendArgs $
+                LSM.LSMArgs (mkFsPath ["lsm"]) lsmSalt (LSM.stdMkBlockIOFS dbDir)
+
         args' =
           ChainDB.completeChainDbArgs
             registry
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Types.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Types.hs
index a43929a25..aaa120215 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Types.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBAnalyser/Types.hs
@@ -49,7 +49,7 @@ newtype NumberOfBlocks = NumberOfBlocks {unNumberOfBlocks :: Word64}
 
 data Limit = Limit Int | Unlimited
 
-data LedgerDBBackend = V1InMem | V1LMDB | V2InMem
+data LedgerDBBackend = V1LMDB | V2InMem | V2LSM
 
 -- | The extent of the ChainDB on-disk files validation. This is completely
 -- unrelated to validation of the ledger rules.
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Orphans.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Orphans.hs
index d1ce637a6..e42fe3d8c 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Orphans.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Orphans.hs
@@ -34,7 +34,7 @@ instance FromJSON NodeConfigStub where
         <*> v .: "ShelleyGenesisFile"
         <*> v .: "ByronGenesisFile"
         <*> v .: "ConwayGenesisFile"
-        <*> v .: "DijkstraGenesisFile"
+        <*> v .:? "DijkstraGenesisFile"
 
 instance AdjustFilePaths NodeConfigStub where
   adjustFilePaths f nc =
@@ -43,7 +43,7 @@ instance AdjustFilePaths NodeConfigStub where
       , ncsShelleyGenesisFile = f $ ncsShelleyGenesisFile nc
       , ncsByronGenesisFile = f $ ncsByronGenesisFile nc
       , ncsConwayGenesisFile = f $ ncsConwayGenesisFile nc
-      , ncsDijkstraGenesisFile = f $ ncsDijkstraGenesisFile nc
+      , ncsDijkstraGenesisFile = fmap f $ ncsDijkstraGenesisFile nc
       }
 
 instance AdjustFilePaths NodeCredentials where
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Run.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Run.hs
index dc9c0db13..c05b62bea 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Run.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Run.hs
@@ -32,7 +32,9 @@ import Data.Aeson as Aeson
   )
 import Data.Bool (bool)
 import Data.ByteString as BS (ByteString, readFile)
+import Data.Functor (($>))
 import qualified Data.Set as Set
+import qualified Ouroboros.Consensus.Block.Forging as BlockForging
 import Ouroboros.Consensus.Cardano.Block
 import Ouroboros.Consensus.Cardano.Node
 import Ouroboros.Consensus.Config (TopLevelConfig, configStorage)
@@ -50,7 +52,8 @@ import qualified Ouroboros.Consensus.Storage.ChainDB as ChainDB (getTipPoint)
 import qualified Ouroboros.Consensus.Storage.ChainDB.Impl as ChainDB
 import qualified Ouroboros.Consensus.Storage.ChainDB.Impl.Args as ChainDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
-import Ouroboros.Consensus.Storage.LedgerDB.V1.Args as LedgerDB.V1
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
+import Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory
 import Ouroboros.Consensus.Util.IOLike (atomically)
 import Ouroboros.Network.Block
 import Ouroboros.Network.Point (WithOrigin (..))
@@ -118,7 +121,10 @@ initialize NodeFilePaths{nfpConfig, nfpChainDB} creds synthOptions = do
     shelleyConfig = NodeShelleyProtocolConfiguration (GenesisFile $ ncsShelleyGenesisFile confConfigStub) Nothing
     alonzoConfig = NodeAlonzoProtocolConfiguration (GenesisFile $ ncsAlonzoGenesisFile confConfigStub) Nothing
     conwayConfig = NodeConwayProtocolConfiguration (GenesisFile $ ncsConwayGenesisFile confConfigStub) Nothing
-    dijkstraConfig = NodeDijkstraProtocolConfiguration (GenesisFile $ ncsDijkstraGenesisFile confConfigStub) Nothing
+    dijkstraConfig =
+      fmap
+        (\x -> NodeDijkstraProtocolConfiguration (GenesisFile x) Nothing)
+        (ncsDijkstraGenesisFile confConfigStub)
     hfConfig_ = eitherParseJson $ ncsNodeConfig confConfigStub
     byConfig_ = eitherParseJson $ ncsNodeConfig confConfigStub
 
@@ -145,8 +151,7 @@ synthesize genTxs DBSynthesizerConfig{confOptions, confShelleyGenesis, confDbDir
     let
       epochSize = sgEpochLength confShelleyGenesis
       chunkInfo = Node.nodeImmutableDbChunkInfo (configStorage pInfoConfig)
-      bss = LedgerDB.V1.V1Args LedgerDB.V1.DisableFlushing InMemoryBackingStoreArgs
-      flavargs = LedgerDB.LedgerDbFlavorArgsV1 bss
+      flavargs = LedgerDB.LedgerDbBackendArgsV2 $ SomeBackendArgs InMemArgs
       dbArgs =
         ChainDB.completeChainDbArgs
           registry
@@ -159,26 +164,33 @@ synthesize genTxs DBSynthesizerConfig{confOptions, confShelleyGenesis, confDbDir
           flavargs
           $ ChainDB.defaultArgs
 
-    forgers <- blockForging
+    mbfs <- mkForgers nullTracer
+    allocatedForgers <-
+      traverse
+        (\mbf -> allocate registry (const (BlockForging.mkBlockForging mbf)) BlockForging.finalize)
+        mbfs
+    let forgers = snd <$> allocatedForgers
     let fCount = length forgers
     putStrLn $ "--> forger count: " ++ show fCount
-    if fCount > 0
-      then do
-        putStrLn $ "--> opening ChainDB on file system with mode: " ++ show synthOpenMode
-        preOpenChainDB synthOpenMode confDbDir
-        let dbTracer = nullTracer
-        ChainDB.withDB (ChainDB.updateTracer dbTracer dbArgs) $ \chainDB -> do
-          slotNo <- do
-            tip <- atomically (ChainDB.getTipPoint chainDB)
-            pure $ case pointSlot tip of
-              Origin -> 0
-              At s -> succ s
+    r <-
+      if fCount > 0
+        then do
+          putStrLn $ "--> opening ChainDB on file system with mode: " ++ show synthOpenMode
+          preOpenChainDB synthOpenMode confDbDir
+          let dbTracer = nullTracer
+          ChainDB.withDB (ChainDB.updateTracer dbTracer dbArgs) $ \chainDB -> do
+            slotNo <- do
+              tip <- atomically (ChainDB.getTipPoint chainDB)
+              pure $ case pointSlot tip of
+                Origin -> 0
+                At s -> succ s
 
-          putStrLn $ "--> starting at: " ++ show slotNo
-          runForge epochSize slotNo synthLimit chainDB forgers pInfoConfig $ genTxs pInfoConfig
-      else do
-        putStrLn "--> no forgers found; leaving possibly existing ChainDB untouched"
-        pure $ ForgeResult 0
+            putStrLn $ "--> starting at: " ++ show slotNo
+            runForge epochSize slotNo synthLimit chainDB forgers pInfoConfig $ genTxs pInfoConfig
+        else do
+          putStrLn "--> no forgers found; leaving possibly existing ChainDB untouched"
+          pure $ ForgeResult 0
+    mapM_ (release . fst) allocatedForgers $> r
  where
   DBSynthesizerOptions
     { synthOpenMode
@@ -188,7 +200,7 @@ synthesize genTxs DBSynthesizerConfig{confOptions, confShelleyGenesis, confDbDir
       { pInfoConfig
       , pInfoInitLedger
       }
-    , blockForging
+    , mkForgers
     ) = protocolInfoCardano runP
 
 preOpenChainDB :: DBSynthesizerOpenMode -> FilePath -> IO ()
diff --git a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Types.hs b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Types.hs
index 36abd183c..5ab84d040 100644
--- a/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Types.hs
+++ b/ouroboros-consensus-cardano/src/unstable-cardano-tools/Cardano/Tools/DBSynthesizer/Types.hs
@@ -12,7 +12,7 @@ data NodeConfigStub = NodeConfigStub
   , ncsShelleyGenesisFile :: !FilePath
   , ncsByronGenesisFile :: !FilePath
   , ncsConwayGenesisFile :: !FilePath
-  , ncsDijkstraGenesisFile :: !FilePath
+  , ncsDijkstraGenesisFile :: !(Maybe FilePath)
   }
   deriving Show
 
diff --git a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Examples.hs b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Examples.hs
index 667ab6465..7d7bba34f 100644
--- a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Examples.hs
+++ b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Examples.hs
@@ -102,7 +102,7 @@ mkLedgerTables tx =
       Map.fromList $
         zip exampleTxIns exampleTxOuts
  where
-  exampleTxIns :: [SL.TxIn]
+  exampleTxIns :: [BigEndianTxIn]
   exampleTxIns = case toList (tx ^. (LC.bodyTxL . LC.allInputsTxBodyF)) of
     [] -> error "No transaction inputs were provided to construct the ledger tables"
     -- We require at least one transaction input (and one
@@ -112,7 +112,7 @@ mkLedgerTables tx =
     --
     -- Also all transactions in Cardano have at least one input for
     -- automatic replay protection.
-    xs -> xs
+    xs -> map BigEndianTxIn xs
 
   exampleTxOuts :: [LC.TxOut era]
   exampleTxOuts = case toList (tx ^. (LC.bodyTxL . LC.outputsTxBodyL)) of
diff --git a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Generators.hs b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Generators.hs
index 414a57bf7..3de6553e3 100644
--- a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Generators.hs
+++ b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/Generators.hs
@@ -1,9 +1,12 @@
 {-# LANGUAGE DataKinds #-}
+{-# LANGUAGE DerivingStrategies #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE GADTs #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
 {-# LANGUAGE QuantifiedConstraints #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE UndecidableInstances #-}
 {-# OPTIONS_GHC -Wno-orphans #-}
 
@@ -239,6 +242,8 @@ instance
       <*> arbitrary
       <*> (LedgerTables . ValuesMK <$> arbitrary)
 
+deriving newtype instance Arbitrary BigEndianTxIn
+
 instance CanMock proto era => Arbitrary (AnnTip (ShelleyBlock proto era)) where
   arbitrary =
     AnnTip
diff --git a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/MockCrypto.hs b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/MockCrypto.hs
index 116683086..60007eecd 100644
--- a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/MockCrypto.hs
+++ b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/Consensus/Shelley/MockCrypto.hs
@@ -2,6 +2,7 @@
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
@@ -13,10 +14,14 @@ module Test.Consensus.Shelley.MockCrypto
   , MockCrypto
   ) where
 
+import Cardano.Crypto.DSIGN (MockDSIGN)
 import Cardano.Crypto.KES (MockKES)
 import qualified Cardano.Crypto.KES as KES (Signable)
 import Cardano.Crypto.Util (SignableRepresentation)
 import Cardano.Crypto.VRF (MockVRF)
+import qualified Cardano.KESAgent.KES.Crypto as Agent
+import qualified Cardano.KESAgent.Processes.ServiceClient as Agent
+import qualified Cardano.KESAgent.Protocols.VersionedProtocol as Agent
 import Cardano.Ledger.BaseTypes (Seed)
 import qualified Cardano.Ledger.Shelley.API as SL
 import qualified Cardano.Ledger.Shelley.Core as Core
@@ -29,6 +34,9 @@ import Ouroboros.Consensus.Ledger.SupportsProtocol
   ( LedgerSupportsProtocol
   )
 import qualified Ouroboros.Consensus.Protocol.Praos as Praos
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( AgentCrypto (..)
+  )
 import Ouroboros.Consensus.Protocol.TPraos (TPraos)
 import Ouroboros.Consensus.Shelley.Eras (ShelleyEra)
 import Ouroboros.Consensus.Shelley.Ledger
@@ -82,3 +90,16 @@ type CanMock proto era =
   , Arbitrary (SL.CertState era)
   , Arbitrary (Core.BlockBody era)
   )
+
+instance Agent.NamedCrypto MockCrypto where
+  cryptoName _ = Agent.CryptoName "Mock"
+
+instance Agent.ServiceClientDrivers MockCrypto where
+  availableServiceClientDrivers = []
+
+instance Agent.Crypto MockCrypto where
+  type KES MockCrypto = MockKES 10
+  type DSIGN MockCrypto = MockDSIGN
+
+instance AgentCrypto MockCrypto where
+  type ACrypto MockCrypto = MockCrypto
diff --git a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/ThreadNet/Infra/Shelley.hs b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/ThreadNet/Infra/Shelley.hs
index 2749ee44e..db30a8e3e 100644
--- a/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/ThreadNet/Infra/Shelley.hs
+++ b/ouroboros-consensus-cardano/src/unstable-shelley-testlib/Test/ThreadNet/Infra/Shelley.hs
@@ -43,6 +43,7 @@ import Cardano.Crypto.DSIGN
   )
 import Cardano.Crypto.KES
   ( KESAlgorithm (..)
+  , UnsoundPureKESAlgorithm (..)
   , UnsoundPureSignKeyKES
   , seedSizeKES
   , unsoundPureDeriveVerKeyKES
@@ -57,7 +58,6 @@ import Cardano.Crypto.VRF
   , seedSizeVRF
   )
 import qualified Cardano.Ledger.Allegra.Scripts as SL
-import Cardano.Ledger.Alonzo (AlonzoEra)
 import Cardano.Ledger.BaseTypes (boundRational, unNonZero)
 import Cardano.Ledger.Hashes
   ( EraIndependentTxBody
@@ -79,6 +79,7 @@ import qualified Cardano.Protocol.TPraos.OCert as SL
   , OCertSignable (..)
   )
 import Control.Monad.Except (throwError)
+import qualified Control.Tracer as Tracer
 import qualified Data.ByteString as BS
 import Data.Coerce (coerce)
 import Data.ListMap (ListMap (ListMap))
@@ -97,10 +98,15 @@ import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.BlockchainTime
 import Ouroboros.Consensus.Config.SecurityParam
 import Ouroboros.Consensus.Node.ProtocolInfo
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( KESAgentClientTrace
+  , KESAgentContext
+  )
 import Ouroboros.Consensus.Protocol.Praos.Common
   ( PraosCanBeLeader (PraosCanBeLeader)
+  , PraosCredentialsSource (..)
   , praosCanBeLeaderColdVerKey
-  , praosCanBeLeaderOpCert
+  , praosCanBeLeaderCredentialsSource
   , praosCanBeLeaderSignKeyVRF
   )
 import Ouroboros.Consensus.Protocol.TPraos
@@ -115,7 +121,6 @@ import Ouroboros.Consensus.Shelley.Ledger
 import Ouroboros.Consensus.Shelley.Node
 import Ouroboros.Consensus.Shelley.Protocol.Abstract (ProtoCrypto)
 import Ouroboros.Consensus.Util.Assert
-import Ouroboros.Consensus.Util.IOLike
 import Quiet (Quiet (..))
 import qualified Test.Cardano.Ledger.Core.KeyPair as TL
   ( KeyPair (..)
@@ -245,10 +250,9 @@ genCoreNode startKESPeriod = do
 mkLeaderCredentials :: CoreNode c -> ShelleyLeaderCredentials c
 mkLeaderCredentials CoreNode{cnDelegateKey, cnVRF, cnKES, cnOCert} =
   ShelleyLeaderCredentials
-    { shelleyLeaderCredentialsInitSignKey = cnKES
-    , shelleyLeaderCredentialsCanBeLeader =
+    { shelleyLeaderCredentialsCanBeLeader =
         PraosCanBeLeader
-          { praosCanBeLeaderOpCert = cnOCert
+          { praosCanBeLeaderCredentialsSource = PraosCredentialsUnsound cnOCert cnKES
           , praosCanBeLeaderColdVerKey = SL.VKey $ deriveVerKeyDSIGN cnDelegateKey
           , praosCanBeLeaderSignKeyVRF = cnVRF
           }
@@ -457,13 +461,15 @@ mkGenesisConfig pVer k f d maxLovelaceSupply slotLength kesCfg coreNodes =
 
 mkProtocolShelley ::
   forall m c.
-  (IOLike m, ShelleyCompatible (TPraos c) ShelleyEra) =>
+  ( KESAgentContext c m
+  , ShelleyCompatible (TPraos c) ShelleyEra
+  ) =>
   ShelleyGenesis ->
   SL.Nonce ->
   ProtVer ->
   CoreNode c ->
   ( ProtocolInfo (ShelleyBlock (TPraos c) ShelleyEra)
-  , m [BlockForging m (ShelleyBlock (TPraos c) ShelleyEra)]
+  , Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (ShelleyBlock (TPraos c) ShelleyEra)]
   )
 mkProtocolShelley genesis initialNonce protVer coreNode =
   protocolInfoShelley
@@ -603,7 +609,7 @@ mkMASetDecentralizationParamTxs ::
   ( ShelleyBasedEra era
   , SL.AllegraEraTxBody era
   , SL.ShelleyEraTxBody era
-  , SL.AtMostEra AlonzoEra era
+  , SL.AtMostEra "Alonzo" era
   ) =>
   [CoreNode (ProtoCrypto proto)] ->
   -- | The proposed protocol version
diff --git a/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/Byron.hs b/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/Byron.hs
index f0ae683f7..02caefb2d 100644
--- a/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/Byron.hs
+++ b/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/Byron.hs
@@ -1481,7 +1481,7 @@ mkRekeyUpd ::
   Genesis.GeneratedSecrets ->
   CoreNodeId ->
   ProtocolInfo ByronBlock ->
-  m [BlockForging m ByronBlock] ->
+  m [MkBlockForging m ByronBlock] ->
   EpochNo ->
   Crypto.SignKeyDSIGN Crypto.ByronDSIGN ->
   m (Maybe (TestNodeInitialization m ByronBlock))
@@ -1496,7 +1496,7 @@ mkRekeyUpd genesisConfig genesisSecrets cid pInfo blockForging eno newSK = do
             TestNodeInitialization
               { tniCrucialTxs = [dlgTx (blcDlgCert creds')]
               , tniProtocolInfo = pInfo
-              , tniBlockForging = pure [blockForging']
+              , tniBlockForging = pure [MkBlockForging $ pure blockForging']
               }
  where
   bcfg = configBlock (pInfoConfig pInfo)
diff --git a/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/DualByron.hs b/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/DualByron.hs
index c21cc911b..8c3c17ed2 100644
--- a/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/DualByron.hs
+++ b/ouroboros-consensus-cardano/test/byron-test/Test/ThreadNet/DualByron.hs
@@ -153,14 +153,13 @@ setupTestOutput setup@SetupDualByron{..} =
     testConfig
     testConfigB
     TestConfigMB
-      { nodeInfo = \coreNodeId ->
-          uncurry
-            plainTestNodeInitialization
-            ( protocolInfoDualByron
-                setupGenesis
-                (setupParams setup)
-                [coreNodeId]
-            )
+      { nodeInfo = \coreNodeId -> do
+          let (pInfo, bfs) =
+                protocolInfoDualByron
+                  setupGenesis
+                  (setupParams setup)
+                  [coreNodeId]
+          plainTestNodeInitialization pInfo (fmap (fmap (MkBlockForging . pure)) bfs)
       , mkRekeyM = Nothing -- TODO
       }
  where
diff --git a/ouroboros-consensus-cardano/test/cardano-test/Test/Consensus/Cardano/Translation.hs b/ouroboros-consensus-cardano/test/cardano-test/Test/Consensus/Cardano/Translation.hs
index e06ce6343..9a4e6d197 100644
--- a/ouroboros-consensus-cardano/test/cardano-test/Test/Consensus/Cardano/Translation.hs
+++ b/ouroboros-consensus-cardano/test/cardano-test/Test/Consensus/Cardano/Translation.hs
@@ -1,4 +1,5 @@
 {-# LANGUAGE BlockArguments #-}
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
@@ -10,7 +11,10 @@
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-}
-{-# OPTIONS_GHC -Wno-orphans #-}
+{-# OPTIONS_GHC -Wno-orphans -Wno-x-ord-preserving-coercions #-}
+#if __GLASGOW_HASKELL__ < 908
+{-# OPTIONS_GHC -Wno-unrecognised-warning-flags #-}
+#endif
 
 module Test.Consensus.Cardano.Translation (tests) where
 
@@ -27,7 +31,6 @@ import Cardano.Ledger.Shelley.API
   , translateCompactTxOutByronToShelley
   , translateTxIdByronToShelley
   )
-import qualified Cardano.Ledger.Shelley.API as SL
 import Cardano.Ledger.Shelley.LedgerState
   ( esLState
   , lsUTxOState
@@ -67,7 +70,8 @@ import Ouroboros.Consensus.Protocol.TPraos (TPraos)
 import Ouroboros.Consensus.Shelley.Eras
 import Ouroboros.Consensus.Shelley.HFEras ()
 import Ouroboros.Consensus.Shelley.Ledger
-  ( ShelleyBlock
+  ( BigEndianTxIn (..)
+  , ShelleyBlock
   , ShelleyLedgerConfig
   , mkShelleyLedgerConfig
   , shelleyLedgerState
@@ -75,6 +79,7 @@ import Ouroboros.Consensus.Shelley.Ledger
   )
 import Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol ()
 import Ouroboros.Consensus.TypeFamilyWrappers
+import Ouroboros.Consensus.Util
 import Test.Cardano.Ledger.Alonzo.Binary.Twiddle ()
 import Test.Cardano.Ledger.Babbage.Binary.Twiddle ()
 import Test.Cardano.Ledger.Dijkstra.Arbitrary ()
@@ -272,7 +277,7 @@ byronUtxosAreInsertsInShelleyUtxoDiff srcLedgerState destLedgerState =
  where
   toNextUtxoDiff ::
     LedgerState ByronBlock mk ->
-    Diff.Diff SL.TxIn (Core.TxOut ShelleyEra)
+    Diff.Diff BigEndianTxIn (Core.TxOut ShelleyEra)
   toNextUtxoDiff ledgerState =
     let
       Byron.UTxO utxo = Byron.cvsUtxo $ byronLedgerState ledgerState
@@ -281,13 +286,13 @@ byronUtxosAreInsertsInShelleyUtxoDiff srcLedgerState destLedgerState =
      in
       Diff.Diff $ Map.map valFn $ Map.mapKeys keyFn utxo
 
-  translateTxInByronToShelley :: Byron.TxIn -> TxIn
+  translateTxInByronToShelley :: Byron.TxIn -> BigEndianTxIn
   translateTxInByronToShelley byronTxIn =
     let
       Byron.TxInUtxo txId txIx = byronTxIn
       shelleyTxId' = translateTxIdByronToShelley txId
      in
-      TxIn shelleyTxId' (TxIx txIx)
+      BigEndianTxIn $ TxIn shelleyTxId' (TxIx txIx)
 
 shelleyAvvmAddressesAreDeletesInUtxoDiff ::
   LedgerState (ShelleyBlock Proto ShelleyEra) EmptyMK ->
@@ -298,9 +303,9 @@ shelleyAvvmAddressesAreDeletesInUtxoDiff srcLedgerState destLedgerState =
  where
   toNextUtxoDiff ::
     LedgerState (ShelleyBlock Proto ShelleyEra) EmptyMK ->
-    Diff.Diff SL.TxIn (Core.TxOut AllegraEra)
+    Diff.Diff BigEndianTxIn (Core.TxOut AllegraEra)
   toNextUtxoDiff = avvmAddressesToUtxoDiff . stashedAVVMAddresses . shelleyLedgerState
-  avvmAddressesToUtxoDiff (UTxO m) = Diff.Diff $ Map.map (\_ -> Diff.Delete) m
+  avvmAddressesToUtxoDiff (UTxO m) = Diff.Diff $ coerceMapKeys $ Map.map (\_ -> Diff.Delete) m
 
 utxoTablesAreEmpty ::
   LedgerState (ShelleyBlock srcProto srcEra) EmptyMK ->
@@ -329,7 +334,7 @@ nonEmptyAvvmAddresses ledgerState =
 
 extractUtxoDiff ::
   LedgerState (ShelleyBlock proto era) DiffMK ->
-  Diff SL.TxIn (Core.TxOut era)
+  Diff BigEndianTxIn (Core.TxOut era)
 extractUtxoDiff shelleyLedgerState =
   let DiffMK tables = getLedgerTables $ shelleyLedgerTables shelleyLedgerState
    in tables
diff --git a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/AllegraMary.hs b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/AllegraMary.hs
index 4c04c2d53..b6d2a3777 100644
--- a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/AllegraMary.hs
+++ b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/AllegraMary.hs
@@ -20,6 +20,7 @@ import qualified Cardano.Ledger.Shelley.Core as SL
 import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.Slot (EpochSize (..), SlotNo (..))
 import Control.Monad (replicateM)
+import Control.Tracer (nullTracer)
 import qualified Data.Map.Strict as Map
 import Data.Maybe (maybeToList)
 import Data.Proxy (Proxy (..))
@@ -273,7 +274,7 @@ prop_simple_allegraMary_convergence
                                 (SlotNo $ unNumSlots numSlots) -- never expire
                                 setupD -- unchanged
                     , tniProtocolInfo = protocolInfo
-                    , tniBlockForging = blockForging
+                    , tniBlockForging = blockForging nullTracer
                     }
           , mkRekeyM = Nothing
           }
diff --git a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/Cardano.hs b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/Cardano.hs
index bab06f028..6364caede 100644
--- a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/Cardano.hs
+++ b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/Cardano.hs
@@ -26,6 +26,7 @@ import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.Slot (EpochSize (..), SlotNo (..))
 import Control.Exception (assert)
 import Control.Monad (replicateM)
+import qualified Control.Tracer as Tracer
 import qualified Data.Map.Strict as Map
 import Data.Maybe (maybeToList)
 import Data.Proxy (Proxy (..))
@@ -34,13 +35,14 @@ import Data.Set (Set)
 import qualified Data.Set as Set
 import Data.Word (Word64)
 import Lens.Micro
-import Ouroboros.Consensus.Block.Forging (BlockForging)
+import Ouroboros.Consensus.Block.Forging (MkBlockForging)
 import Ouroboros.Consensus.BlockchainTime
 import Ouroboros.Consensus.Byron.Ledger (LedgerState (..))
 import Ouroboros.Consensus.Byron.Ledger.Block (ByronBlock)
 import Ouroboros.Consensus.Byron.Ledger.Conversions
 import Ouroboros.Consensus.Byron.Node
 import Ouroboros.Consensus.Cardano.Block
+import Ouroboros.Consensus.Cardano.CanHardFork
 import Ouroboros.Consensus.Cardano.Condense ()
 import Ouroboros.Consensus.Config.SecurityParam
 import Ouroboros.Consensus.HardFork.Combinator
@@ -54,10 +56,13 @@ import Ouroboros.Consensus.Node.NetworkProtocolVersion
 import Ouroboros.Consensus.Node.ProtocolInfo
 import Ouroboros.Consensus.NodeId
 import Ouroboros.Consensus.Protocol.PBFT
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( KESAgentClientTrace
+  , KESAgentContext
+  )
 import Ouroboros.Consensus.Shelley.HFEras ()
 import Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol ()
 import Ouroboros.Consensus.Shelley.Node
-import Ouroboros.Consensus.Util.IOLike (IOLike)
 import Test.Consensus.Cardano.ProtocolInfo
   ( hardForkOnDefaultProtocolVersions
   , mkTestProtocolInfo
@@ -471,7 +476,7 @@ prop_simple_cardano_convergence
 
 mkProtocolCardanoAndHardForkTxs ::
   forall c m.
-  (IOLike m, c ~ StandardCrypto) =>
+  (CardanoHardForkConstraints c, KESAgentContext c m) =>
   -- Byron
   PBftParams ->
   CoreNodeId ->
@@ -495,7 +500,7 @@ mkProtocolCardanoAndHardForkTxs
     TestNodeInitialization
       { tniCrucialTxs = crucialTxs
       , tniProtocolInfo = protocolInfo
-      , tniBlockForging = blockForging
+      , tniBlockForging = blockForging Tracer.nullTracer
       }
    where
     crucialTxs :: [GenTx (CardanoBlock c)]
@@ -514,7 +519,7 @@ mkProtocolCardanoAndHardForkTxs
           propPV
 
     protocolInfo :: ProtocolInfo (CardanoBlock c)
-    blockForging :: m [BlockForging m (CardanoBlock c)]
+    blockForging :: Tracer.Tracer m KESAgentClientTrace -> m [MkBlockForging m (CardanoBlock c)]
     (setByronProtVer -> protocolInfo, blockForging) =
       mkTestProtocolInfo
         (coreNodeId, coreNodeShelley)
diff --git a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/MaryAlonzo.hs b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/MaryAlonzo.hs
index 7c8d818c8..f8041f692 100644
--- a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/MaryAlonzo.hs
+++ b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/MaryAlonzo.hs
@@ -25,6 +25,7 @@ import qualified Cardano.Ledger.Shelley.Core as SL
 import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.Slot (EpochSize (..), SlotNo (..))
 import Control.Monad (replicateM)
+import Control.Tracer (nullTracer)
 import qualified Data.Map.Strict as Map
 import Data.Maybe (maybeToList)
 import Data.Proxy (Proxy (..))
@@ -283,7 +284,7 @@ prop_simple_allegraAlonzo_convergence
                                 (SlotNo $ unNumSlots numSlots) -- never expire
                                 setupD -- unchanged
                     , tniProtocolInfo = protocolInfo
-                    , tniBlockForging = blockForging
+                    , tniBlockForging = blockForging nullTracer
                     }
           , mkRekeyM = Nothing
           }
diff --git a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/ShelleyAllegra.hs b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/ShelleyAllegra.hs
index 712268d12..783ea08dc 100644
--- a/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/ShelleyAllegra.hs
+++ b/ouroboros-consensus-cardano/test/cardano-test/Test/ThreadNet/ShelleyAllegra.hs
@@ -20,6 +20,7 @@ import qualified Cardano.Ledger.Shelley.Core as SL
 import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.Slot (EpochSize (..), SlotNo (..))
 import Control.Monad (replicateM)
+import Control.Tracer (nullTracer)
 import qualified Data.Map.Strict as Map
 import Data.Maybe (maybeToList)
 import Data.Proxy (Proxy (..))
@@ -282,7 +283,7 @@ prop_simple_shelleyAllegra_convergence
                                 (SlotNo $ unNumSlots numSlots) -- never expire
                                 setupD -- unchanged
                     , tniProtocolInfo = protocolInfo
-                    , tniBlockForging = blockForging
+                    , tniBlockForging = blockForging nullTracer
                     }
           , mkRekeyM = Nothing
           }
diff --git a/ouroboros-consensus-cardano/test/shelley-test/Test/Consensus/Shelley/LedgerTables.hs b/ouroboros-consensus-cardano/test/shelley-test/Test/Consensus/Shelley/LedgerTables.hs
index 720d13438..a647b1049 100644
--- a/ouroboros-consensus-cardano/test/shelley-test/Test/Consensus/Shelley/LedgerTables.hs
+++ b/ouroboros-consensus-cardano/test/shelley-test/Test/Consensus/Shelley/LedgerTables.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE DerivingStrategies #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE ScopedTypeVariables #-}
@@ -11,6 +12,9 @@
 module Test.Consensus.Shelley.LedgerTables (tests) where
 
 import qualified Cardano.Ledger.Api.Era as L
+import qualified Cardano.Ledger.BaseTypes as L
+import qualified Cardano.Ledger.Shelley.API.Types as L
+import Data.MemPack
 import Data.Proxy
 import Data.SOP.BasicFunctors
 import Data.SOP.Constraint
@@ -29,12 +33,16 @@ import Test.Cardano.Ledger.Dijkstra.Arbitrary ()
 import Test.Consensus.Shelley.Generators ()
 import Test.Consensus.Shelley.MockCrypto (CanMock)
 import Test.LedgerTables
+import Test.QuickCheck
 import Test.Tasty
 import Test.Tasty.QuickCheck
 
 tests :: TestTree
 tests =
   testGroup "LedgerTables"
+    . (testProperty "Serializing BigEndianTxIn preserves order" testBigEndianTxInPreservesOrder :)
+    . (testProperty "Serializing TxIn fails to preserve order" (expectFailure testTxInPreservesOrder) :)
+    . (testProperty "BigEndianTxIn roundtrips" testBigEndianRoundtrips :)
     . hcollapse
     . hcmap (Proxy @TestLedgerTables) (K . f)
     $ (hpure Proxy :: NP Proxy (CardanoShelleyEras StandardCrypto))
@@ -74,3 +82,21 @@ instance
   Arbitrary (LedgerTables (LedgerState (ShelleyBlock proto era)) ValuesMK)
   where
   arbitrary = projectLedgerTables . unstowLedgerTables <$> arbitrary
+
+testBigEndianTxInPreservesOrder :: L.TxId -> L.TxIx -> L.TxIx -> Property
+testBigEndianTxInPreservesOrder txid txix1 txix2 =
+  let b1 = packByteString (BigEndianTxIn $ L.TxIn txid txix1)
+      b2 = packByteString (BigEndianTxIn $ L.TxIn txid txix2)
+   in counterexample (show b1 <> " " <> show b2) $ compare b1 b2 === compare txix1 txix2
+
+testBigEndianRoundtrips :: L.TxIn -> Property
+testBigEndianRoundtrips txin =
+  case unpack (pack txin) of
+    Left err -> counterexample ("unpack failed with error: " ++ show err) False
+    Right v -> v === txin
+
+testTxInPreservesOrder :: L.TxId -> L.TxIx -> L.TxIx -> Property
+testTxInPreservesOrder txid txix1 txix2 =
+  let b1 = packByteString (L.TxIn txid txix1)
+      b2 = packByteString (L.TxIn txid txix2)
+   in counterexample (show b1 <> " " <> show b2) $ compare b1 b2 === compare txix1 txix2
diff --git a/ouroboros-consensus-cardano/test/shelley-test/Test/ThreadNet/Shelley.hs b/ouroboros-consensus-cardano/test/shelley-test/Test/ThreadNet/Shelley.hs
index f3b75f4df..a795b2667 100644
--- a/ouroboros-consensus-cardano/test/shelley-test/Test/ThreadNet/Shelley.hs
+++ b/ouroboros-consensus-cardano/test/shelley-test/Test/ThreadNet/Shelley.hs
@@ -21,6 +21,7 @@ import qualified Cardano.Ledger.Shelley.Translation as SL
 import qualified Cardano.Protocol.TPraos.OCert as SL
 import Cardano.Slotting.EpochInfo (fixedEpochInfo)
 import Control.Monad (replicateM)
+import Control.Tracer (nullTracer)
 import qualified Data.Map.Strict as Map
 import Data.Word (Word64)
 import Lens.Micro ((^.))
@@ -296,7 +297,7 @@ prop_simple_real_tpraos_convergence
                               nextProtVer
                               sentinel -- Does not expire during test
                               setupD2
-                    , tniBlockForging = blockForging
+                    , tniBlockForging = blockForging nullTracer
                     }
           , mkRekeyM = Nothing
           }
diff --git a/ouroboros-consensus-diffusion/CHANGELOG.md b/ouroboros-consensus-diffusion/CHANGELOG.md
index b5462f1c9..8da7b7ed3 100644
--- a/ouroboros-consensus-diffusion/CHANGELOG.md
+++ b/ouroboros-consensus-diffusion/CHANGELOG.md
@@ -2,6 +2,23 @@
 
 # Changelog entries
 
+<a id='changelog-0.24.0.0'></a>
+## 0.24.0.0 -- 2025-09-29
+
+### Non-Breaking
+
+- Ensure that block forging threads finalize their keys when shutting down.
+- Adds a `kesAgentClientTracer` for tracing `KESAgentClientTrace` events
+
+### Breaking
+
+- `Ouroboros.Consensus.Network.NodeToNode.mkApps` takes `StdGen` as an argument, which is passed to `chain-sync` client.
+- `LowLevelRunNodeArgs` and `StdRunNodeArgs` were changed to match `ouroboros-network-0.22`
+- `NetworkP2PMode` was removed (non-p2p mode is removed from `ouroboros-network`).
+- `Ouroboros.Consensus.Node.stdRunDataDiffusion` was changed to match `Cardano.Network.Diffusion` API.
+
+- Added tracers `GsmEventInitializedInCaughtUp` and `GsmEventInitializedInPreSyncing` for the initial Genesis State Machine state.
+
 <a id='changelog-0.23.0.0'></a>
 ## 0.23.0.0 -- 2025-05-15
 
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250512_165249_alexander.esgen_genesis_caughtup_final_chainsel.md b/ouroboros-consensus-diffusion/changelog.d/20250512_165249_alexander.esgen_genesis_caughtup_final_chainsel.md
deleted file mode 100644
index 0a49bb7c8..000000000
--- a/ouroboros-consensus-diffusion/changelog.d/20250512_165249_alexander.esgen_genesis_caughtup_final_chainsel.md
+++ /dev/null
@@ -1,3 +0,0 @@
-<!--
-Testing changes only
--->
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250624_133331_javier.sagredo_remove_forkers_resource_reg.md b/ouroboros-consensus-diffusion/changelog.d/20250624_133331_javier.sagredo_remove_forkers_resource_reg.md
deleted file mode 100644
index b4c160d7c..000000000
--- a/ouroboros-consensus-diffusion/changelog.d/20250624_133331_javier.sagredo_remove_forkers_resource_reg.md
+++ /dev/null
@@ -1,24 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-<!--
-### Breaking
-
-- A bullet item for the Breaking category.
-
--->
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250728_115759_coot_cardano_diffusion_integration.md b/ouroboros-consensus-diffusion/changelog.d/20250728_115759_coot_cardano_diffusion_integration.md
deleted file mode 100644
index 991f95cdc..000000000
--- a/ouroboros-consensus-diffusion/changelog.d/20250728_115759_coot_cardano_diffusion_integration.md
+++ /dev/null
@@ -1,7 +0,0 @@
-### Breaking
-
-- `Ouroboros.Consensus.Network.NodeToNode.mkApps` takes `StdGen` as an argument, which is passed to `chain-sync` client.
-- `LowLevelRunNodeArgs` and `StdRunNodeArgs` were changed to match `ouroboros-network-0.22`
-- `NetworkP2PMode` was removed (non-p2p mode is removed from `ouroboros-network`).
-- `Ouroboros.Consensus.Node.stdRunDataDiffusion` was changed to match `Cardano.Network.Diffusion` API.
-
diff --git a/ouroboros-consensus/changelog.d/20250826_112148_javier.sagredo_reorg_ldb_constraints.md b/ouroboros-consensus-diffusion/changelog.d/20250729_125052_javier.sagredo_lsm1.md
similarity index 75%
rename from ouroboros-consensus/changelog.d/20250826_112148_javier.sagredo_reorg_ldb_constraints.md
rename to ouroboros-consensus-diffusion/changelog.d/20250729_125052_javier.sagredo_lsm1.md
index 337f401a3..147392cce 100644
--- a/ouroboros-consensus/changelog.d/20250826_112148_javier.sagredo_reorg_ldb_constraints.md
+++ b/ouroboros-consensus-diffusion/changelog.d/20250729_125052_javier.sagredo_lsm1.md
@@ -19,4 +19,5 @@ For top level release notes, leave all the headers commented out.
 -->
 ### Breaking
 
-- Delete `LedgerSupportsOnDiskLedgerDB` constraint and created `LedgerSupports(V1|V2)LedgerDB`.
+- `srnLdbFlavorArgs` was renamed to `srnLedgerDbBackendArgs` and changed its type to `LedgerDBBackendArgs`.
+
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250812_114557_alexander.esgen_gsm_init_state_tracer.md b/ouroboros-consensus-diffusion/changelog.d/20250812_114557_alexander.esgen_gsm_init_state_tracer.md
deleted file mode 100644
index 3eda0344f..000000000
--- a/ouroboros-consensus-diffusion/changelog.d/20250812_114557_alexander.esgen_gsm_init_state_tracer.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Breaking
-
-- Added tracers `GsmEventInitializedInCaughtUp` and `GsmEventInitializedInPreSyncing` for the initial Genesis State Machine state.
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250903_152809_coot_size_limits.md b/ouroboros-consensus-diffusion/changelog.d/20250903_152809_coot_size_limits.md
new file mode 100644
index 000000000..95c510fd7
--- /dev/null
+++ b/ouroboros-consensus-diffusion/changelog.d/20250903_152809_coot_size_limits.md
@@ -0,0 +1,5 @@
+### Patch
+
+- Added size limits for keep-alive server
+- Addes size limits for peer-sharing client & server
+
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250919_095435_thomas.bagrel_weighted_chain_selec.md b/ouroboros-consensus-diffusion/changelog.d/20250919_095435_thomas.bagrel_weighted_chain_selec.md
new file mode 100644
index 000000000..f9361ba9d
--- /dev/null
+++ b/ouroboros-consensus-diffusion/changelog.d/20250919_095435_thomas.bagrel_weighted_chain_selec.md
@@ -0,0 +1,3 @@
+### Breaking
+
+- In module `Ouroboros.Consensus.Node.GSM`, `GSMView` now has a monadic `getCandidateOverSelection :: STM m (selection -> chainSyncState -> CandidateVersusSelection)` instead of the previous pure `candidateOverSelection`. This is due to the fact that chain comparisons now depend on the set of Peras certificates (if Peras is enabled).
diff --git a/ouroboros-consensus-diffusion/changelog.d/20250919_095930_thomas.bagrel_object_diffusion.md b/ouroboros-consensus-diffusion/changelog.d/20250919_095930_thomas.bagrel_object_diffusion.md
new file mode 100644
index 000000000..fc67d834c
--- /dev/null
+++ b/ouroboros-consensus-diffusion/changelog.d/20250919_095930_thomas.bagrel_object_diffusion.md
@@ -0,0 +1,28 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Modify `Ouroboros.Consensus{.Node,.Node.Tracer,.Network.NodeToNode}` to wire-in PerasCertDiffusion similarly to other mini-protocols (e.g. TX-submission)
+- Propagate feature flags down to `NodeKernelArgs`
+
+### Non-Breaking
+
+- Update `Test.ThreadNet.Network` in `unstable-diffusion-testlib` accordingly to the changes made in `Ouroboros.Consensus.Network.NodeToNode`
diff --git a/ouroboros-consensus/changelog.d/20250822_162104_jasataco_forkers.md b/ouroboros-consensus-diffusion/changelog.d/20250919_101623_thomas.bagrel_hfc_era_peras.md
similarity index 74%
rename from ouroboros-consensus/changelog.d/20250822_162104_jasataco_forkers.md
rename to ouroboros-consensus-diffusion/changelog.d/20250919_101623_thomas.bagrel_hfc_era_peras.md
index 9ef23a6d1..18ef03093 100644
--- a/ouroboros-consensus/changelog.d/20250822_162104_jasataco_forkers.md
+++ b/ouroboros-consensus-diffusion/changelog.d/20250919_101623_thomas.bagrel_hfc_era_peras.md
@@ -14,7 +14,7 @@ For top level release notes, leave all the headers commented out.
 
 ### Non-Breaking
 
-- Ensure uncommitted forkers do not leak Ledger tables handles.
+- Update code using `EraParams` now that it has a new field `eraPerasRoundLength` for Byron and Shelley eras.
 
 <!--
 ### Breaking
diff --git a/ouroboros-consensus-cardano/changelog.d/20250811_072709_rukokarasu_get_filtered_vote_delegatees.md b/ouroboros-consensus-diffusion/changelog.d/20251010_121130_javier.sagredo_extract_2.md
similarity index 71%
rename from ouroboros-consensus-cardano/changelog.d/20250811_072709_rukokarasu_get_filtered_vote_delegatees.md
rename to ouroboros-consensus-diffusion/changelog.d/20251010_121130_javier.sagredo_extract_2.md
index 55af91fb2..04192cc01 100644
--- a/ouroboros-consensus-cardano/changelog.d/20250811_072709_rukokarasu_get_filtered_vote_delegatees.md
+++ b/ouroboros-consensus-diffusion/changelog.d/20251010_121130_javier.sagredo_extract_2.md
@@ -17,6 +17,7 @@ For top level release notes, leave all the headers commented out.
 - A bullet item for the Non-Breaking category.
 
 -->
+
 ### Breaking
 
-- Return full map instead of empty map from GetFilteredVoteDelegatees in the case where an empty set is passed.
+- Expect `srnLedgerDbBackendArgs :: LedgerDbBackendArgs m blk` as an argument, type which changed semantics in the abstract layer.
diff --git a/ouroboros-consensus/changelog.d/20250602_165308_jasataco_newer_ledger.md b/ouroboros-consensus-diffusion/changelog.d/20251024_123840_javier.sagredo_bangs.md
similarity index 81%
rename from ouroboros-consensus/changelog.d/20250602_165308_jasataco_newer_ledger.md
rename to ouroboros-consensus-diffusion/changelog.d/20251024_123840_javier.sagredo_bangs.md
index db8daf4f1..d7f9c3108 100644
--- a/ouroboros-consensus/changelog.d/20250602_165308_jasataco_newer_ledger.md
+++ b/ouroboros-consensus-diffusion/changelog.d/20251024_123840_javier.sagredo_bangs.md
@@ -7,7 +7,7 @@ For top level release notes, leave all the headers commented out.
 
 ### Patch
 
-- Fix serialization of `TriggerHardForkNotDuringThisExecution`.
+- Ensure the `ProtocolInfo` is garbage collected once we start Consensus.
 
 <!--
 ### Non-Breaking
diff --git a/ouroboros-consensus-diffusion/ouroboros-consensus-diffusion.cabal b/ouroboros-consensus-diffusion/ouroboros-consensus-diffusion.cabal
index 1ffccbe23..0caddc634 100644
--- a/ouroboros-consensus-diffusion/ouroboros-consensus-diffusion.cabal
+++ b/ouroboros-consensus-diffusion/ouroboros-consensus-diffusion.cabal
@@ -1,6 +1,6 @@
 cabal-version: 3.0
 name: ouroboros-consensus-diffusion
-version: 0.23.0.0
+version: 0.24.0.0
 synopsis: Integration for the Ouroboros Network layer
 description:
   Top level integration for consensus & network layers of the Ouroboros blockchain protocol.
@@ -77,6 +77,7 @@ library
   build-depends:
     base >=4.14 && <4.22,
     bytestring >=0.10 && <0.13,
+    cardano-base,
     cardano-slotting,
     cborg ^>=0.2.2,
     containers >=0.5 && <0.8,
@@ -88,7 +89,8 @@ library
     io-classes:{io-classes, si-timers, strict-stm} ^>=1.8,
     mtl,
     network-mux ^>=0.9,
-    ouroboros-consensus ^>=0.27,
+    ouroboros-consensus ^>=0.28,
+    ouroboros-consensus-protocol ^>=0.13,
     ouroboros-network:{cardano-diffusion, ouroboros-network} ^>=0.22.1,
     ouroboros-network-api ^>=0.16,
     ouroboros-network-framework ^>=0.19,
@@ -137,6 +139,7 @@ library unstable-diffusion-testlib
     mtl,
     ouroboros-consensus:{ouroboros-consensus, unstable-consensus-testlib},
     ouroboros-consensus-diffusion,
+    ouroboros-consensus-protocol,
     ouroboros-network,
     ouroboros-network-api,
     ouroboros-network-framework,
diff --git a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Network/NodeToNode.hs b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Network/NodeToNode.hs
index 85c4109a5..294aace61 100644
--- a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Network/NodeToNode.hs
+++ b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Network/NodeToNode.hs
@@ -54,6 +54,7 @@ import qualified Data.ByteString.Lazy as BSL
 import Data.Hashable (Hashable)
 import Data.Int (Int64)
 import Data.Map.Strict (Map)
+import qualified Data.Set as Set
 import Data.Void (Void)
 import qualified Network.Mux as Mux
 import Network.TypedProtocol.Codec
@@ -68,6 +69,10 @@ import Ouroboros.Consensus.MiniProtocol.ChainSync.Client
   )
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client as CsClient
 import Ouroboros.Consensus.MiniProtocol.ChainSync.Server
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Inbound (objectDiffusionInbound)
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.PerasCert
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Outbound (objectDiffusionOutbound)
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert
 import Ouroboros.Consensus.Node.ExitPolicy
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
 import Ouroboros.Consensus.Node.Run
@@ -81,10 +86,6 @@ import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.Orphans ()
 import Ouroboros.Network.Block
   ( Serialised (..)
-  , decodePoint
-  , decodeTip
-  , encodePoint
-  , encodeTip
   )
 import Ouroboros.Network.BlockFetch
 import Ouroboros.Network.BlockFetch.Client
@@ -124,6 +125,18 @@ import Ouroboros.Network.Protocol.KeepAlive.Client
 import Ouroboros.Network.Protocol.KeepAlive.Codec
 import Ouroboros.Network.Protocol.KeepAlive.Server
 import Ouroboros.Network.Protocol.KeepAlive.Type
+import Ouroboros.Network.Protocol.ObjectDiffusion.Codec
+  ( byteLimitsObjectDiffusion
+  , codecObjectDiffusion
+  , codecObjectDiffusionId
+  , timeLimitsObjectDiffusion
+  )
+import Ouroboros.Network.Protocol.ObjectDiffusion.Inbound
+  ( objectDiffusionInboundPeerPipelined
+  )
+import Ouroboros.Network.Protocol.ObjectDiffusion.Outbound
+  ( objectDiffusionOutboundPeer
+  )
 import Ouroboros.Network.Protocol.PeerSharing.Client
   ( PeerSharingClient
   , peerSharingClientPeer
@@ -197,6 +210,15 @@ data Handlers m addr blk = Handlers
       NodeToNodeVersion ->
       ConnectionId addr ->
       TxSubmissionServerPipelined (GenTxId blk) (GenTx blk) m ()
+  , hPerasCertDiffusionClient ::
+      NodeToNodeVersion ->
+      ControlMessageSTM m ->
+      ConnectionId addr ->
+      PerasCertDiffusionInboundPipelined blk m ()
+  , hPerasCertDiffusionServer ::
+      NodeToNodeVersion ->
+      ConnectionId addr ->
+      PerasCertDiffusionOutbound blk m ()
   , hKeepAliveClient ::
       NodeToNodeVersion ->
       ControlMessageSTM m ->
@@ -293,6 +315,22 @@ mkHandlers
             (mapTxSubmissionMempoolReader txForgetValidated $ getMempoolReader getMempool)
             (getMempoolWriter getMempool)
             version
+      , hPerasCertDiffusionClient = \version controlMessageSTM peer ->
+          objectDiffusionInbound
+            (contramap (TraceLabelPeer peer) (Node.perasCertDiffusionInboundTracer tracers))
+            ( perasCertDiffusionMaxFifoLength miniProtocolParameters
+            , 10 -- TODO: see https://github.com/tweag/cardano-peras/issues/97
+            , 10 -- TODO: see https://github.com/tweag/cardano-peras/issues/97
+            )
+            (makePerasCertPoolWriterFromChainDB $ getChainDB)
+            version
+            controlMessageSTM
+      , hPerasCertDiffusionServer = \version peer ->
+          objectDiffusionOutbound
+            (contramap (TraceLabelPeer peer) (Node.perasCertDiffusionOutboundTracer tracers))
+            (perasCertDiffusionMaxFifoLength miniProtocolParameters)
+            (makePerasCertPoolReaderFromChainDB $ getChainDB)
+            version
       , hKeepAliveClient = \_version -> keepAliveClient (Node.keepAliveClientTracer tracers) keepAliveRng
       , hKeepAliveServer = \_version _peer -> keepAliveServer
       , hPeerSharingClient = \_version controlMessageSTM _peer -> peerSharingClient controlMessageSTM
@@ -304,7 +342,7 @@ mkHandlers
 -------------------------------------------------------------------------------}
 
 -- | Node-to-node protocol codecs needed to run 'Handlers'.
-data Codecs blk addr e m bCS bSCS bBF bSBF bTX bKA bPS = Codecs
+data Codecs blk addr e m bCS bSCS bBF bSBF bTX bPCD bKA bPS = Codecs
   { cChainSyncCodec :: Codec (ChainSync (Header blk) (Point blk) (Tip blk)) e m bCS
   , cChainSyncCodecSerialised ::
       Codec (ChainSync (SerialisedHeader blk) (Point blk) (Tip blk)) e m bSCS
@@ -312,6 +350,7 @@ data Codecs blk addr e m bCS bSCS bBF bSBF bTX bKA bPS = Codecs
   , cBlockFetchCodecSerialised ::
       Codec (BlockFetch (Serialised blk) (Point blk)) e m bSBF
   , cTxSubmission2Codec :: Codec (TxSubmission2 (GenTxId blk) (GenTx blk)) e m bTX
+  , cPerasCertDiffusionCodec :: Codec (PerasCertDiffusion blk) e m bPCD
   , cKeepAliveCodec :: Codec KeepAlive e m bKA
   , cPeerSharingCodec :: Codec (PeerSharing addr) e m bPS
   }
@@ -339,49 +378,53 @@ defaultCodecs ::
     ByteString
     ByteString
     ByteString
+    ByteString
 defaultCodecs ccfg version encAddr decAddr nodeToNodeVersion =
   Codecs
     { cChainSyncCodec =
         codecChainSync
           enc
           dec
-          (encodePoint (encodeRawHash p))
-          (decodePoint (decodeRawHash p))
-          (encodeTip (encodeRawHash p))
-          (decodeTip (decodeRawHash p))
+          enc
+          dec
+          enc
+          dec
     , cChainSyncCodecSerialised =
         codecChainSync
           enc
           dec
-          (encodePoint (encodeRawHash p))
-          (decodePoint (decodeRawHash p))
-          (encodeTip (encodeRawHash p))
-          (decodeTip (decodeRawHash p))
+          enc
+          dec
+          enc
+          dec
     , cBlockFetchCodec =
         codecBlockFetch
           enc
           dec
-          (encodePoint (encodeRawHash p))
-          (decodePoint (decodeRawHash p))
+          enc
+          dec
     , cBlockFetchCodecSerialised =
         codecBlockFetch
           enc
           dec
-          (encodePoint (encodeRawHash p))
-          (decodePoint (decodeRawHash p))
+          enc
+          dec
     , cTxSubmission2Codec =
         codecTxSubmission2
           enc
           dec
           enc
           dec
+    , cPerasCertDiffusionCodec =
+        codecObjectDiffusion
+          enc
+          dec
+          enc
+          dec
     , cKeepAliveCodec = codecKeepAlive_v2
     , cPeerSharingCodec = codecPeerSharing (encAddr nodeToNodeVersion) (decAddr nodeToNodeVersion)
     }
  where
-  p :: Proxy blk
-  p = Proxy
-
   enc :: SerialiseNodeToNode blk a => a -> Encoding
   enc = encodeNodeToNode ccfg version
 
@@ -401,6 +444,7 @@ identityCodecs ::
     (AnyMessage (BlockFetch blk (Point blk)))
     (AnyMessage (BlockFetch (Serialised blk) (Point blk)))
     (AnyMessage (TxSubmission2 (GenTxId blk) (GenTx blk)))
+    (AnyMessage (PerasCertDiffusion blk))
     (AnyMessage KeepAlive)
     (AnyMessage (PeerSharing addr))
 identityCodecs =
@@ -410,6 +454,7 @@ identityCodecs =
     , cBlockFetchCodec = codecBlockFetchId
     , cBlockFetchCodecSerialised = codecBlockFetchId
     , cTxSubmission2Codec = codecTxSubmission2Id
+    , cPerasCertDiffusionCodec = codecObjectDiffusionId
     , cKeepAliveCodec = codecKeepAliveId
     , cPeerSharingCodec = codecPeerSharingId
     }
@@ -432,6 +477,7 @@ data Tracers' peer ntnAddr blk e f = Tracers
       f (TraceLabelPeer peer (TraceSendRecv (BlockFetch (Serialised blk) (Point blk))))
   , tTxSubmission2Tracer ::
       f (TraceLabelPeer peer (TraceSendRecv (TxSubmission2 (GenTxId blk) (GenTx blk))))
+  , tPerasCertDiffusionTracer :: f (TraceLabelPeer peer (TraceSendRecv (PerasCertDiffusion blk)))
   , tKeepAliveTracer :: f (TraceLabelPeer peer (TraceSendRecv KeepAlive))
   , tPeerSharingTracer :: f (TraceLabelPeer peer (TraceSendRecv (PeerSharing ntnAddr)))
   }
@@ -444,6 +490,7 @@ instance (forall a. Semigroup (f a)) => Semigroup (Tracers' peer ntnAddr blk e f
       , tBlockFetchTracer = f tBlockFetchTracer
       , tBlockFetchSerialisedTracer = f tBlockFetchSerialisedTracer
       , tTxSubmission2Tracer = f tTxSubmission2Tracer
+      , tPerasCertDiffusionTracer = f tPerasCertDiffusionTracer
       , tKeepAliveTracer = f tKeepAliveTracer
       , tPeerSharingTracer = f tPeerSharingTracer
       }
@@ -464,6 +511,7 @@ nullTracers =
     , tBlockFetchTracer = nullTracer
     , tBlockFetchSerialisedTracer = nullTracer
     , tTxSubmission2Tracer = nullTracer
+    , tPerasCertDiffusionTracer = nullTracer
     , tKeepAliveTracer = nullTracer
     , tPeerSharingTracer = nullTracer
     }
@@ -485,6 +533,7 @@ showTracers tr =
     , tBlockFetchTracer = showTracing tr
     , tBlockFetchSerialisedTracer = showTracing tr
     , tTxSubmission2Tracer = showTracing tr
+    , tPerasCertDiffusionTracer = showTracing tr
     , tKeepAliveTracer = showTracing tr
     , tPeerSharingTracer = showTracing tr
     }
@@ -509,7 +558,7 @@ type ServerApp m addr bytes a =
 -- | Applications for the node-to-node protocols
 --
 -- See 'Network.Mux.Types.MuxApplication'
-data Apps m addr bCS bBF bTX bKA bPS a b = Apps
+data Apps m addr bCS bBF bTX bPCD bKA bPS a b = Apps
   { aChainSyncClient :: ClientApp m addr bCS a
   -- ^ Start a chain sync client that communicates with the given upstream
   -- node.
@@ -525,6 +574,10 @@ data Apps m addr bCS bBF bTX bKA bPS a b = Apps
   -- given upstream node.
   , aTxSubmission2Server :: ServerApp m addr bTX b
   -- ^ Start a transaction submission v2 server.
+  , aPerasCertDiffusionClient :: ClientApp m addr bPCD a
+  -- ^ Start a Peras cert diffusion client.
+  , aPerasCertDiffusionServer :: ServerApp m addr bPCD b
+  -- ^ Start a Peras cert diffusion server.
   , aKeepAliveClient :: ClientApp m addr bKA a
   -- ^ Start a keep-alive client.
   , aKeepAliveServer :: ServerApp m addr bKA b
@@ -540,7 +593,7 @@ data Apps m addr bCS bBF bTX bKA bPS a b = Apps
 --
 -- They don't depend on the instantiation of the protocol parameters (which
 -- block type is used, etc.), hence the use of 'RankNTypes'.
-data ByteLimits bCS bBF bTX bKA = ByteLimits
+data ByteLimits bCS bBF bTX bPCD bKA bPS = ByteLimits
   { blChainSync ::
       forall header point tip.
       ProtocolSizeLimits
@@ -556,28 +609,42 @@ data ByteLimits bCS bBF bTX bKA = ByteLimits
       ProtocolSizeLimits
         (TxSubmission2 txid tx)
         bTX
+  , blPerasCertDiffusion ::
+      forall blk.
+      ProtocolSizeLimits
+        (PerasCertDiffusion blk)
+        bPCD
   , blKeepAlive ::
       ProtocolSizeLimits
         KeepAlive
         bKA
+  , blPeerSharing ::
+      forall addr.
+      ProtocolSizeLimits
+        (PeerSharing addr)
+        bPS
   }
 
-noByteLimits :: ByteLimits bCS bBF bTX bKA
+noByteLimits :: ByteLimits bCS bBF bTX bPCD bKA bPS
 noByteLimits =
   ByteLimits
     { blChainSync = byteLimitsChainSync (const 0)
     , blBlockFetch = byteLimitsBlockFetch (const 0)
     , blTxSubmission2 = byteLimitsTxSubmission2 (const 0)
+    , blPerasCertDiffusion = byteLimitsObjectDiffusion (const 0)
     , blKeepAlive = byteLimitsKeepAlive (const 0)
+    , blPeerSharing = byteLimitsPeerSharing (const 0)
     }
 
-byteLimits :: ByteLimits ByteString ByteString ByteString ByteString
+byteLimits :: ByteLimits ByteString ByteString ByteString ByteString ByteString ByteString
 byteLimits =
   ByteLimits
     { blChainSync = byteLimitsChainSync size
     , blBlockFetch = byteLimitsBlockFetch size
     , blTxSubmission2 = byteLimitsTxSubmission2 size
+    , blPerasCertDiffusion = byteLimitsObjectDiffusion size
     , blKeepAlive = byteLimitsKeepAlive size
+    , blPeerSharing = byteLimitsPeerSharing size
     }
  where
   size :: ByteString -> Word
@@ -587,7 +654,7 @@ byteLimits =
 
 -- | Construct the 'NetworkApplication' for the node-to-node protocols
 mkApps ::
-  forall m addrNTN addrNTC blk e bCS bBF bTX bKA bPS.
+  forall m addrNTN addrNTC blk e bCS bBF bTX bPCD bKA bPS.
   ( IOLike m
   , MonadTimer m
   , Ord addrNTN
@@ -602,8 +669,8 @@ mkApps ::
   NodeKernel m addrNTN addrNTC blk ->
   StdGen ->
   Tracers m addrNTN blk e ->
-  (NodeToNodeVersion -> Codecs blk addrNTN e m bCS bCS bBF bBF bTX bKA bPS) ->
-  ByteLimits bCS bBF bTX bKA ->
+  (NodeToNodeVersion -> Codecs blk addrNTN e m bCS bCS bBF bBF bTX bPCD bKA bPS) ->
+  ByteLimits bCS bBF bTX bPCD bKA bPS ->
   -- Chain-Sync timeouts for chain-sync client (using `Header blk`) as well as
   -- the server (`SerialisedHeader blk`).
   (forall header. ProtocolTimeLimitsWithRnd (ChainSync header (Point blk) (Tip blk))) ->
@@ -611,7 +678,7 @@ mkApps ::
   CsClient.CSJConfig ->
   ReportPeerMetrics m (ConnectionId addrNTN) ->
   Handlers m addrNTN blk ->
-  Apps m addrNTN bCS bBF bTX bKA bPS NodeToNodeInitiatorResult ()
+  Apps m addrNTN bCS bBF bTX bPCD bKA bPS NodeToNodeInitiatorResult ()
 mkApps kernel rng Tracers{..} mkCodecs ByteLimits{..} chainSyncTimeouts lopBucketConfig csjConfig ReportPeerMetrics{..} Handlers{..} =
   Apps{..}
  where
@@ -790,6 +857,51 @@ mkApps kernel rng Tracers{..} mkCodecs ByteLimits{..} chainSyncTimeouts lopBucke
       channel
       (txSubmissionServerPeerPipelined (hTxSubmissionServer version them))
 
+  aPerasCertDiffusionClient ::
+    NodeToNodeVersion ->
+    ExpandedInitiatorContext addrNTN m ->
+    Channel m bPCD ->
+    m (NodeToNodeInitiatorResult, Maybe bPCD)
+  aPerasCertDiffusionClient
+    version
+    ExpandedInitiatorContext
+      { eicConnectionId = them
+      , eicControlMessage = controlMessageSTM
+      }
+    channel = do
+      labelThisThread "PerasCertDiffusionClient"
+      ((), trailing) <-
+        runPipelinedPeerWithLimits
+          (TraceLabelPeer them `contramap` tPerasCertDiffusionTracer)
+          (cPerasCertDiffusionCodec (mkCodecs version))
+          blPerasCertDiffusion
+          timeLimitsObjectDiffusion
+          channel
+          ( objectDiffusionInboundPeerPipelined
+              (hPerasCertDiffusionClient version controlMessageSTM them)
+          )
+      return (NoInitiatorResult, trailing)
+
+  aPerasCertDiffusionServer ::
+    NodeToNodeVersion ->
+    ResponderContext addrNTN ->
+    Channel m bPCD ->
+    m ((), Maybe bPCD)
+  aPerasCertDiffusionServer
+    version
+    ResponderContext{rcConnectionId = them}
+    channel = do
+      labelThisThread "PerasCertDiffusionServer"
+      runPeerWithLimits
+        (TraceLabelPeer them `contramap` tPerasCertDiffusionTracer)
+        (cPerasCertDiffusionCodec (mkCodecs version))
+        blPerasCertDiffusion
+        timeLimitsObjectDiffusion
+        channel
+        ( objectDiffusionOutboundPeer
+            (hPerasCertDiffusionServer version them)
+        )
+
   aKeepAliveClient ::
     NodeToNodeVersion ->
     ExpandedInitiatorContext addrNTN m ->
@@ -831,7 +943,7 @@ mkApps kernel rng Tracers{..} mkCodecs ByteLimits{..} chainSyncTimeouts lopBucke
     runPeerWithLimits
       (TraceLabelPeer them `contramap` tKeepAliveTracer)
       (cKeepAliveCodec (mkCodecs version))
-      (byteLimitsKeepAlive (const 0)) -- TODO: Real Bytelimits, see #1727
+      blKeepAlive
       timeLimitsKeepAlive
       channel
       $ keepAliveServerPeer
@@ -857,7 +969,7 @@ mkApps kernel rng Tracers{..} mkCodecs ByteLimits{..} chainSyncTimeouts lopBucke
             runPeerWithLimits
               (TraceLabelPeer them `contramap` tPeerSharingTracer)
               (cPeerSharingCodec (mkCodecs version))
-              (byteLimitsPeerSharing (const 0))
+              blPeerSharing
               timeLimitsPeerSharing
               channel
               (peerSharingClientPeer psClient)
@@ -873,7 +985,7 @@ mkApps kernel rng Tracers{..} mkCodecs ByteLimits{..} chainSyncTimeouts lopBucke
     runPeerWithLimits
       (TraceLabelPeer them `contramap` tPeerSharingTracer)
       (cPeerSharingCodec (mkCodecs version))
-      (byteLimitsPeerSharing (const 0))
+      blPeerSharing
       timeLimitsPeerSharing
       channel
       $ peerSharingServerPeer
@@ -893,10 +1005,11 @@ initiator ::
   MiniProtocolParameters ->
   NodeToNodeVersion ->
   NodeToNodeVersionData ->
-  Apps m addr b b b b b a c ->
+  Apps m addr b b b b b b a c ->
   OuroborosBundleWithExpandedCtx 'Mux.InitiatorMode addr b m a Void
 initiator miniProtocolParameters version versionData Apps{..} =
   nodeToNodeProtocols
+    Set.empty -- TODO: change for a meaningful value
     miniProtocolParameters
     -- TODO: currently consensus is using 'ConnectionId' for its 'peer' type.
     -- This is currently ok, as we might accept multiple connections from the
@@ -911,6 +1024,9 @@ initiator miniProtocolParameters version versionData Apps{..} =
             (InitiatorProtocolOnly (MiniProtocolCb (\ctx -> aBlockFetchClient version ctx)))
         , txSubmissionProtocol =
             (InitiatorProtocolOnly (MiniProtocolCb (\ctx -> aTxSubmission2Client version ctx)))
+        , perasCertDiffusionProtocol =
+            (InitiatorProtocolOnly (MiniProtocolCb (\ctx -> aPerasCertDiffusionClient version ctx)))
+        , perasVoteDiffusionProtocol = error "perasVoteDiffusionProtocol not implemented"
         , keepAliveProtocol =
             (InitiatorProtocolOnly (MiniProtocolCb (\ctx -> aKeepAliveClient version ctx)))
         , peerSharingProtocol =
@@ -929,10 +1045,11 @@ initiatorAndResponder ::
   MiniProtocolParameters ->
   NodeToNodeVersion ->
   NodeToNodeVersionData ->
-  Apps m addr b b b b b a c ->
+  Apps m addr b b b b b b a c ->
   OuroborosBundleWithExpandedCtx 'Mux.InitiatorResponderMode addr b m a c
 initiatorAndResponder miniProtocolParameters version versionData Apps{..} =
   nodeToNodeProtocols
+    Set.empty -- TODO: change for a meaningful value
     miniProtocolParameters
     ( NodeToNodeProtocols
         { chainSyncProtocol =
@@ -950,6 +1067,12 @@ initiatorAndResponder miniProtocolParameters version versionData Apps{..} =
                 (MiniProtocolCb (\initiatorCtx -> aTxSubmission2Client version initiatorCtx))
                 (MiniProtocolCb (\responderCtx -> aTxSubmission2Server version responderCtx))
             )
+        , perasCertDiffusionProtocol =
+            ( InitiatorAndResponderProtocol
+                (MiniProtocolCb (\initiatorCtx -> aPerasCertDiffusionClient version initiatorCtx))
+                (MiniProtocolCb (\responderCtx -> aPerasCertDiffusionServer version responderCtx))
+            )
+        , perasVoteDiffusionProtocol = error "perasVoteDiffusionProtocol not implemented"
         , keepAliveProtocol =
             ( InitiatorAndResponderProtocol
                 (MiniProtocolCb (\initiatorCtx -> aKeepAliveClient version initiatorCtx))
diff --git a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node.hs b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node.hs
index 7c0535c1b..fd009ec4b 100644
--- a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node.hs
+++ b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE BangPatterns #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DuplicateRecordFields #-}
@@ -60,6 +61,7 @@ module Ouroboros.Consensus.Node
   , openChainDB
   ) where
 
+import Cardano.Base.FeatureFlags (CardanoFeatureFlag)
 import qualified Cardano.Network.Diffusion as Cardano.Diffusion
 import Cardano.Network.Diffusion.Configuration (ChainSyncIdleTimeout (..))
 import qualified Cardano.Network.Diffusion.Policies as Cardano.Diffusion
@@ -84,6 +86,7 @@ import Data.Kind (Type)
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
 import Data.Maybe (fromMaybe, isNothing)
+import Data.Set (Set)
 import Data.Time (NominalDiffTime)
 import Data.Typeable (Typeable)
 import Ouroboros.Consensus.Block
@@ -232,6 +235,8 @@ data RunNodeArgs m addrNTN addrNTC blk = RunNodeArgs
   -- ^ Network PeerSharing miniprotocol willingness flag
   , rnGetUseBootstrapPeers :: STM m UseBootstrapPeers
   , rnGenesisConfig :: GenesisConfig
+  , rnFeatureFlags :: Set CardanoFeatureFlag
+  -- ^ Enabled experimental features
   }
 
 -- | Arguments that usually only tests /directly/ specify.
@@ -317,8 +322,10 @@ data LowLevelRunNodeArgs m addrNTN addrNTC blk
   , llrnMaxClockSkew :: InFutureCheck.ClockSkew
   -- ^ Maximum clock skew
   , llrnPublicPeerSelectionStateVar :: StrictSTM.StrictTVar m (PublicPeerSelectionState addrNTN)
-  , llrnLdbFlavorArgs :: Complete LedgerDbFlavorArgs m
+  , llrnLdbFlavorArgs :: LedgerDbBackendArgs m blk
   -- ^ The flavor arguments
+  , llrnFeatureFlags :: Set CardanoFeatureFlag
+  -- ^ Enabled experimental features
   }
 
 data NodeDatabasePaths
@@ -375,7 +382,7 @@ data
   , -- Ad hoc values to replace default ChainDB configurations
     srnSnapshotPolicyArgs :: SnapshotPolicyArgs
   , srnQueryBatchSize :: QueryBatchSize
-  , srnLdbFlavorArgs :: Complete LedgerDbFlavorArgs m
+  , srnLedgerDbBackendArgs :: LedgerDbBackendArgs m blk
   }
 
 {-------------------------------------------------------------------------------
@@ -570,6 +577,7 @@ runWith RunNodeArgs{..} encAddrNtN decAddrNtN LowLevelRunNodeArgs{..} =
                   gsmAntiThunderingHerd
                   keepAliveRng
                   cfg
+                  llrnFeatureFlags
                   rnTraceConsensus
                   btime
                   (InFutureCheck.realHeaderInFutureCheck llrnMaxClockSkew systemTime)
@@ -632,7 +640,7 @@ runWith RunNodeArgs{..} encAddrNtN decAddrNtN LowLevelRunNodeArgs{..} =
     } = rnProtocolInfo
 
   codecConfig :: CodecConfig blk
-  codecConfig = configCodec cfg
+  !codecConfig = configCodec cfg
 
   mkNodeToNodeApps ::
     NodeKernelArgs m addrNTN (ConnectionId addrNTC) blk ->
@@ -649,6 +657,7 @@ runWith RunNodeArgs{..} encAddrNtN decAddrNtN LowLevelRunNodeArgs{..} =
       ByteString
       ByteString
       ByteString
+      ByteString
       NodeToNodeInitiatorResult
       ()
   mkNodeToNodeApps nodeKernelArgs nodeKernel peerMetrics encAddrNTN decAddrNTN version =
@@ -690,6 +699,7 @@ runWith RunNodeArgs{..} encAddrNtN decAddrNtN LowLevelRunNodeArgs{..} =
         ByteString
         ByteString
         ByteString
+        ByteString
         NodeToNodeInitiatorResult
         ()
     ) ->
@@ -816,7 +826,7 @@ openChainDB ::
   (ChainDB.RelativeMountPoint -> SomeHasFS m) ->
   -- | Volatile FS, see 'NodeDatabasePaths'
   (ChainDB.RelativeMountPoint -> SomeHasFS m) ->
-  Complete LedgerDbFlavorArgs m ->
+  LedgerDbBackendArgs m blk ->
   -- | A set of default arguments (possibly modified from 'defaultArgs')
   Incomplete ChainDbArgs m blk ->
   -- | Customise the 'ChainDbArgs'
@@ -845,6 +855,7 @@ mkNodeKernelArgs ::
   StdGen ->
   StdGen ->
   TopLevelConfig blk ->
+  Set CardanoFeatureFlag ->
   Tracers m (ConnectionId addrNTN) (ConnectionId addrNTC) blk ->
   BlockchainTime m ->
   InFutureCheck.SomeHeaderInFutureCheck m blk ->
@@ -864,6 +875,7 @@ mkNodeKernelArgs
   gsmAntiThunderingHerd
   rng
   cfg
+  featureFlags
   tracers
   btime
   chainSyncFutureCheck
@@ -883,6 +895,7 @@ mkNodeKernelArgs
           { tracers
           , registry
           , cfg
+          , featureFlags
           , btime
           , chainDB
           , initChainDB = nodeInitChainDB
@@ -1001,6 +1014,7 @@ stdLowLevelRunNodeArgsIO
     { rnProtocolInfo
     , rnPeerSharing
     , rnGenesisConfig
+    , rnFeatureFlags
     }
   $(SafeWildCards.fields 'StdRunNodeArgs) = do
     llrnBfcSalt <- stdBfcSaltIO
@@ -1049,8 +1063,9 @@ stdLowLevelRunNodeArgsIO
             InFutureCheck.defaultClockSkew
         , llrnPublicPeerSelectionStateVar =
             Diffusion.dcPublicPeerSelectionVar srnDiffusionConfiguration
-        , llrnLdbFlavorArgs =
-            srnLdbFlavorArgs
+        , llrnLdbFlavorArgs = srnLedgerDbBackendArgs
+        , llrnFeatureFlags =
+            rnFeatureFlags
         }
    where
     networkMagic :: NetworkMagic
diff --git a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/GSM.hs b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/GSM.hs
index aa9733d36..780602118 100644
--- a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/GSM.hs
+++ b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/GSM.hs
@@ -104,10 +104,16 @@ data GsmView m upstreamPeer selection chainSyncState = GsmView
   -- thundering herd phenomenon.
   --
   -- 'Nothing' should only be used for testing.
-  , candidateOverSelection ::
-      selection ->
-      chainSyncState ->
-      CandidateVersusSelection
+  , getCandidateOverSelection ::
+      STM
+        m
+        ( selection ->
+          chainSyncState ->
+          CandidateVersusSelection
+        )
+  -- ^ Whether the candidate from the @chainSyncState@ is preferable to the
+  -- selection. This can depend on external state (Peras certificates boosting
+  -- blocks).
   , peerIsIdle :: chainSyncState -> Bool
   , durationUntilTooOld :: Maybe (selection -> m DurationFromNow)
   -- ^ How long from now until the selection will be so old that the node
@@ -234,7 +240,7 @@ realGsmEntryPoints tracerArgs gsmView =
 
   GsmView
     { antiThunderingHerd
-    , candidateOverSelection
+    , getCandidateOverSelection
     , peerIsIdle
     , durationUntilTooOld
     , equivalent
@@ -383,6 +389,7 @@ realGsmEntryPoints tracerArgs gsmView =
     -- long.
     selection <- getCurrentSelection
     candidates <- traverse StrictSTM.readTVar varsState
+    candidateOverSelection <- getCandidateOverSelection
     let ok candidate =
           WhetherCandidateIsBetter False
             == candidateOverSelection selection candidate
diff --git a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/Tracers.hs b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/Tracers.hs
index 24b82c331..4b8627dbd 100644
--- a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/Tracers.hs
+++ b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/Node/Tracers.hs
@@ -42,7 +42,11 @@ import Ouroboros.Consensus.MiniProtocol.ChainSync.Server
 import Ouroboros.Consensus.MiniProtocol.LocalTxSubmission.Server
   ( TraceLocalTxSubmissionServerEvent (..)
   )
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert
 import Ouroboros.Consensus.Node.GSM (TraceGsmEvent)
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( KESAgentClientTrace (..)
+  )
 import Ouroboros.Network.Block (Tip)
 import Ouroboros.Network.BlockFetch
   ( TraceFetchClientState
@@ -76,6 +80,10 @@ data Tracers' remotePeer localPeer blk f = Tracers
       f (TraceLabelPeer remotePeer (TraceTxSubmissionOutbound (GenTxId blk) (GenTx blk)))
   , localTxSubmissionServerTracer :: f (TraceLocalTxSubmissionServerEvent blk)
   , mempoolTracer :: f (TraceEventMempool blk)
+  , perasCertDiffusionInboundTracer ::
+      f (TraceLabelPeer remotePeer (TracePerasCertDiffusionInbound blk))
+  , perasCertDiffusionOutboundTracer ::
+      f (TraceLabelPeer remotePeer (TracePerasCertDiffusionOutbound blk))
   , forgeTracer :: f (TraceLabelCreds (TraceForgeEvent blk))
   , blockchainTimeTracer :: f (TraceBlockchainTimeEvent UTCTime)
   , forgeStateInfoTracer :: f (TraceLabelCreds (ForgeStateInfo blk))
@@ -87,6 +95,7 @@ data Tracers' remotePeer localPeer blk f = Tracers
   , csjTracer ::
       f (TraceLabelPeer remotePeer (CSJumping.TraceEventCsj remotePeer blk))
   , dbfTracer :: f (CSJumping.TraceEventDbf remotePeer)
+  , kesAgentTracer :: f KESAgentClientTrace
   }
 
 instance
@@ -105,6 +114,8 @@ instance
       , txOutboundTracer = f txOutboundTracer
       , localTxSubmissionServerTracer = f localTxSubmissionServerTracer
       , mempoolTracer = f mempoolTracer
+      , perasCertDiffusionInboundTracer = f perasCertDiffusionInboundTracer
+      , perasCertDiffusionOutboundTracer = f perasCertDiffusionOutboundTracer
       , forgeTracer = f forgeTracer
       , blockchainTimeTracer = f blockchainTimeTracer
       , forgeStateInfoTracer = f forgeStateInfoTracer
@@ -115,6 +126,7 @@ instance
       , gddTracer = f gddTracer
       , csjTracer = f csjTracer
       , dbfTracer = f dbfTracer
+      , kesAgentTracer = f kesAgentTracer
       }
    where
     f ::
@@ -141,6 +153,8 @@ nullTracers =
     , txOutboundTracer = nullTracer
     , localTxSubmissionServerTracer = nullTracer
     , mempoolTracer = nullTracer
+    , perasCertDiffusionInboundTracer = nullTracer
+    , perasCertDiffusionOutboundTracer = nullTracer
     , forgeTracer = nullTracer
     , blockchainTimeTracer = nullTracer
     , forgeStateInfoTracer = nullTracer
@@ -151,6 +165,7 @@ nullTracers =
     , gddTracer = nullTracer
     , csjTracer = nullTracer
     , dbfTracer = nullTracer
+    , kesAgentTracer = nullTracer
     }
 
 showTracers ::
@@ -179,6 +194,8 @@ showTracers tr =
     , txOutboundTracer = showTracing tr
     , localTxSubmissionServerTracer = showTracing tr
     , mempoolTracer = showTracing tr
+    , perasCertDiffusionInboundTracer = showTracing tr
+    , perasCertDiffusionOutboundTracer = showTracing tr
     , forgeTracer = showTracing tr
     , blockchainTimeTracer = showTracing tr
     , forgeStateInfoTracer = showTracing tr
@@ -189,6 +206,7 @@ showTracers tr =
     , gddTracer = showTracing tr
     , csjTracer = showTracing tr
     , dbfTracer = showTracing tr
+    , kesAgentTracer = showTracing tr
     }
 
 {-------------------------------------------------------------------------------
diff --git a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/NodeKernel.hs b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/NodeKernel.hs
index b9c53da49..36ba2cbcf 100644
--- a/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/NodeKernel.hs
+++ b/ouroboros-consensus-diffusion/src/ouroboros-consensus-diffusion/Ouroboros/Consensus/NodeKernel.hs
@@ -27,6 +27,7 @@ module Ouroboros.Consensus.NodeKernel
   , toConsensusMode
   ) where
 
+import Cardano.Base.FeatureFlags (CardanoFeatureFlag)
 import Cardano.Network.ConsensusMode (ConsensusMode (..))
 import Cardano.Network.PeerSelection.Bootstrap (UseBootstrapPeers)
 import Cardano.Network.PeerSelection.LocalRootPeers
@@ -51,6 +52,7 @@ import Data.List.NonEmpty (NonEmpty)
 import qualified Data.List.NonEmpty as NE
 import Data.Maybe (isJust, mapMaybe)
 import Data.Proxy
+import Data.Set (Set)
 import qualified Data.Text as Text
 import Data.Void (Void)
 import Ouroboros.Consensus.Block hiding (blockMatchesHeader)
@@ -178,7 +180,7 @@ data NodeKernel m addrNTN addrNTC blk = NodeKernel
   -- the PeerSharing protocol
   , getTracers :: Tracers m (ConnectionId addrNTN) addrNTC blk
   -- ^ The node's tracers
-  , setBlockForging :: [BlockForging m blk] -> m ()
+  , setBlockForging :: [MkBlockForging m blk] -> m ()
   -- ^ Set block forging
   --
   -- When set with the empty list '[]' block forging will be disabled.
@@ -195,6 +197,7 @@ data NodeKernelArgs m addrNTN addrNTC blk = NodeKernelArgs
   { tracers :: Tracers m (ConnectionId addrNTN) addrNTC blk
   , registry :: ResourceRegistry m
   , cfg :: TopLevelConfig blk
+  , featureFlags :: Set CardanoFeatureFlag
   , btime :: BlockchainTime m
   , chainDB :: ChainDB m blk
   , initChainDB :: StorageConfig blk -> InitChainDB m blk -> m ()
@@ -244,7 +247,7 @@ initNodeKernel
     , getDiffusionPipeliningSupport
     } = do
     -- using a lazy 'TVar', 'BlockForging' does not have a 'NoThunks' instance.
-    blockForgingVar :: LazySTM.TMVar m [BlockForging m blk] <- LazySTM.newTMVarIO []
+    blockForgingVar :: LazySTM.TMVar m [MkBlockForging m blk] <- LazySTM.newTMVarIO []
     initChainDB (configStorage cfg) (InitChainDB.fromFull chainDB)
 
     st <- initInternalState args
@@ -271,15 +274,18 @@ initNodeKernel
               gsmTracerArgs
               GSM.GsmView
                 { GSM.antiThunderingHerd = Just gsmAntiThunderingHerd
-                , GSM.candidateOverSelection = \(headers, _lst) state ->
-                    case AF.intersectionPoint headers (csCandidate state) of
-                      Nothing -> GSM.CandidateDoesNotIntersect
-                      Just{} ->
-                        GSM.WhetherCandidateIsBetter $ -- precondition requires intersection
-                          preferAnchoredCandidate
-                            (configBlock cfg)
-                            headers
-                            (csCandidate state)
+                , GSM.getCandidateOverSelection = do
+                    weights <- ChainDB.getPerasWeightSnapshot chainDB
+                    pure $ \(headers, _lst) state ->
+                      case AF.intersectionPoint headers (csCandidate state) of
+                        Nothing -> GSM.CandidateDoesNotIntersect
+                        Just{} ->
+                          GSM.WhetherCandidateIsBetter $ -- precondition requires intersection
+                            preferAnchoredCandidate
+                              (configBlock cfg)
+                              (forgetFingerprint weights)
+                              headers
+                              (csCandidate state)
                 , GSM.peerIsIdle = csIdling
                 , GSM.durationUntilTooOld =
                     gsmDurationUntilTooOld
@@ -375,7 +381,7 @@ initNodeKernel
    where
     blockForgingController ::
       InternalState m remotePeer localPeer blk ->
-      STM m [BlockForging m blk] ->
+      STM m [MkBlockForging m blk] ->
       m Void
     blockForgingController st getBlockForging = go []
      where
@@ -390,7 +396,7 @@ castTraceFetchDecision ::
   forall remotePeer blk.
   TraceDecisionEvent remotePeer (HeaderWithTime blk) -> TraceDecisionEvent remotePeer (Header blk)
 castTraceFetchDecision = \case
-  PeersFetch xs -> PeersFetch (map (fmap (second (map castPoint))) xs) -- [TraceLabelPeer peer (FetchDecision [Point header])]
+  PeersFetch xs -> PeersFetch (map (fmap (second (map castPoint))) xs)
   PeerStarvedUs peer -> PeerStarvedUs peer
 
 castTraceFetchClientState ::
@@ -493,20 +499,29 @@ forkBlockForging ::
   forall m addrNTN addrNTC blk.
   (IOLike m, RunNode blk) =>
   InternalState m addrNTN addrNTC blk ->
-  BlockForging m blk ->
+  MkBlockForging m blk ->
   m (Thread m Void)
-forkBlockForging IS{..} blockForging =
-  forkLinkedWatcher registry label $
-    knownSlotWatcher btime $
-      \currentSlot -> withRegistry (\rr -> withEarlyExit_ $ go rr currentSlot)
+forkBlockForging IS{..} (MkBlockForging blockForgingM) =
+  forkLinkedWatcherAllocate
+    registry
+    label
+    blockForgingMLabel
+    finalize
+    ( \bf -> knownSlotWatcher btime $
+        \currentSlot -> withRegistry (\rr -> withEarlyExit_ $ go bf rr currentSlot)
+    )
  where
   label :: String
-  label =
-    "NodeKernel.blockForging." <> Text.unpack (forgeLabel blockForging)
+  label = "NodeKernel.blockForging"
 
-  go :: ResourceRegistry m -> SlotNo -> WithEarlyExit m ()
-  go reg currentSlot = do
-    trace $ TraceStartLeadershipCheck currentSlot
+  blockForgingMLabel = do
+    bf <- blockForgingM
+    labelThisThread $ Text.unpack $ forgeLabel bf
+    pure bf
+
+  go :: BlockForging m blk -> ResourceRegistry m -> SlotNo -> WithEarlyExit m ()
+  go blockForging reg currentSlot = do
+    trace blockForging $ TraceStartLeadershipCheck currentSlot
 
     -- Figure out which block to connect to
     --
@@ -521,10 +536,10 @@ forkBlockForging IS{..} blockForging =
       case eBlkCtx of
         Right blkCtx -> return blkCtx
         Left failure -> do
-          trace failure
+          trace blockForging failure
           exitEarly
 
-    trace $ TraceBlockContext currentSlot bcBlockNo bcPrevPoint
+    trace blockForging $ TraceBlockContext currentSlot bcBlockNo bcPrevPoint
 
     -- Get forker corresponding to bcPrevPoint
     --
@@ -536,13 +551,13 @@ forkBlockForging IS{..} blockForging =
     -- Remember to close this forker before exiting!
     forker <- case forkerEith of
       Left _ -> do
-        trace $ TraceNoLedgerState currentSlot bcPrevPoint
+        trace blockForging $ TraceNoLedgerState currentSlot bcPrevPoint
         exitEarly
       Right forker -> pure forker
 
     unticked <- lift $ atomically $ LedgerDB.roforkerGetLedgerState forker
 
-    trace $ TraceLedgerState currentSlot bcPrevPoint
+    trace blockForging $ TraceLedgerState currentSlot bcPrevPoint
 
     -- We require the ticked ledger view in order to construct the ticked
     -- 'ChainDepState'.
@@ -561,13 +576,13 @@ forkBlockForging IS{..} blockForging =
           -- the ticked ledger state). However, we probably don't /want/ to
           -- produce a block in this case; we are most likely missing a blocks
           -- on our chain.
-          trace $ TraceNoLedgerView currentSlot err
+          trace blockForging $ TraceNoLedgerView currentSlot err
           lift $ roforkerClose forker
           exitEarly
         Right lv ->
           return lv
 
-    trace $ TraceLedgerView currentSlot
+    trace blockForging $ TraceLedgerView currentSlot
 
     -- Tick the 'ChainDepState' for the 'SlotNo' we're producing a block for. We
     -- only need the ticked 'ChainDepState' to check the whether we're a leader.
@@ -595,21 +610,21 @@ forkBlockForging IS{..} blockForging =
             tickedChainDepState
       case shouldForge of
         ForgeStateUpdateError err -> do
-          trace $ TraceForgeStateUpdateError currentSlot err
+          trace blockForging $ TraceForgeStateUpdateError currentSlot err
           lift $ roforkerClose forker
           exitEarly
         CannotForge cannotForge -> do
-          trace $ TraceNodeCannotForge currentSlot cannotForge
+          trace blockForging $ TraceNodeCannotForge currentSlot cannotForge
           lift $ roforkerClose forker
           exitEarly
         NotLeader -> do
-          trace $ TraceNodeNotLeader currentSlot
+          trace blockForging $ TraceNodeNotLeader currentSlot
           lift $ roforkerClose forker
           exitEarly
         ShouldForge p -> return p
 
     -- At this point we have established that we are indeed slot leader
-    trace $ TraceNodeIsLeader currentSlot
+    trace blockForging $ TraceNodeIsLeader currentSlot
 
     -- Tick the ledger state for the 'SlotNo' we're producing a block for
     let tickedLedgerState :: Ticked (LedgerState blk) DiffMK
@@ -621,7 +636,7 @@ forkBlockForging IS{..} blockForging =
             (ledgerState unticked)
 
     _ <- evaluate tickedLedgerState
-    trace $ TraceForgeTickedLedgerState currentSlot bcPrevPoint
+    trace blockForging $ TraceForgeTickedLedgerState currentSlot bcPrevPoint
 
     -- Get a snapshot of the mempool that is consistent with the ledger
     --
@@ -656,7 +671,7 @@ forkBlockForging IS{..} blockForging =
     _ <- evaluate (length txs)
     _ <- evaluate mempoolHash
 
-    trace $ TraceForgingMempoolSnapshot currentSlot bcPrevPoint mempoolHash mempoolSlotNo
+    trace blockForging $ TraceForgingMempoolSnapshot currentSlot bcPrevPoint mempoolHash mempoolSlotNo
 
     -- Actually produce the block
     newBlock <-
@@ -670,7 +685,7 @@ forkBlockForging IS{..} blockForging =
           txs
           proof
 
-    trace $
+    trace blockForging $
       TraceForgedBlock
         currentSlot
         (ledgerTipPoint (ledgerState unticked))
@@ -700,9 +715,9 @@ forkBlockForging IS{..} blockForging =
                 <$> ChainDB.getIsInvalidBlock chainDB
         case isInvalid of
           Nothing ->
-            trace $ TraceDidntAdoptBlock currentSlot newBlock
+            trace blockForging $ TraceDidntAdoptBlock currentSlot newBlock
           Just reason -> do
-            trace $ TraceForgedInvalidBlock currentSlot newBlock reason
+            trace blockForging $ TraceForgedInvalidBlock currentSlot newBlock reason
             -- We just produced a block that is invalid according to the
             -- ledger in the ChainDB, while the mempool said it is valid.
             -- There is an inconsistency between the two!
@@ -726,10 +741,10 @@ forkBlockForging IS{..} blockForging =
       -- assert this here because the ability to extract transactions from a
       -- block, i.e., the @HasTxs@ class, is not implementable by all blocks,
       -- e.g., @DualBlock@.
-      trace $ TraceAdoptedBlock currentSlot newBlock txs
+      trace blockForging $ TraceAdoptedBlock currentSlot newBlock txs
 
-  trace :: TraceForgeEvent blk -> WithEarlyExit m ()
-  trace =
+  trace :: BlockForging m blk -> TraceForgeEvent blk -> WithEarlyExit m ()
+  trace blockForging =
     lift
       . traceWith (forgeTracer tracers)
       . TraceLabelCreds (forgeLabel blockForging)
diff --git a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/General.hs b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/General.hs
index cb2005189..afa90db0e 100644
--- a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/General.hs
+++ b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/General.hs
@@ -55,6 +55,7 @@ import Ouroboros.Consensus.Node.Run
 import Ouroboros.Consensus.NodeId
 import Ouroboros.Consensus.Protocol.Abstract (LedgerView)
 import Ouroboros.Consensus.Protocol.LeaderSchedule
+import Ouroboros.Consensus.Protocol.Praos.AgentClient (MonadKESAgent)
 import qualified Ouroboros.Consensus.Storage.ChainDB as ChainDB
 import Ouroboros.Consensus.TypeFamilyWrappers
 import Ouroboros.Consensus.Util.Condense
@@ -214,7 +215,7 @@ runTestNetwork ::
   ) =>
   TestConfig ->
   TestConfigB blk ->
-  (forall m. IOLike m => TestConfigMB m blk) ->
+  (forall m. (IOLike m, MonadKESAgent m) => TestConfigMB m blk) ->
   TestOutput blk
 runTestNetwork
   TestConfig
diff --git a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Network.hs b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Network.hs
index d34e717e7..6bd6d9bde 100644
--- a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Network.hs
+++ b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Network.hs
@@ -83,6 +83,7 @@ import Ouroboros.Consensus.Mempool
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client as CSClient
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client.HistoricityCheck as HistoricityCheck
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client.InFutureCheck as InFutureCheck
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert (PerasCertDiffusion)
 import qualified Ouroboros.Consensus.Network.NodeToNode as NTN
 import Ouroboros.Consensus.Node.ExitPolicy
 import qualified Ouroboros.Consensus.Node.GSM as GSM
@@ -123,8 +124,8 @@ import Ouroboros.Network.NodeToNode
   ( ConnectionId (..)
   , ExpandedInitiatorContext (..)
   , IsBigLedgerPeer (..)
-  , MiniProtocolParameters (..)
   , ResponderContext (..)
+  , defaultMiniProtocolParameters
   )
 import Ouroboros.Network.PeerSelection.Governor
   ( makePublicPeerSelectionStateVar
@@ -177,7 +178,7 @@ instance Show (ForgeEbbEnv blk) where
 type RekeyM m blk =
   CoreNodeId ->
   ProtocolInfo blk ->
-  m [BlockForging m blk] ->
+  m [MkBlockForging m blk] ->
   -- | The slot in which the node is rekeying
   SlotNo ->
   -- | Which epoch the slot is in
@@ -198,12 +199,12 @@ data TestNodeInitialization m blk = TestNodeInitialization
   -- that determines which transactions will be included in the block it's
   -- about to forge.
   , tniProtocolInfo :: ProtocolInfo blk
-  , tniBlockForging :: m [BlockForging m blk]
+  , tniBlockForging :: m [MkBlockForging m blk]
   }
 
 plainTestNodeInitialization ::
   ProtocolInfo blk ->
-  m [BlockForging m blk] ->
+  m [MkBlockForging m blk] ->
   TestNodeInitialization m blk
 plainTestNodeInitialization pInfo blockForging =
   TestNodeInitialization
@@ -506,20 +507,20 @@ runThreadNetwork
         loop ::
           SlotNo ->
           ProtocolInfo blk ->
-          m [BlockForging m blk] ->
+          m [MkBlockForging m blk] ->
           NodeRestart ->
           Map SlotNo NodeRestart ->
           m ()
-        loop s pInfo blockForging nr rs = do
+        loop s pInfo mkBlockForging nr rs = do
           -- a registry solely for the resources of this specific node instance
           (again, finalChain, finalLdgr) <- withRegistry $ \nodeRegistry -> do
             -- change the node's key and prepare a delegation transaction if
             -- the node is restarting because it just rekeyed
             tni' <- case (nr, mbRekeyM) of
               (NodeRekey, Just rekeyM) -> do
-                rekeyM coreNodeId pInfo blockForging s (pure . HFF.futureSlotToEpoch future)
+                rekeyM coreNodeId pInfo mkBlockForging s (pure . HFF.futureSlotToEpoch future)
               _ ->
-                pure $ plainTestNodeInitialization pInfo blockForging
+                pure $ plainTestNodeInitialization pInfo mkBlockForging
             let TestNodeInitialization
                   { tniCrucialTxs = crucialTxs'
                   , tniProtocolInfo = pInfo'
@@ -822,7 +823,7 @@ runThreadNetwork
       SlotNo ->
       ResourceRegistry m ->
       ProtocolInfo blk ->
-      m [BlockForging m blk] ->
+      m [MkBlockForging m blk] ->
       NodeInfo blk (StrictTMVar m MockFS) (Tracer m) ->
       [GenTx blk] ->
       -- \^ valid transactions the node should immediately propagate
@@ -830,7 +831,7 @@ runThreadNetwork
         ( NodeKernel m NodeId Void blk
         , LimitedApp m NodeId blk
         )
-    forkNode coreNodeId clock joinSlot registry pInfo blockForging nodeInfo txs0 = do
+    forkNode coreNodeId clock joinSlot registry pInfo mkBlockForging nodeInfo txs0 = do
       let ProtocolInfo{..} = pInfo
 
       let NodeInfo
@@ -1044,6 +1045,7 @@ runThreadNetwork
               { tracers
               , registry
               , cfg = pInfoConfig
+              , featureFlags = mempty
               , btime
               , chainDB
               , initChainDB = nodeInitChainDB
@@ -1056,13 +1058,7 @@ runThreadNetwork
               , mempoolCapacityOverride = NoMempoolCapacityBytesOverride
               , keepAliveRng = kaRng
               , peerSharingRng = psRng
-              , miniProtocolParameters =
-                  MiniProtocolParameters
-                    { chainSyncPipeliningHighMark = 4
-                    , chainSyncPipeliningLowMark = 2
-                    , blockFetchPipeliningMax = 10
-                    , txSubmissionMaxUnacked = 1000 -- TODO ?
-                    }
+              , miniProtocolParameters = defaultMiniProtocolParameters
               , blockFetchConfiguration =
                   BlockFetchConfiguration
                     { bfcMaxConcurrencyBulkSync = 1
@@ -1097,10 +1093,12 @@ runThreadNetwork
 
       nodeKernel <- initNodeKernel nodeKernelArgs
 
-      blockForging' <-
-        map (\bf -> bf{forgeBlock = customForgeBlock bf})
-          <$> blockForging
-      setBlockForging nodeKernel blockForging'
+      mkBlockForgings <- mkBlockForging
+      let mkBlockForgings' =
+            map
+              (\(MkBlockForging bfM) -> MkBlockForging $ fmap (\bf -> bf{forgeBlock = customForgeBlock bf}) bfM)
+              mkBlockForgings
+      setBlockForging nodeKernel mkBlockForgings'
 
       let mempool = getMempool nodeKernel
       let app =
@@ -1186,6 +1184,7 @@ runThreadNetwork
         Lazy.ByteString
         Lazy.ByteString
         (AnyMessage (TxSubmission2 (GenTxId blk) (GenTx blk)))
+        (AnyMessage (PerasCertDiffusion blk))
         (AnyMessage KeepAlive)
         (AnyMessage (PeerSharing NodeId))
     customNodeToNodeCodecs cfg ntnVersion =
@@ -1205,6 +1204,9 @@ runThreadNetwork
         , cTxSubmission2Codec =
             mapFailureCodec CodecIdFailure $
               NTN.cTxSubmission2Codec NTN.identityCodecs
+        , cPerasCertDiffusionCodec =
+            mapFailureCodec CodecIdFailure $
+              NTN.cPerasCertDiffusionCodec NTN.identityCodecs
         , cKeepAliveCodec =
             mapFailureCodec CodecIdFailure $
               NTN.cKeepAliveCodec NTN.identityCodecs
@@ -1795,6 +1797,7 @@ type LimitedApp' m addr blk =
     Lazy.ByteString
     Lazy.ByteString
     (AnyMessage (TxSubmission2 (GenTxId blk) (GenTx blk)))
+    (AnyMessage (PerasCertDiffusion blk))
     (AnyMessage KeepAlive)
     (AnyMessage (PeerSharing addr))
     NodeToNodeInitiatorResult
diff --git a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Rekeying.hs b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Rekeying.hs
index 6a2a48362..7164a3e40 100644
--- a/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Rekeying.hs
+++ b/ouroboros-consensus-diffusion/src/unstable-diffusion-testlib/Test/ThreadNet/Rekeying.hs
@@ -33,7 +33,7 @@ data Rekeying m blk = forall opKey. Rekeying
   , rekeyUpd ::
       CoreNodeId ->
       ProtocolInfo blk ->
-      m [BlockForging m blk] ->
+      m [MkBlockForging m blk] ->
       EpochNo ->
       opKey ->
       m (Maybe (TestNodeInitialization m blk))
diff --git a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/GSM.hs b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/GSM.hs
index 4f223c42e..44a57f4c3 100644
--- a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/GSM.hs
+++ b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/GSM.hs
@@ -137,7 +137,8 @@ setupGsm isHaaSatisfied vars = do
     (id, tracer)
     GSM.GsmView
       { GSM.antiThunderingHerd = Nothing
-      , GSM.candidateOverSelection = \s (PeerState c _) -> candidateOverSelection s c
+      , GSM.getCandidateOverSelection = pure $ \s (PeerState c _) ->
+          candidateOverSelection s c
       , GSM.peerIsIdle = isIdling
       , GSM.durationUntilTooOld = Just durationUntilTooOld
       , GSM.equivalent = (==) -- unsound, but harmless in this test
diff --git a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/Genesis/Tests/LoE/CaughtUp.hs b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/Genesis/Tests/LoE/CaughtUp.hs
index fe7383c0f..a58923bd6 100644
--- a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/Genesis/Tests/LoE/CaughtUp.hs
+++ b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/Genesis/Tests/LoE/CaughtUp.hs
@@ -58,6 +58,7 @@ import qualified Ouroboros.Consensus.Node.GSM as GSM
 import Ouroboros.Consensus.Node.Genesis (setGetLoEFragment)
 import Ouroboros.Consensus.Node.GsmState
 import Ouroboros.Consensus.NodeId
+import Ouroboros.Consensus.Peras.Weight (emptyPerasWeightSnapshot)
 import qualified Ouroboros.Consensus.Storage.ChainDB as ChainDB
 import Ouroboros.Consensus.Storage.ChainDB.API (ChainDB)
 import qualified Ouroboros.Consensus.Storage.ChainDB.API.Types.InvalidBlockPunishment as Punishment
@@ -279,7 +280,7 @@ mkGsmEntryPoints varChainSyncHandles chainDB writeGsmState =
   GSM.realGsmEntryPoints
     (id, nullTracer)
     GSM.GsmView
-      { GSM.candidateOverSelection
+      { GSM.getCandidateOverSelection = pure candidateOverSelection
       , GSM.peerIsIdle = csIdling
       , GSM.equivalent = (==) `on` AF.headPoint
       , GSM.getChainSyncStates = fmap cschState <$> cschcMap varChainSyncHandles
@@ -301,10 +302,13 @@ mkGsmEntryPoints varChainSyncHandles chainDB writeGsmState =
       Just{} ->
         -- precondition requires intersection
         GSM.WhetherCandidateIsBetter $
-          preferAnchoredCandidate (configBlock cfg) selection candFrag
+          preferAnchoredCandidate (configBlock cfg) weights selection candFrag
    where
     candFrag = csCandidate candidateState
 
+    -- TODO https://github.com/tweag/cardano-peras/issues/67
+    weights = emptyPerasWeightSnapshot
+
 forkGDD ::
   forall m.
   IOLike m =>
diff --git a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator.hs b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator.hs
index 549de0f35..b07657af1 100644
--- a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator.hs
+++ b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator.hs
@@ -164,6 +164,7 @@ prop_simple_hfc_convergence testSetup@TestSetup{..} =
         (History.StandardSafeZone (safeFromTipA k))
         (safeZoneB k)
       <*> pure (GenesisWindow ((unNonZero $ maxRollbacks k) * 2))
+      <*> pure (History.PerasEnabled defaultPerasRoundLength)
 
   shape :: History.Shape '[BlockA, BlockB]
   shape = History.Shape $ exactlyTwo eraParamsA eraParamsB
@@ -257,11 +258,11 @@ prop_simple_hfc_convergence testSetup@TestSetup{..} =
             }
       }
 
-  blockForging :: Monad m => [BlockForging m TestBlock]
+  blockForging :: Monad m => [MkBlockForging m TestBlock]
   blockForging =
-    [ hardForkBlockForging "Test" $
-        OptCons blockForgingA $
-          OptCons blockForgingB $
+    [ hardForkBlockForging (const "Test") $
+        OptCons (MkBlockForging $ pure blockForgingA) $
+          OptCons (MkBlockForging $ pure blockForgingB) $
             OptNil
     ]
 
diff --git a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/A.hs b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/A.hs
index d30d71dc7..50adf203b 100644
--- a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/A.hs
+++ b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/A.hs
@@ -358,6 +358,7 @@ blockForgingA =
     , forgeBlock = \cfg bno slot st txs proof ->
         return $
           forgeBlockA cfg bno slot st (fmap txForgetValidated txs) proof
+    , finalize = return ()
     }
 
 -- | See 'Ouroboros.Consensus.HardFork.History.EraParams.safeFromTip'
diff --git a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/B.hs b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/B.hs
index caf7d9bb3..4f74a9a42 100644
--- a/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/B.hs
+++ b/ouroboros-consensus-diffusion/test/consensus-test/Test/Consensus/HardFork/Combinator/B.hs
@@ -300,6 +300,7 @@ blockForgingB =
     , forgeBlock = \cfg bno slot st txs proof ->
         return $
           forgeBlockB cfg bno slot st (fmap txForgetValidated txs) proof
+    , finalize = return ()
     }
 
 -- | A basic 'History.SafeZone'
diff --git a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/BFT.hs b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/BFT.hs
index 3f82ec83e..34d0c567a 100644
--- a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/BFT.hs
+++ b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/BFT.hs
@@ -103,6 +103,7 @@ prop_simple_bft_convergence
         , version = newestVersion (Proxy @MockBftBlock)
         }
 
+    testOutput :: TestOutput MockBftBlock
     testOutput =
       runTestNetwork
         testConfig
@@ -116,6 +117,6 @@ prop_simple_bft_convergence
                     k
                     (HardFork.defaultEraParams k slotLength)
                 )
-                (pure $ blockForgingBft nid)
+                (pure $ fmap (MkBlockForging . pure) $ blockForgingBft nid)
           , mkRekeyM = Nothing
           }
diff --git a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/LeaderSchedule.hs b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/LeaderSchedule.hs
index 8e276266f..9dd2053a6 100644
--- a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/LeaderSchedule.hs
+++ b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/LeaderSchedule.hs
@@ -137,7 +137,7 @@ prop_simple_leader_schedule_convergence
                     schedule
                     emptyPraosEvolvingStake
                 )
-                (pure blockForgingPraosRule)
+                (pure $ fmap (MkBlockForging . pure) $ blockForgingPraosRule)
           , mkRekeyM = Nothing
           }
 
diff --git a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/PBFT.hs b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/PBFT.hs
index dac0a4c57..af003a923 100644
--- a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/PBFT.hs
+++ b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/PBFT.hs
@@ -128,7 +128,7 @@ prop_simple_pbft_convergence
                     params
                     (HardFork.defaultEraParams k slotLength)
                 )
-                (pure $ blockForgingMockPBFT nid)
+                (pure $ fmap (MkBlockForging . pure) $ blockForgingMockPBFT nid)
           , mkRekeyM = Nothing
           }
 
diff --git a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/Praos.hs b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/Praos.hs
index 27b0976ea..4b78803da 100644
--- a/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/Praos.hs
+++ b/ouroboros-consensus-diffusion/test/mock-test/Test/ThreadNet/Praos.hs
@@ -55,7 +55,7 @@ data TestSetup = TestSetup
 
 genEvolvingStake :: EpochSize -> TestConfig -> Gen PraosEvolvingStake
 genEvolvingStake epochSize TestConfig{numSlots, numCoreNodes} = do
-  chosenEpochs <- sublistOf [0 .. EpochNo $ max 1 maxEpochs - 1]
+  chosenEpochs <- sublistOf [EpochNo 0 .. EpochNo $ max 1 maxEpochs - 1]
   let l = fromIntegral maxEpochs
   stakeDists <- replicateM l genStakeDist
   return . PraosEvolvingStake . Map.fromList $ zip chosenEpochs stakeDists
@@ -171,7 +171,7 @@ prop_simple_praos_convergence
                     setupInitialNonce
                     evolvingStake
                 )
-                (blockForgingPraos numCoreNodes nid)
+                (fmap (fmap (MkBlockForging . pure)) $ blockForgingPraos numCoreNodes nid)
           , mkRekeyM = Nothing
           }
 
diff --git a/ouroboros-consensus-protocol/CHANGELOG.md b/ouroboros-consensus-protocol/CHANGELOG.md
index d2a6c5ef1..fa15a6d88 100644
--- a/ouroboros-consensus-protocol/CHANGELOG.md
+++ b/ouroboros-consensus-protocol/CHANGELOG.md
@@ -2,6 +2,43 @@
 
 # Changelog entries
 
+<a id='changelog-0.13.0.0'></a>
+## 0.13.0.0 -- 2025-09-29
+
+### Patch
+
+- Bump `cardano-protocol-tpraos` to 1.4.1
+
+### Non-Breaking
+
+- Added `SafeToHash` instance for `BHeader`
+
+### Breaking
+
+- Use new mlocked KES API for all internal KES sign key handling.
+- Add finalizers to all block forgings (required by `ouroboros-consensus`).
+- Change `HotKey` to manage not only KES sign keys, but also the corresponding
+  OpCerts. This is in preparation for KES agent connectivity: with the new
+  design, the KES agent will provide both KES sign keys and matching OpCerts
+  together, and we need to be able to dynamically replace them both together.
+- Add finalizer to `HotKey`. This takes care of securely forgetting any KES
+  keys the HotKey may still hold, and will be called automatically when the
+  owning block forging terminates.
+- Change `PraosCanBeLeader` to not contain the KES sign key itself anymore.
+  Instead, it now contains a `PraosCredentialsSource` field, which
+  specifies how to obtain the actual credentials (OpCert and KES SignKey). For
+  now, the only supported method is passing an OpCert and an
+  UnsoundPureSignKeyKES, presumably loaded from disk
+  (`PraosCredentialsUnsound`); future iterations will add support for
+  connecting to a KES agent.
+
+- Encode the slot number in the TPraos state as `[] / [slot]` instead of `[0] / [1, slot]`.
+
+- Add new `HasMaxMajorProtVer` class for consensus protocols.
+
+- Removed `PraosChainSelectView`, use `SelectView (TPraos c)`/`SelectView (Praos
+  c)` instead.
+
 <a id='changelog-0.12.0.0'></a>
 ## 0.12.0.0 -- 2025-04-21
 
diff --git a/ouroboros-consensus-protocol/changelog.d/20250528_162423_javier.sagredo_withoriginth.md b/ouroboros-consensus-protocol/changelog.d/20250528_162423_javier.sagredo_withoriginth.md
deleted file mode 100644
index 5207ac84d..000000000
--- a/ouroboros-consensus-protocol/changelog.d/20250528_162423_javier.sagredo_withoriginth.md
+++ /dev/null
@@ -1,22 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Encode the slot number in the TPraos state as `[] / [slot]` instead of `[0] / [1, slot]`.
diff --git a/ouroboros-consensus-protocol/changelog.d/20250603_131116_javier.sagredo_newer_ledger.md b/ouroboros-consensus-protocol/changelog.d/20250603_131116_javier.sagredo_newer_ledger.md
deleted file mode 100644
index b4c160d7c..000000000
--- a/ouroboros-consensus-protocol/changelog.d/20250603_131116_javier.sagredo_newer_ledger.md
+++ /dev/null
@@ -1,24 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-<!--
-### Breaking
-
-- A bullet item for the Breaking category.
-
--->
diff --git a/ouroboros-consensus-protocol/changelog.d/20250616_122906_javier.sagredo_query_max_major_prot_ver.md b/ouroboros-consensus-protocol/changelog.d/20250616_122906_javier.sagredo_query_max_major_prot_ver.md
deleted file mode 100644
index cfef66db3..000000000
--- a/ouroboros-consensus-protocol/changelog.d/20250616_122906_javier.sagredo_query_max_major_prot_ver.md
+++ /dev/null
@@ -1,21 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-### Breaking
-
-- Add new `HasMaxMajorProtVer` class for consensus protocols.
diff --git a/ouroboros-consensus-protocol/changelog.d/20250716_190242_alexander.esgen_tiebreaker_view.md b/ouroboros-consensus-protocol/changelog.d/20250716_190242_alexander.esgen_tiebreaker_view.md
deleted file mode 100644
index 173979570..000000000
--- a/ouroboros-consensus-protocol/changelog.d/20250716_190242_alexander.esgen_tiebreaker_view.md
+++ /dev/null
@@ -1,4 +0,0 @@
-### Breaking
-
-- Removed `PraosChainSelectView`, use `SelectView (TPraos c)`/`SelectView (Praos
-  c)` instead.
diff --git a/ouroboros-consensus-protocol/changelog.d/20250903_152939_coot_size_limits.md b/ouroboros-consensus-protocol/changelog.d/20250903_152939_coot_size_limits.md
new file mode 100644
index 000000000..643b2aa82
--- /dev/null
+++ b/ouroboros-consensus-protocol/changelog.d/20250903_152939_coot_size_limits.md
@@ -0,0 +1,4 @@
+### Non-Breaking
+
+- Small refactoring inside doValidateKESSignature to make it more readable.
+
diff --git a/ouroboros-consensus-protocol/changelog.d/20250806_150821_georgy.lukyanov_update_ledger.md b/ouroboros-consensus-protocol/changelog.d/20251002_112510_javier.sagredo_lsm1.md
similarity index 87%
rename from ouroboros-consensus-protocol/changelog.d/20250806_150821_georgy.lukyanov_update_ledger.md
rename to ouroboros-consensus-protocol/changelog.d/20251002_112510_javier.sagredo_lsm1.md
index 53d2ef2ec..5e9da7f4c 100644
--- a/ouroboros-consensus-protocol/changelog.d/20250806_150821_georgy.lukyanov_update_ledger.md
+++ b/ouroboros-consensus-protocol/changelog.d/20251002_112510_javier.sagredo_lsm1.md
@@ -5,10 +5,9 @@ Uncomment the section that is right (remove the HTML comment wrapper).
 For top level release notes, leave all the headers commented out.
 -->
 
-
 ### Patch
 
-- Bump `cardano-protocol-tpraos` to 1.4.1
+- Bump `cardano-ledger-core` dependency to 1.19.
 
 <!--
 ### Non-Breaking
diff --git a/ouroboros-consensus-protocol/ouroboros-consensus-protocol.cabal b/ouroboros-consensus-protocol/ouroboros-consensus-protocol.cabal
index dffbcc571..8afd2fdbd 100644
--- a/ouroboros-consensus-protocol/ouroboros-consensus-protocol.cabal
+++ b/ouroboros-consensus-protocol/ouroboros-consensus-protocol.cabal
@@ -1,6 +1,6 @@
 cabal-version: 3.0
 name: ouroboros-consensus-protocol
-version: 0.12.0.0
+version: 0.13.0.0
 synopsis: Cardano consensus protocols
 description: Cardano consensus protocols.
 license: Apache-2.0
@@ -56,6 +56,7 @@ library
     Ouroboros.Consensus.Protocol.Ledger.HotKey
     Ouroboros.Consensus.Protocol.Ledger.Util
     Ouroboros.Consensus.Protocol.Praos
+    Ouroboros.Consensus.Protocol.Praos.AgentClient
     Ouroboros.Consensus.Protocol.Praos.Common
     Ouroboros.Consensus.Protocol.Praos.Header
     Ouroboros.Consensus.Protocol.Praos.VRF
@@ -63,6 +64,7 @@ library
     Ouroboros.Consensus.Protocol.TPraos
 
   build-depends:
+    Win32-network ^>=0.2,
     base >=4.14 && <4.22,
     bytestring,
     cardano-binary,
@@ -74,9 +76,17 @@ library
     cardano-slotting,
     cborg,
     containers,
+    contra-tracer ^>=0.1.0,
+    io-classes ^>=1.8.0,
+    io-sim,
+    kes-agent <1,
+    kes-agent-crypto <1,
     mtl,
+    network ^>=3.2.7,
     nothunks,
-    ouroboros-consensus >=0.23 && <0.28,
+    ouroboros-consensus >=0.23 && <0.29,
+    ouroboros-network-framework ^>=0.19,
+    ouroboros-network-testing ^>=0.8,
     serialise,
     text,
 
@@ -119,7 +129,7 @@ test-suite protocol-test
     base,
     cardano-crypto-class ^>=2.2,
     cardano-ledger-binary:testlib,
-    cardano-ledger-core >=1.17 && <1.19,
+    cardano-ledger-core >=1.17 && <1.20,
     cardano-protocol-tpraos ^>=1.4.1,
     containers,
     ouroboros-consensus:{ouroboros-consensus, unstable-consensus-testlib},
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Ledger/HotKey.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Ledger/HotKey.hs
index cbaec8a8b..c53da8ced 100644
--- a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Ledger/HotKey.hs
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Ledger/HotKey.hs
@@ -1,9 +1,16 @@
 {-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE NamedFieldPuns #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeOperators #-}
+{-# LANGUAGE UndecidableInstances #-}
 
 -- | Hot key
 --
@@ -22,7 +29,11 @@ module Ouroboros.Consensus.Protocol.Ledger.HotKey
   , HotKey (..)
   , KESEvolutionError (..)
   , KESEvolutionInfo
+  , getOCert
+  , mkDynamicHotKey
+  , mkEmptyHotKey
   , mkHotKey
+  , mkHotKeyAtEvolution
   , sign
   ) where
 
@@ -30,9 +41,12 @@ import qualified Cardano.Crypto.KES as KES
 import qualified Cardano.Crypto.KES as Relative (Period)
 import Cardano.Protocol.Crypto (Crypto (..))
 import qualified Cardano.Protocol.TPraos.OCert as Absolute (KESPeriod (..))
+import qualified Cardano.Protocol.TPraos.OCert as OCert
+import Control.Monad (forM_)
 import Data.Word (Word64)
 import GHC.Generics (Generic)
 import GHC.Stack (HasCallStack)
+import NoThunks.Class (OnlyCheckWhnfNamed (..))
 import Ouroboros.Consensus.Block.Forging (UpdateInfo (..))
 import Ouroboros.Consensus.Util.IOLike
 
@@ -134,19 +148,39 @@ data HotKey c m = HotKey
   -- When the key cannot evolve anymore, we poison it.
   , getInfo :: m KESInfo
   -- ^ Return 'KESInfo' of the signing key.
+  , getOCertMaybe :: m (Maybe (OCert.OCert c))
+  -- ^ Return the 'OCert' corresponding to the KES signing key, if any.
   , isPoisoned :: m Bool
-  -- ^ Return 'True' when the signing key is poisoned because it expired.
+  -- ^ Check whether a valid KES signing key exists. "Poisoned" means no
+  -- key exists; reasons for this could be:
+  -- - no signing key has been set yet
+  -- - the signing key has been explicitly erased ('forget')
+  -- - the signing key has been evolved past the end of the available
+  --   evolutions
   , sign_ ::
       forall toSign.
       (KES.Signable (KES c) toSign, HasCallStack) =>
-      toSign -> m (KES.SignedKES (KES c) toSign)
+      toSign ->
+      m (KES.SignedKES (KES c) toSign)
   -- ^ Sign the given @toSign@ with the current signing key.
   --
   -- PRECONDITION: the key is not poisoned.
   --
   -- POSTCONDITION: the signature is in normal form.
+  , finalize :: m ()
+  -- ^ Release any resources held by the 'HotKey', including the signing key
+  -- itself. This should be called exactly once per 'HotKey' instance.
   }
 
+deriving via (OnlyCheckWhnfNamed "HotKey" (HotKey c m)) instance NoThunks (HotKey c m)
+
+getOCert :: Monad m => HotKey c m -> m (OCert.OCert c)
+getOCert hotKey = do
+  ocertMay <- getOCertMaybe hotKey
+  case ocertMay of
+    Just ocert -> return ocert
+    Nothing -> error "trying to read OpCert for poisoned key"
+
 sign ::
   (KES.Signable (KES c) toSign, HasCallStack) =>
   HotKey c m ->
@@ -157,15 +191,15 @@ sign = sign_
 -- | The actual KES key, unless it expired, in which case it is replaced by
 -- \"poison\".
 data KESKey c
-  = KESKey !(KES.UnsoundPureSignKeyKES (KES c))
+  = KESKey !(OCert.OCert c) !(KES.SignKeyKES (KES c))
   | KESKeyPoisoned
   deriving Generic
 
-instance Crypto c => NoThunks (KESKey c)
+instance (NoThunks (KES.SignKeyKES (KES c)), Crypto c) => NoThunks (KESKey c)
 
 kesKeyIsPoisoned :: KESKey c -> Bool
 kesKeyIsPoisoned KESKeyPoisoned = True
-kesKeyIsPoisoned (KESKey _) = False
+kesKeyIsPoisoned (KESKey _ _) = False
 
 data KESState c = KESState
   { kesStateInfo :: !KESInfo
@@ -173,35 +207,141 @@ data KESState c = KESState
   }
   deriving Generic
 
-instance Crypto c => NoThunks (KESState c)
+instance (NoThunks (KES.SignKeyKES (KES c)), Crypto c) => NoThunks (KESState c)
 
+-- Create a new 'HotKey' and initialize it to the given initial KES key. The
+-- initial key must be at evolution 0 (i.e., freshly generated and never
+-- evolved).
 mkHotKey ::
   forall m c.
   (Crypto c, IOLike m) =>
-  KES.UnsoundPureSignKeyKES (KES c) ->
+  OCert.OCert c ->
+  KES.SignKeyKES (KES c) ->
+  -- | Start period
+  Absolute.KESPeriod ->
+  -- | Max KES evolutions
+  Word64 ->
+  m (HotKey c m)
+mkHotKey = mkHotKeyAtEvolution 0
+
+-- Create a new 'HotKey' and initialize it to the given initial KES key. The
+-- initial key should be at the given evolution.
+mkHotKeyAtEvolution ::
+  forall m c.
+  (Crypto c, IOLike m) =>
+  Word ->
+  OCert.OCert c ->
+  KES.SignKeyKES (KES c) ->
   -- | Start period
   Absolute.KESPeriod ->
   -- | Max KES evolutions
   Word64 ->
   m (HotKey c m)
-mkHotKey initKey startPeriod@(Absolute.KESPeriod start) maxKESEvolutions = do
+mkHotKeyAtEvolution evolution ocert initKey startPeriod maxKESEvolutions =
+  mkHotKeyWith
+    (Just (ocert, initKey, evolution, startPeriod))
+    maxKESEvolutions
+    Nothing
+
+-- | Create a new 'HotKey' and initialize it to a poisoned state (containing no
+-- valid KES sign key).
+mkEmptyHotKey ::
+  forall m c.
+  (Crypto c, IOLike m) =>
+  -- | Max KES evolutions
+  Word64 ->
+  m (HotKey c m)
+mkEmptyHotKey maxKESEvolutions =
+  mkDynamicHotKey maxKESEvolutions Nothing
+
+mkKESState ::
+  Word64 -> OCert.OCert c -> KES.SignKeyKES (KES c) -> Word -> Absolute.KESPeriod -> KESState c
+mkKESState maxKESEvolutions newOCert newKey evolution startPeriod@(Absolute.KESPeriod start) =
+  KESState
+    { kesStateInfo =
+        KESInfo
+          { kesStartPeriod = startPeriod
+          , kesEndPeriod = Absolute.KESPeriod (start + fromIntegral maxKESEvolutions)
+          , kesEvolution = evolution
+          }
+    , kesStateKey = KESKey newOCert newKey
+    }
+
+type KeyProducer c m =
+  -- | Callback that will be invoked when a new key has been received
+  (OCert.OCert c -> KES.SignKeyKES (KES c) -> Word -> Absolute.KESPeriod -> m ()) ->
+  -- | Callback that will be invoked when a key deletion has been received
+  m () ->
+  m ()
+
+-- | Create a new 'HotKey' that runs a key-producer action on a separate thread.
+-- The key producer action will receive a callback that can be used to pass
+-- keys into the HotKey; the HotKey will dynamically update its internal state
+-- to reflect new keys as they arrive.
+mkDynamicHotKey ::
+  forall m c.
+  (Crypto c, IOLike m) =>
+  -- | Max KES evolutions
+  Word64 ->
+  Maybe (KeyProducer c m) ->
+  m (HotKey c m)
+mkDynamicHotKey = mkHotKeyWith Nothing
+
+-- | The most general function for creating a new 'HotKey', accepting an initial
+-- set of credentials, a key producer action, and a custom finalizer.
+mkHotKeyWith ::
+  forall m c.
+  (Crypto c, IOLike m) =>
+  Maybe (OCert.OCert c, KES.SignKeyKES (KES c), Word, Absolute.KESPeriod) ->
+  -- | Max KES evolutions
+  Word64 ->
+  Maybe (KeyProducer c m) ->
+  m (HotKey c m)
+mkHotKeyWith initialStateMay maxKESEvolutions keyThreadMay = do
   varKESState <- newMVar initKESState
+
+  let set newOCert newKey evolution startPeriod =
+        modifyMVar_ varKESState $ \oldState -> do
+          _ <- poisonState oldState
+          return $ mkKESState maxKESEvolutions newOCert newKey evolution startPeriod
+      unset =
+        modifyMVar_ varKESState poisonState
+
+  forM_ initialStateMay $ \(newOCert, newKey, evolution, startPeriod) ->
+    set newOCert newKey evolution startPeriod
+
+  finalizer' <- case keyThreadMay of
+    Just keyThread -> do
+      keyThreadAsync <- async $ do
+        labelThisThread "HotKey receiver"
+        keyThread set unset
+
+      -- 'cancel' cannot throw exceptions, so we don't need to use 'finally'
+      -- here
+      pure (cancel keyThreadAsync >> unset)
+    Nothing ->
+      -- we don't need to do anything here, since we haven't spawned any other
+      -- threads to communicate with the KES agent
+      pure $ pure ()
+
   return
     HotKey
       { evolve = evolveKey varKESState
       , getInfo = kesStateInfo <$> readMVar varKESState
+      , getOCertMaybe =
+          kesStateKey <$> readMVar varKESState >>= \case
+            KESKeyPoisoned -> return Nothing
+            KESKey ocert _ -> return (Just ocert)
       , isPoisoned = kesKeyIsPoisoned . kesStateKey <$> readMVar varKESState
       , sign_ = \toSign -> do
-          KESState{kesStateInfo, kesStateKey} <- readMVar varKESState
-          case kesStateKey of
-            KESKeyPoisoned -> error "trying to sign with a poisoned key"
-            KESKey key -> do
-              let evolution = kesEvolution kesStateInfo
-                  signed = KES.unsoundPureSignedKES () evolution toSign key
-              -- Force the signature to WHNF (for 'SignedKES', WHNF implies
-              -- NF) so that we don't have any thunks holding on to a key that
-              -- might be destructively updated when evolved.
-              evaluate signed
+          withMVar varKESState $ \KESState{kesStateInfo, kesStateKey} -> do
+            case kesStateKey of
+              KESKeyPoisoned ->
+                error "trying to sign with a poisoned key"
+              KESKey _ key -> do
+                let evolution = kesEvolution kesStateInfo
+                KES.signedKES () evolution toSign key
+      , finalize = finalizer'
       }
  where
   initKESState :: KESState c
@@ -209,14 +349,26 @@ mkHotKey initKey startPeriod@(Absolute.KESPeriod start) maxKESEvolutions = do
     KESState
       { kesStateInfo =
           KESInfo
-            { kesStartPeriod = startPeriod
-            , kesEndPeriod = Absolute.KESPeriod (start + fromIntegral maxKESEvolutions)
-            , -- We always start from 0 as the key hasn't evolved yet.
-              kesEvolution = 0
+            { kesStartPeriod = Absolute.KESPeriod 0
+            , kesEndPeriod = Absolute.KESPeriod 0
+            , kesEvolution = 0
             }
-      , kesStateKey = KESKey initKey
+      , kesStateKey = KESKeyPoisoned
       }
 
+poisonState ::
+  forall m c.
+  (KES.KESAlgorithm (KES c), IOLike m) =>
+  KESState c -> m (KESState c)
+poisonState kesState = do
+  case kesStateKey kesState of
+    KESKeyPoisoned -> do
+      -- already poisoned
+      return kesState
+    KESKey _ sk -> do
+      forgetSignKeyKES sk
+      return kesState{kesStateKey = KESKeyPoisoned}
+
 -- | Evolve the 'HotKey' so that its evolution matches the given KES period.
 --
 -- When the given KES period is after the end period of the 'HotKey', we
@@ -232,7 +384,7 @@ mkHotKey initKey startPeriod@(Absolute.KESPeriod start) maxKESEvolutions = do
 -- When the key is poisoned, we always return 'UpdateFailed'.
 evolveKey ::
   forall m c.
-  (Crypto c, IOLike m) =>
+  (IOLike m, KES.ContextKES (KES c) ~ (), KES.KESAlgorithm (KES c)) =>
   StrictMVar m (KESState c) -> Absolute.KESPeriod -> m KESEvolutionInfo
 evolveKey varKESState targetPeriod = modifyMVar varKESState $ \kesState -> do
   let info = kesStateInfo kesState
@@ -244,7 +396,7 @@ evolveKey varKESState targetPeriod = modifyMVar varKESState $ \kesState -> do
     KESKeyPoisoned ->
       let err = KESKeyAlreadyPoisoned info targetPeriod
        in return (kesState, UpdateFailed err)
-    KESKey key -> case kesStatus info targetPeriod of
+    KESKey ocert key -> case kesStatus info targetPeriod of
       -- When the absolute period is before the start period, we can't
       -- update the key. 'checkCanForge' will say we can't forge because the
       -- key is not valid yet.
@@ -252,9 +404,10 @@ evolveKey varKESState targetPeriod = modifyMVar varKESState $ \kesState -> do
         return (kesState, Updated info)
       -- When the absolute period is after the end period, we can't evolve
       -- anymore and poison the expired key.
-      AfterKESEnd{} ->
+      AfterKESEnd{} -> do
         let err = KESCouldNotEvolve info targetPeriod
-         in return (poisonState kesState, UpdateFailed err)
+        poisonedState <- poisonState kesState
+        return (poisonedState, UpdateFailed err)
       InKESRange targetEvolution
         -- No evolving needed
         | targetEvolution <= kesEvolution info ->
@@ -262,29 +415,26 @@ evolveKey varKESState targetPeriod = modifyMVar varKESState $ \kesState -> do
         -- Evolving needed
         | otherwise ->
             (\s' -> (s', Updated (kesStateInfo s')))
-              <$> go targetEvolution info key
+              <$> go targetEvolution info ocert key
  where
-  poisonState :: KESState c -> KESState c
-  poisonState kesState = kesState{kesStateKey = KESKeyPoisoned}
-
   -- \| PRECONDITION:
   --
   -- > targetEvolution >= curEvolution
-  go :: KESEvolution -> KESInfo -> KES.UnsoundPureSignKeyKES (KES c) -> m (KESState c)
-  go targetEvolution info key
+  go :: KESEvolution -> KESInfo -> OCert.OCert c -> KES.SignKeyKES (KES c) -> m (KESState c)
+  go targetEvolution info ocert key
     | targetEvolution <= curEvolution =
-        return $ KESState{kesStateInfo = info, kesStateKey = KESKey key}
+        return $ KESState{kesStateInfo = info, kesStateKey = KESKey ocert key}
     | otherwise =
-        case KES.unsoundPureUpdateKES () key curEvolution of
-          -- This cannot happen
-          Nothing -> error "Could not update KES key"
-          Just !key' -> do
-            -- Clear the memory associated with the old key
-            -- FIXME: Secure forgetting is not available through the unsound KES API,
-            -- but we must restore this invocation when moving to the new mlocked KES
-            -- API.
-            -- forgetSignKeyKES key
-            let info' = info{kesEvolution = curEvolution + 1}
-            go targetEvolution info' key'
+        do
+          maybeKey' <- KES.updateKES () key curEvolution
+          case maybeKey' of
+            Nothing ->
+              -- This cannot happen
+              error "Could not update KES key"
+            Just !key' -> do
+              -- Clear the memory associated with the old key
+              forgetSignKeyKES key
+              let info' = info{kesEvolution = curEvolution + 1}
+              go targetEvolution info' ocert key'
    where
     curEvolution = kesEvolution info
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos.hs
index 96b896886..772f3c255 100644
--- a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos.hs
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos.hs
@@ -91,7 +91,6 @@ import Data.Functor.Identity (runIdentity)
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
 import Data.Proxy (Proxy (Proxy))
-import qualified Data.Set as Set
 import Data.Word (Word64)
 import GHC.Generics (Generic)
 import NoThunks.Class (NoThunks)
@@ -187,26 +186,24 @@ forgePraosFields
   PraosCanBeLeader
     { praosCanBeLeaderColdVerKey
     , praosCanBeLeaderSignKeyVRF
-    , praosCanBeLeaderOpCert
     }
   PraosIsLeader{praosIsLeaderVrfRes}
   mkToSign = do
+    ocert <- HotKey.getOCert hotKey
+    let signedFields =
+          PraosToSign
+            { praosToSignIssuerVK = praosCanBeLeaderColdVerKey
+            , praosToSignVrfVK = VRF.deriveVerKeyVRF praosCanBeLeaderSignKeyVRF
+            , praosToSignVrfRes = praosIsLeaderVrfRes
+            , praosToSignOCert = ocert
+            }
+        toSign = mkToSign signedFields
     signature <- HotKey.sign hotKey toSign
     return
       PraosFields
         { praosSignature = signature
         , praosToSign = toSign
         }
-   where
-    toSign = mkToSign signedFields
-
-    signedFields =
-      PraosToSign
-        { praosToSignIssuerVK = praosCanBeLeaderColdVerKey
-        , praosToSignVrfVK = VRF.deriveVerKeyVRF praosCanBeLeaderSignKeyVRF
-        , praosToSignVrfRes = praosIsLeaderVrfRes
-        , praosToSignOCert = praosCanBeLeaderOpCert
-        }
 
 {-------------------------------------------------------------------------------
   Protocol proper
@@ -652,10 +649,12 @@ doValidateKESSignature praosMaxKESEvo praosSlotsPerKESPeriod stakeDistribution o
 
   currentIssueNo :: Maybe Word64
   currentIssueNo
-    | Map.member hk ocertCounters = Map.lookup hk ocertCounters
-    | Set.member (coerceKeyRole hk) (Map.keysSet stakeDistribution) =
+    | r@Just{} <- Map.lookup hk ocertCounters =
+        r
+    | Map.member (coerceKeyRole hk) stakeDistribution =
         Just 0
-    | otherwise = Nothing
+    | otherwise =
+        Nothing
 
 {-------------------------------------------------------------------------------
   CannotForge
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/AgentClient.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/AgentClient.hs
new file mode 100644
index 000000000..c9564a3bd
--- /dev/null
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/AgentClient.hs
@@ -0,0 +1,188 @@
+{-# LANGUAGE ConstraintKinds #-}
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeOperators #-}
+{-# OPTIONS_GHC -Wno-orphans #-}
+
+module Ouroboros.Consensus.Protocol.Praos.AgentClient
+  ( AgentCrypto (..)
+  , KESAgentClientTrace (..)
+  , KESAgentContext
+  , MonadKESAgent (..)
+  , runKESAgentClient
+  ) where
+
+import Cardano.Crypto.DirectSerialise
+  ( DirectDeserialise
+  , DirectSerialise
+  )
+import Cardano.Crypto.KES.Class
+import Cardano.Crypto.VRF.Class
+import qualified Cardano.KESAgent.KES.Bundle as Agent
+import qualified Cardano.KESAgent.KES.Crypto as Agent
+import qualified Cardano.KESAgent.KES.OCert as Agent
+import qualified Cardano.KESAgent.Processes.ServiceClient as Agent
+import qualified Cardano.KESAgent.Protocols.RecvResult as Agent
+import qualified Cardano.KESAgent.Protocols.StandardCrypto as Agent
+import qualified Cardano.KESAgent.Protocols.VersionedProtocol as Agent
+import Cardano.KESAgent.Util.RefCounting
+import Cardano.Ledger.Keys (DSIGN)
+import Cardano.Protocol.Crypto (Crypto, KES, StandardCrypto, VRF)
+import qualified Cardano.Protocol.TPraos.OCert as OCert
+import Control.Monad (forever)
+import Control.Monad.Class.MonadAsync
+import Control.Monad.IOSim
+import Control.Tracer
+import Data.Coerce (coerce)
+import Data.Kind
+import Data.Typeable
+import Network.Socket
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Network.RawBearer
+import Ouroboros.Network.Snocket
+import qualified Simulation.Network.Snocket as SimSnocket
+import System.IOManager
+import Test.Ouroboros.Network.Data.AbsBearerInfo as ABI
+
+type KESAgentContext c m =
+  ( AgentCrypto c
+  , MonadKESAgent m
+  , IOLike m
+  )
+
+data KESAgentClientTrace
+  = KESAgentClientException SomeException
+  | KESAgentClientTrace Agent.ServiceClientTrace
+  deriving Show
+
+class
+  ( Crypto c
+  , Agent.Crypto (ACrypto c)
+  , Agent.NamedCrypto (ACrypto c)
+  , Agent.KES (ACrypto c) ~ KES c
+  , ContextKES (KES c) ~ ()
+  , ContextVRF (VRF c) ~ ()
+  , Typeable (ACrypto c)
+  , Agent.ServiceClientDrivers (ACrypto c)
+  , DirectSerialise (SignKeyKES (KES c))
+  , DirectDeserialise (SignKeyKES (KES c))
+  ) =>
+  AgentCrypto c
+  where
+  type ACrypto c :: Type
+
+instance AgentCrypto StandardCrypto where
+  type ACrypto StandardCrypto = Agent.StandardCrypto
+
+convertOCert ::
+  (AgentCrypto c, Agent.DSIGN (ACrypto c) ~ DSIGN) => Agent.OCert (ACrypto c) -> OCert.OCert c
+convertOCert oca =
+  OCert.OCert
+    { OCert.ocertVkHot = Agent.ocertVkHot oca
+    , OCert.ocertN = Agent.ocertN oca
+    , OCert.ocertKESPeriod = OCert.KESPeriod (Agent.unKESPeriod $ Agent.ocertKESPeriod oca)
+    , OCert.ocertSigma = coerce (Agent.ocertSigma oca)
+    }
+
+convertPeriod :: Agent.KESPeriod -> OCert.KESPeriod
+convertPeriod (Agent.KESPeriod p) = OCert.KESPeriod p
+
+class (MonadFail m, Show (Addr m)) => MonadKESAgent m where
+  type FD m :: Type
+  type Addr m :: Type
+  withAgentContext :: (Snocket m (FD m) (Addr m) -> m a) -> m a
+  makeRawBearer :: MakeRawBearer m (FD m)
+  makeAddress :: Proxy m -> FilePath -> Addr m
+
+instance MonadKESAgent IO where
+  type FD IO = Socket
+  type Addr IO = SockAddr
+  withAgentContext inner =
+    withIOManager $ \ioManager ->
+      inner (socketSnocket ioManager)
+  makeRawBearer = makeSocketRawBearer
+  makeAddress _ = SockAddrUnix
+
+instance MonadKESAgent (IOSim s) where
+  type FD (IOSim s) = SimSnocket.FD (IOSim s) (TestAddress FilePath)
+  type Addr (IOSim s) = TestAddress FilePath
+  withAgentContext inner = do
+    SimSnocket.withSnocket
+      nullTracer
+      (toBearerInfo $ absNoAttenuation{abiConnectionDelay = SmallDelay})
+      mempty
+      $ \snocket _observe -> inner snocket
+  makeRawBearer = SimSnocket.makeFDRawBearer nullTracer
+  makeAddress _ = TestAddress
+
+instance SimSnocket.GlobalAddressScheme FilePath where
+  getAddressType = const SimSnocket.IPv4Address
+  ephemeralAddress _ty num = TestAddress $ "simSnocket_" <> show num
+
+runKESAgentClient ::
+  forall m c.
+  ( KESAgentContext c m
+  , Agent.DSIGN (ACrypto c) ~ DSIGN
+  ) =>
+  Tracer m KESAgentClientTrace ->
+  FilePath ->
+  (OCert.OCert c -> SignKeyKES (KES c) -> Word -> OCert.KESPeriod -> m ()) ->
+  m () ->
+  m ()
+runKESAgentClient tracer path handleKey handleDropKey = do
+  withAgentContext $ \snocket -> do
+    forever $ do
+      Agent.runServiceClient
+        (Proxy @(ACrypto c))
+        makeRawBearer
+        ( Agent.ServiceClientOptions
+            { Agent.serviceClientSnocket = snocket
+            , Agent.serviceClientAddress = makeAddress (Proxy @m) path
+            } ::
+            Agent.ServiceClientOptions m (FD m) (Addr m)
+        )
+        ( \(Agent.TaggedBundle mBundle _) -> do
+            case mBundle of
+              Just (Agent.Bundle skpRef ocert) -> do
+                -- We take ownership of the key, so we acquire one extra reference,
+                -- preventing the key from being discarded after `handleKey`
+                -- finishes.
+                _ <- acquireCRef skpRef
+                withCRefValue skpRef $ \(SignKeyWithPeriodKES sk p) ->
+                  handleKey (convertOCert ocert) sk p (convertPeriod $ Agent.ocertKESPeriod ocert)
+                return Agent.RecvOK
+              _ -> do
+                handleDropKey
+                return Agent.RecvOK
+        )
+        (contramap KESAgentClientTrace tracer)
+        `catch` ( \(_e :: AsyncCancelled) ->
+                    return ()
+                )
+        `catch` ( \(e :: SomeException) ->
+                    traceWith tracer (KESAgentClientException e)
+                )
+      threadDelay 10000000
+
+toBearerInfo :: ABI.AbsBearerInfo -> SimSnocket.BearerInfo
+toBearerInfo abi =
+  SimSnocket.BearerInfo
+    { SimSnocket.biConnectionDelay = ABI.delay (ABI.abiConnectionDelay abi)
+    , SimSnocket.biInboundAttenuation = attenuation (ABI.abiInboundAttenuation abi)
+    , SimSnocket.biOutboundAttenuation = attenuation (ABI.abiOutboundAttenuation abi)
+    , SimSnocket.biInboundWriteFailure = ABI.abiInboundWriteFailure abi
+    , SimSnocket.biOutboundWriteFailure = ABI.abiOutboundWriteFailure abi
+    , SimSnocket.biAcceptFailures =
+        ( \(errDelay, errType) ->
+            ( ABI.delay errDelay
+            , errType
+            )
+        )
+          <$> abiAcceptFailure abi
+    , SimSnocket.biSDUSize = toSduSize (ABI.abiSDUSize abi)
+    }
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Common.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Common.hs
index be0991105..2c255a608 100644
--- a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Common.hs
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Common.hs
@@ -2,8 +2,13 @@
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GADTs #-}
 {-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
 
 -- | Various things common to iterations of the Praos protocol.
@@ -15,26 +20,35 @@ module Ouroboros.Consensus.Protocol.Praos.Common
   , VRFTiebreakerFlavor (..)
 
     -- * node support
+  , PraosCredentialsSource (..)
   , PraosNonces (..)
   , PraosProtocolSupportsNode (..)
+  , instantiatePraosCredentials
   ) where
 
+import qualified Cardano.Crypto.KES.Class as KES
+import Cardano.Crypto.VRF
 import qualified Cardano.Crypto.VRF as VRF
+import qualified Cardano.KESAgent.KES.Crypto as Agent
 import Cardano.Ledger.BaseTypes (Nonce)
 import qualified Cardano.Ledger.BaseTypes as SL
 import Cardano.Ledger.Binary (FromCBOR, ToCBOR)
-import Cardano.Ledger.Keys (KeyHash, KeyRole (BlockIssuer))
+import Cardano.Ledger.Keys (DSIGN, KeyHash, KeyRole (BlockIssuer))
 import qualified Cardano.Ledger.Shelley.API as SL
-import Cardano.Protocol.Crypto (Crypto, VRF)
+import Cardano.Protocol.Crypto (Crypto, KES, VRF)
 import qualified Cardano.Protocol.TPraos.OCert as OCert
 import Cardano.Slotting.Slot (SlotNo)
+import qualified Control.Tracer as Tracer
 import Data.Function (on)
 import Data.Map.Strict (Map)
 import Data.Ord (Down (Down))
+import Data.Void
 import Data.Word (Word64)
 import GHC.Generics (Generic)
-import NoThunks.Class (NoThunks)
+import NoThunks.Class
 import Ouroboros.Consensus.Protocol.Abstract
+import qualified Ouroboros.Consensus.Protocol.Ledger.HotKey as HotKey
+import Ouroboros.Consensus.Protocol.Praos.AgentClient
 
 -- | The maximum major protocol version.
 --
@@ -240,16 +254,64 @@ instance Crypto c => ChainOrder (PraosTiebreakerView c) where
   preferCandidate cfg ours cand = comparePraos cfg ours cand == LT
 
 data PraosCanBeLeader c = PraosCanBeLeader
-  { praosCanBeLeaderOpCert :: !(OCert.OCert c)
-  -- ^ Certificate delegating rights from the stake pool cold key (or
-  -- genesis stakeholder delegate cold key) to the online KES key.
-  , praosCanBeLeaderColdVerKey :: !(SL.VKey 'SL.BlockIssuer)
+  { praosCanBeLeaderColdVerKey :: !(SL.VKey 'SL.BlockIssuer)
   -- ^ Stake pool cold key or genesis stakeholder delegate cold key.
-  , praosCanBeLeaderSignKeyVRF :: !(VRF.SignKeyVRF (VRF c))
+  , praosCanBeLeaderSignKeyVRF :: !(SignKeyVRF (VRF c))
+  , praosCanBeLeaderCredentialsSource :: !(PraosCredentialsSource c)
+  -- ^ How to obtain KES credentials (ocert + sign key)
   }
   deriving Generic
 
-instance Crypto c => NoThunks (PraosCanBeLeader c)
+instance
+  (NoThunks (SignKeyVRF (VRF c)), NoThunks (KES.UnsoundPureSignKeyKES (KES c)), Crypto c) =>
+  NoThunks (PraosCanBeLeader c)
+
+-- | Defines a method for obtaining Praos credentials (opcert + KES signing
+-- key).
+data PraosCredentialsSource c where
+  -- | Pass an opcert and sign key directly. This uses
+  -- 'KES.UnsoundPureSignKeyKES', which does not provide mlocking guarantees,
+  -- violating the rule that KES secrets must never be stored on disk, but
+  -- allows the sign key to be loaded from a local file. This method is
+  -- provided for backwards compatibility.
+  PraosCredentialsUnsound ::
+    OCert.OCert c -> KES.UnsoundPureSignKeyKES (KES c) -> PraosCredentialsSource c
+  -- | Connect to a KES agent listening on a service socket at the given path.
+  PraosCredentialsAgent ::
+    Agent.DSIGN (ACrypto c) ~ DSIGN => Void -> FilePath -> PraosCredentialsSource c
+
+instance (NoThunks (KES.UnsoundPureSignKeyKES (KES c)), Crypto c) => NoThunks (PraosCredentialsSource c) where
+  wNoThunks ctxt = \case
+    PraosCredentialsUnsound oca k ->
+      allNoThunks
+        [ noThunks ctxt oca
+        , noThunks ctxt k
+        ]
+    PraosCredentialsAgent _ fp -> noThunks ctxt fp
+
+  showTypeOf _ = "PraosCredentialsSource"
+
+instantiatePraosCredentials ::
+  forall m c.
+  KESAgentContext c m =>
+  Word64 ->
+  Tracer.Tracer m KESAgentClientTrace ->
+  PraosCredentialsSource c ->
+  m (HotKey.HotKey c m)
+instantiatePraosCredentials maxKESEvolutions _ (PraosCredentialsUnsound ocert skUnsound) = do
+  sk <- KES.unsoundPureSignKeyKESToSoundSignKeyKES skUnsound
+  let startPeriod :: OCert.KESPeriod
+      startPeriod = OCert.ocertKESPeriod ocert
+
+  HotKey.mkHotKey
+    ocert
+    sk
+    startPeriod
+    maxKESEvolutions
+instantiatePraosCredentials maxKESEvolutions tr (PraosCredentialsAgent _ path) = do
+  HotKey.mkDynamicHotKey
+    maxKESEvolutions
+    (Just $ runKESAgentClient tr path)
 
 -- | See 'PraosProtocolSupportsNode'
 data PraosNonces = PraosNonces
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Header.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Header.hs
index dbb231805..00e6bf205 100644
--- a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Header.hs
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/Praos/Header.hs
@@ -2,9 +2,12 @@
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
 {-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
 {-# LANGUAGE NamedFieldPuns #-}
 {-# LANGUAGE PatternSynonyms #-}
 {-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE ViewPatterns #-}
 
 -- | Block header associated with Praos.
 --
@@ -42,7 +45,6 @@ import Cardano.Ledger.Binary
   , encodedSigKESSizeExpr
   , serialize'
   , unCBORGroup
-  , withSlice
   )
 import Cardano.Ledger.Binary.Coders
 import Cardano.Ledger.Binary.Crypto
@@ -56,18 +58,25 @@ import Cardano.Ledger.Hashes
   ( EraIndependentBlockBody
   , EraIndependentBlockHeader
   , HASH
+  , SafeToHash
+  , originalBytesSize
   )
 import Cardano.Ledger.Keys (KeyRole (BlockIssuer), VKey)
+import Cardano.Ledger.MemoBytes
+  ( Mem
+  , MemoBytes
+  , Memoized (..)
+  , getMemoRawType
+  , mkMemoized
+  )
 import Cardano.Protocol.Crypto (Crypto, KES, VRF)
 import Cardano.Protocol.TPraos.BHeader (PrevHash)
 import Cardano.Protocol.TPraos.OCert (OCert)
 import Cardano.Slotting.Block (BlockNo)
 import Cardano.Slotting.Slot (SlotNo)
-import qualified Data.ByteString as BS
-import qualified Data.ByteString.Lazy as BSL
 import Data.Word (Word32)
 import GHC.Generics (Generic)
-import NoThunks.Class (AllowThunksIn (..), NoThunks (..))
+import NoThunks.Class (NoThunks (..))
 import Ouroboros.Consensus.Protocol.Praos.VRF (InputVRF)
 
 -- | The body of the header is the part which gets hashed to form the hash
@@ -121,54 +130,31 @@ instance Crypto c => Eq (HeaderRaw c) where
     headerRawSig h1 == headerRawSig h2
       && headerRawBody h1 == headerRawBody h2
 
--- | Checks the binary representation first.
-instance Crypto c => Eq (Header c) where
-  h1 == h2 =
-    headerBytes h1 == headerBytes h2
-      && headerRaw h1 == headerRaw h2
-
 instance
   Crypto crypto =>
   NoThunks (HeaderRaw crypto)
 
 -- | Full header type, carrying its own memoised bytes.
-data Header crypto = HeaderConstr
-  { headerRaw :: !(HeaderRaw crypto)
-  , headerBytes :: BS.ByteString -- lazy on purpose, constructed on demand
-  }
-  deriving (Show, Generic)
-  deriving NoThunks via AllowThunksIn '["headerBytes"] (Header crypto)
+newtype Header crypto = HeaderConstr (MemoBytes (HeaderRaw crypto))
+  deriving Generic
+  deriving newtype (Eq, Show, NoThunks, Plain.ToCBOR, SafeToHash)
+
+instance Memoized (Header crypto) where
+  type RawType (Header crypto) = HeaderRaw crypto
 
 pattern Header ::
   Crypto crypto =>
   HeaderBody crypto ->
   KES.SignedKES (KES crypto) (HeaderBody crypto) ->
   Header crypto
-pattern Header{headerBody, headerSig} <-
-  HeaderConstr
-    { headerRaw =
-      HeaderRaw
-        { headerRawBody = headerBody
-        , headerRawSig = headerSig
-        }
-    }
+pattern Header{headerBody, headerSig} <- (getMemoRawType -> HeaderRaw headerBody headerSig)
   where
-    Header body sig =
-      let header =
-            HeaderRaw
-              { headerRawBody = body
-              , headerRawSig = sig
-              }
-       in HeaderConstr
-            { headerRaw = header
-            , headerBytes = serialize' (pvMajor (hbProtVer body)) header
-            }
-
+    Header body sig = mkMemoized (pvMajor (hbProtVer body)) $ HeaderRaw body sig
 {-# COMPLETE Header #-}
 
 -- | Compute the size of the header
 headerSize :: Header crypto -> Int
-headerSize (HeaderConstr _ bytes) = BS.length bytes
+headerSize = originalBytesSize
 
 -- | Hash a header
 headerHash ::
@@ -239,16 +225,13 @@ instance Crypto crypto => DecCBOR (HeaderRaw crypto) where
 instance Crypto crypto => DecCBOR (Annotator (HeaderRaw crypto)) where
   decCBOR = pure <$> decCBOR
 
-instance Crypto c => Plain.ToCBOR (Header c) where
-  toCBOR (HeaderConstr _ bytes) = Plain.encodePreEncoded bytes
-
 instance Crypto c => EncCBOR (Header c) where
   encodedSizeExpr size proxy =
     1
-      + encodedSizeExpr size (headerRawBody . headerRaw <$> proxy)
-      + encodedSigKESSizeExpr (KES.getSig . headerRawSig . headerRaw <$> proxy)
+      + encodedSizeExpr size (headerBody <$> proxy)
+      + encodedSigKESSizeExpr (KES.getSig . headerSig <$> proxy)
 
-instance Crypto c => DecCBOR (Annotator (Header c)) where
-  decCBOR = do
-    (Annotator getT, Annotator getBytes) <- withSlice decCBOR
-    pure (Annotator (\fullbytes -> HeaderConstr (getT fullbytes) (BSL.toStrict (getBytes fullbytes))))
+deriving via
+  Mem (HeaderRaw crypto)
+  instance
+    Crypto crypto => DecCBOR (Annotator (Header crypto))
diff --git a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/TPraos.hs b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/TPraos.hs
index 103dcad8e..478ce19b1 100644
--- a/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/TPraos.hs
+++ b/ouroboros-consensus-protocol/src/ouroboros-consensus-protocol/Ouroboros/Consensus/Protocol/TPraos.hs
@@ -142,23 +142,22 @@ forgeTPraosFields ::
   (TPraosToSign c -> toSign) ->
   m (TPraosFields c toSign)
 forgeTPraosFields hotKey PraosCanBeLeader{..} TPraosIsLeader{..} mkToSign = do
+  ocert <- HotKey.getOCert hotKey
+  let signedFields =
+        TPraosToSign
+          { tpraosToSignIssuerVK = praosCanBeLeaderColdVerKey
+          , tpraosToSignVrfVK = VRF.deriveVerKeyVRF praosCanBeLeaderSignKeyVRF
+          , tpraosToSignEta = tpraosIsLeaderEta
+          , tpraosToSignLeader = tpraosIsLeaderProof
+          , tpraosToSignOCert = ocert
+          }
+      toSign = mkToSign signedFields
   signature <- HotKey.sign hotKey toSign
   return
     TPraosFields
       { tpraosSignature = signature
       , tpraosToSign = toSign
       }
- where
-  toSign = mkToSign signedFields
-
-  signedFields =
-    TPraosToSign
-      { tpraosToSignIssuerVK = praosCanBeLeaderColdVerKey
-      , tpraosToSignVrfVK = VRF.deriveVerKeyVRF praosCanBeLeaderSignKeyVRF
-      , tpraosToSignEta = tpraosIsLeaderEta
-      , tpraosToSignLeader = tpraosIsLeaderProof
-      , tpraosToSignOCert = praosCanBeLeaderOpCert
-      }
 
 -- | Because we are using the executable spec, rather than implementing the
 -- protocol directly here, we have a fixed header type rather than an
diff --git a/ouroboros-consensus/CHANGELOG.md b/ouroboros-consensus/CHANGELOG.md
index 9af79de26..3cbb62c14 100644
--- a/ouroboros-consensus/CHANGELOG.md
+++ b/ouroboros-consensus/CHANGELOG.md
@@ -2,6 +2,137 @@
 
 # Changelog entries
 
+<a id='changelog-0.28.0.0'></a>
+## 0.28.0.0 -- 2025-09-29
+
+### Patch
+
+- Changed ChainSel to reprocess LoE-delayed blocks even when LoE is disabled.
+
+- Changed GDD to trigger chain selection when caught-up. In certain edge cases,
+  this enables the node to promptly select a better chain right after concluding
+  that it is caught-up.
+
+- Changed the V2 LedgerDB `LedgerTablesHandle`s to actually be closed in all
+  cases. With the current (only) backend (in-memory), this doesn't matter, but
+  on-disk backends (like LSM trees) need this.
+
+- Fix serialization of `TriggerHardForkNotDuringThisExecution`.
+
+- LedgerDB.V2: prevent race condition when creating snapshots.
+
+- The backing store of the V1 LedgerDB was only tracked in the
+  resource registry if we were starting from Genesis. Now the backing
+  store will be properly tracked in the resource registry even when we
+  start from a snapshot.
+
+- Closing the LedgerDB will no longer release all the open forkers,
+  but instead invalidate them by emptying the ldbForkers map, so that
+  the only possible operation that could be performed is closing them
+  in the LedgerDB clients, such as ChainSel or the forging loop.
+
+- Closing the forker is idempotent, and it was performed both when
+  calling `forkerClose` as well as when the resource registry of the
+  LedgerDB client was going out of scope. Now, `forkerClose` will
+  release the resource from the registry so this won't run twice.
+
+- The mempool will now carry its own forker instead of acquiring one on each
+  revalidation. This particularly implies that the mempool will no longer
+  re-sync under the hood while trying to add a transaction, and only the
+  background thread will perform such a re-sync.
+
+- The mempool now has its own registry in which it allocates forkers. The
+  background thread was moved to this inner registry such that it can access the
+  mempool internal registry, but an action to cancel it will still live in the
+  outer registry, to ensure the thread is closed before we attempt to close the
+  mempool internal registry. Otherwise we would run into a race condition if the
+  background thread would attempt a resync while the internal registry was being
+  closed.
+
+- Changed ChainSel reprocessing of blocks postponed by the Limited of Eagerness
+  (Genesis), which in particular should be more efficient.
+
+### Non-Breaking
+
+- Only open BackingStore ValueHandles in V1 when we perform a UTxO operation.
+
+- Support `NodeToClientV_22`.
+- Using `io-classes-1.8.0.1`
+
+- Ensure uncommitted forkers do not leak Ledger tables handles.
+
+- Gate `NoThunks` invariant checks behind the `expensive-invariants` build to allow for:
+  + No invariant checking in production
+  + Cheap (domain-specific) invariant checking in regular CI
+  + Cheap and expensive invariant checking in nightly CI
+
+### Breaking
+
+- Use new mlocked KES API to represent KES sign keys internally. This ensures
+  that KES keys are securely erased when replaced with a newer evolution or a
+  fresh key, and that they will not spill to disk or swap. See
+  https://github.com/IntersectMBO/cardano-base/pull/255.
+- Add `finalize` method to `BlockForging`, and use it where necessary to clean
+  up when a block forging thread terminates (see `forkLinkedWatcherFinalize`)
+
+- LedgerDB: added new trace events (enabling new tests).
+
+- Delete `Ouroboros.Consensus.HardFork.Combinator.Compat`
+
+- ChainDB internals: changed type of `FollowerHandle.fhSwitchFork`.
+
+- Removed `getLedgerTablesAtFor` from the ChainDB API. Clients now have to
+  actually open a forker and manage it.
+
+- Changed pruning of immutable ledger states to happen on LedgerDB garbage
+  collection instead of directly on every block adoption. This is purely an
+  internal refactoring (with breaking API changes) supporting predictable ledger
+  snapshotting.
+
+- Avoid maintaining volatile ledger states during ledger replay, making it
+  slightly more efficient.
+
+- Changed `SelectView` to be a data type instead of an associated type of
+  `ConsensusProtocol`, which is the combination of a `BlockNo` and a
+  `TiebreakerView`, which is a new associated type of `ConsensusProtocol`. This
+  makes it explicit that `ouroboros-consensus` is targeting longest chain
+  protocols.
+
+  - Removed `PBftSelectView`, use `SelectView PBft` instead.
+
+  - Removed `HardForkSelectView`, use `SelectView (HardForkProtocol xs)` instead.
+
+- Changed `AddedReprocessLoEBlocksToQueue` to take an `Enclosing' Word` (the queue size), just like `AddedBlockToQueue`.
+
+- `PoppedBlockFromQueue` no longer takes an `Enclosing`. `PoppedBlockFromQueue RisingEdge` is replaced by `PoppingFromQueue`.
+
+- Using `LedgerRelayAccessPoint` rather than `RelayAccessPoint` in `Ouroboros.Consensus.Ledger.SupportsPeerSelection`.
+
+- Changed `SelectionChangedInfo.newTipTrigger` (contained in tracing types) to
+  be a `Maybe` to accurately reflect Ouroboros Genesis-related (Limit on
+  Eagerness) triggered chain selection.
+
+- Renamed `IgnoreBlockOlderThanK` to `IgnoreBlockOlderThanImmTip` for future-proofing.
+- Renamed and simplified `olderThanK` to `olderThanImmTip`.
+
+- LedgerDB: generalized over the criterion used to determine which states are
+  volatile/immutable, in preparation for Ouroboros Peras.
+
+  Concretely, `LedgerDB.openDB` takes a new argument, `GetVolatileSuffix m blk`.
+  For Praos behavior, use `praosGetVolatileSuffix`.
+
+- `forkerRangeRead` now returns also the maximal key found in the backend.
+
+- Group snapshot management functions in the new datatype `SnapshotManager`.
+
+- Delete `LedgerSupportsOnDiskLedgerDB` constraint and created `LedgerSupports(V1|V2)LedgerDB`.
+
+- Introduce `Ouroboros.Consensus.Block.SupportsPeras` with types related to Peras.
+  - All new types are re-exported through `Ouroboros.Consensus.Block`.
+- Introduce `Ouroboros.Consensus.Peras.Weight` with weight computation related types and functions for chains and fragments.
+- Introduce a new benchmark suite `PerasCertDB-bench`
+- Add property tests and benchmarks for weight computation on chain and fragments
+
 <a id='changelog-0.27.0.0'></a>
 ## 0.27.0.0 -- 2025-05-15
 
diff --git a/ouroboros-consensus/bench/PerasCertDB-bench/Main.hs b/ouroboros-consensus/bench/PerasCertDB-bench/Main.hs
new file mode 100644
index 000000000..e2fe35490
--- /dev/null
+++ b/ouroboros-consensus/bench/PerasCertDB-bench/Main.hs
@@ -0,0 +1,134 @@
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE ImportQualifiedPost #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE TypeApplications #-}
+
+-- | This module contains benchmarks for Peras chain weight calculation as
+--   implemented in the 'Ouroboros.Consensus.Peras.Weight' module.
+--
+--   We benchmark the calculation on a static sequence of chain fragments of
+--   increasing length, ranging from 0 to 'fragmentMaxLength', with a step size
+--   of 'fragmentLengthStepSize'. The chain fragments are instantiated with
+--   'TestBlock', and every 'boostedBlockGap' blocks there is a booster block
+--   with weight 'boostWeight'. All parameters are set in 'benchmarkParams'.
+module Main (main) where
+
+import Cardano.Ledger.BaseTypes.NonZero (knownNonZeroBounded)
+import Data.List (iterate')
+import Data.Word (Word64)
+import Numeric.Natural (Natural)
+import Ouroboros.Consensus.Block (PerasWeight (PerasWeight), SlotNo (..))
+import Ouroboros.Consensus.Config.SecurityParam
+import Ouroboros.Consensus.Peras.Weight
+  ( PerasWeightSnapshot
+  , mkPerasWeightSnapshot
+  , takeVolatileSuffix
+  , weightBoostOfFragment
+  )
+import Ouroboros.Network.AnchoredFragment qualified as AF
+import Test.Ouroboros.Storage.TestBlock (TestBlock (..), TestBody (..), TestHeader (..))
+import Test.Ouroboros.Storage.TestBlock qualified as TestBlock
+import Test.Tasty.Bench
+
+data BenchmarkParams = BenchmarkParams
+  { slotGap :: Word64
+  -- ^ The slot gap between blocks on the fragments, ie the inverse of the
+  -- active slot coefficient. Measured in slots.
+  , fragmentLengthStepSize :: Natural
+  -- ^ Step size for the fragment lengths between different benchmarks, in
+  -- blocks.
+  , fragmentMaxLength :: Natural
+  -- ^ The maximum length of a fragment, in blocks.
+  , boostedBlockGap :: Natural
+  -- ^ How often boosted blocks occur, in blocks.
+  , boostWeight :: PerasWeight
+  -- ^ The weight of the boost.
+  }
+
+benchmarkParams :: BenchmarkParams
+benchmarkParams =
+  BenchmarkParams
+    { -- On Cardano mainnet, the active slot coefficient f=1/20, so there are 20
+      -- slots between blocks on average assuming nominal chain density.
+      slotGap = 20
+    , -- Represents a decent balance between the number of benchmarks we run and
+      -- the granularity at which we can observe results.
+      fragmentLengthStepSize = 100
+    , -- This is the maximum size of header fragments while syncing (the current
+      -- selection (k) plus one forecast window under nominal chain density
+      -- (3k), where k=2160 on Cardano mainnet).
+      fragmentMaxLength = 2160 + 3 * 2160
+    , -- A plausible value for the Peras round length is 90 slots, which means
+      -- that we expect to see 4-5 blocks per Peras round (and therefore between
+      -- boosted blocks) on mainnet where the active slot coefficient f=1/20.
+      boostedBlockGap = 5
+    , -- This is a plausible mainnet value (the exact value does not impact the
+      -- benchmark).
+      boostWeight = PerasWeight 15
+    }
+
+main :: IO ()
+main =
+  Test.Tasty.Bench.defaultMain $
+    concat
+      [ map benchWeightBoostOfFragment inputs
+      , map benchTakeVolatileSuffix inputs
+      ]
+ where
+  -- NOTE: we do not use the 'env' combinator to set up the test data since
+  --       it requires 'NFData' for 'AF.AnchoredFragment'. While the necessary
+  --       instances could be provided, we do not think is necessary for this
+  --       benchmark, as the input data is rather small.
+  inputs :: [(Natural, (PerasWeightSnapshot TestBlock, AF.AnchoredFragment TestBlock))]
+  inputs =
+    getEveryN (fragmentLengthStepSize benchmarkParams) $
+      take (fromIntegral $ fragmentMaxLength benchmarkParams) $
+        zip [0 ..] $
+          zip (map uniformWeightSnapshot fragments) fragments
+
+benchWeightBoostOfFragment ::
+  (Natural, (PerasWeightSnapshot TestBlock, AF.AnchoredFragment TestBlock)) -> Benchmark
+benchWeightBoostOfFragment (i, (weightSnapshot, fragment)) =
+  bench ("weightBoostOfFragment of length " <> show i) $
+    whnf (weightBoostOfFragment weightSnapshot) fragment
+
+benchTakeVolatileSuffix ::
+  (Natural, (PerasWeightSnapshot TestBlock, AF.AnchoredFragment TestBlock)) -> Benchmark
+benchTakeVolatileSuffix (i, (weightSnapshot, fragment)) =
+  bench ("takeVolatileSuffix of length " <> show i) $
+    whnf (takeVolatileSuffix weightSnapshot k) fragment
+ where
+  k = SecurityParam $ knownNonZeroBounded @2160
+
+-- | An infinite list of chain fragments
+fragments :: [AF.AnchoredFragment TestBlock]
+fragments = iterate' addSuccessorBlock genesisFragment
+ where
+  genesisFragment :: AF.AnchoredFragment TestBlock
+  genesisFragment = AF.Empty AF.AnchorGenesis
+
+  addSuccessorBlock :: AF.AnchoredFragment TestBlock -> AF.AnchoredFragment TestBlock
+  addSuccessorBlock = \case
+    AF.Empty _ -> (AF.Empty AF.AnchorGenesis) AF.:> (TestBlock.firstBlock 0 dummyBody)
+    (xs AF.:> x) ->
+      let nextBlockSlot = SlotNo (slotGap benchmarkParams) + thSlotNo (testHeader x)
+       in (xs AF.:> x) AF.:> TestBlock.mkNextBlock x nextBlockSlot dummyBody
+
+  dummyBody :: TestBody
+  dummyBody = TestBody{tbForkNo = 0, tbIsValid = True}
+
+-- | Given a chain fragment, construct a weight snapshot where there's a boosted block every 90 slots
+uniformWeightSnapshot :: AF.AnchoredFragment TestBlock -> PerasWeightSnapshot TestBlock
+uniformWeightSnapshot fragment =
+  let pointsToBoost =
+        map snd
+          . getEveryN (boostedBlockGap benchmarkParams)
+          . zip [0 ..]
+          . map AF.blockPoint
+          . AF.toOldestFirst
+          $ fragment
+      weights = repeat (boostWeight benchmarkParams)
+   in mkPerasWeightSnapshot $ pointsToBoost `zip` weights
+
+getEveryN :: Natural -> [(Natural, a)] -> [(Natural, a)]
+getEveryN n = filter (\(i, _) -> (i `mod` n) == 0)
diff --git a/ouroboros-consensus/changelog.d/20250512_164809_alexander.esgen_genesis_caughtup_final_chainsel.md b/ouroboros-consensus/changelog.d/20250512_164809_alexander.esgen_genesis_caughtup_final_chainsel.md
deleted file mode 100644
index fcc32d2ff..000000000
--- a/ouroboros-consensus/changelog.d/20250512_164809_alexander.esgen_genesis_caughtup_final_chainsel.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Patch
-
-- Changed ChainSel to reprocess LoE-delayed blocks even when LoE is disabled.
diff --git a/ouroboros-consensus/changelog.d/20250512_165110_alexander.esgen_genesis_caughtup_final_chainsel.md b/ouroboros-consensus/changelog.d/20250512_165110_alexander.esgen_genesis_caughtup_final_chainsel.md
deleted file mode 100644
index f5add4eaf..000000000
--- a/ouroboros-consensus/changelog.d/20250512_165110_alexander.esgen_genesis_caughtup_final_chainsel.md
+++ /dev/null
@@ -1,5 +0,0 @@
-### Patch
-
-- Changed GDD to trigger chain selection when caught-up. In certain edge cases,
-  this enables the node to promptly select a better chain right after concluding
-  that it is caught-up.
diff --git a/ouroboros-consensus/changelog.d/20250519_193751_alexander.esgen_v2_ledgerseq_close.md b/ouroboros-consensus/changelog.d/20250519_193751_alexander.esgen_v2_ledgerseq_close.md
deleted file mode 100644
index a79a6c45d..000000000
--- a/ouroboros-consensus/changelog.d/20250519_193751_alexander.esgen_v2_ledgerseq_close.md
+++ /dev/null
@@ -1,5 +0,0 @@
-### Patch
-
-- Changed the V2 LedgerDB `LedgerTablesHandle`s to actually be closed in all
-  cases. With the current (only) backend (in-memory), this doesn't matter, but
-  on-disk backends (like LSM trees) need this.
diff --git a/ouroboros-consensus/changelog.d/20250528_135650_alexander.esgen_v2_ledgerseq_close.md b/ouroboros-consensus/changelog.d/20250528_135650_alexander.esgen_v2_ledgerseq_close.md
deleted file mode 100644
index 42c50933f..000000000
--- a/ouroboros-consensus/changelog.d/20250528_135650_alexander.esgen_v2_ledgerseq_close.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Breaking
-
-- LedgerDB: added new trace events (enabling new tests).
diff --git a/ouroboros-consensus/changelog.d/20250528_160421_javier.sagredo.md b/ouroboros-consensus/changelog.d/20250528_160421_javier.sagredo.md
deleted file mode 100644
index fc082205f..000000000
--- a/ouroboros-consensus/changelog.d/20250528_160421_javier.sagredo.md
+++ /dev/null
@@ -1,22 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Delete `Ouroboros.Consensus.HardFork.Combinator.Compat`
diff --git a/ouroboros-consensus/changelog.d/20250602_100145_alexander.esgen_small_opts.md b/ouroboros-consensus/changelog.d/20250602_100145_alexander.esgen_small_opts.md
deleted file mode 100644
index 21de64fa2..000000000
--- a/ouroboros-consensus/changelog.d/20250602_100145_alexander.esgen_small_opts.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Breaking
-
-- ChainDB internals: changed type of `FollowerHandle.fhSwitchFork`.
diff --git a/ouroboros-consensus/changelog.d/20250610_172615_alexander.esgen_ledgerdb_v2_locking.md b/ouroboros-consensus/changelog.d/20250610_172615_alexander.esgen_ledgerdb_v2_locking.md
deleted file mode 100644
index f52e831ce..000000000
--- a/ouroboros-consensus/changelog.d/20250610_172615_alexander.esgen_ledgerdb_v2_locking.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Patch
-
-- LedgerDB.V2: prevent race condition when creating snapshots.
diff --git a/ouroboros-consensus/changelog.d/20250617_113413_javier.sagredo_only_vh_second_try.md b/ouroboros-consensus/changelog.d/20250617_113413_javier.sagredo_only_vh_second_try.md
deleted file mode 100644
index 367f93846..000000000
--- a/ouroboros-consensus/changelog.d/20250617_113413_javier.sagredo_only_vh_second_try.md
+++ /dev/null
@@ -1,24 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-<!--
-### Patch
-
-- A bullet item for the Patch category.
-
--->
-
-### Non-Breaking
-
-- Only open BackingStore ValueHandles in V1 when we perform a UTxO operation.
-
-
-<!--
-### Breaking
-
-- A bullet item for the Breaking category.
-
--->
diff --git a/ouroboros-consensus/changelog.d/20250617_173548_javier.sagredo_remove_forkers_resource_reg.md b/ouroboros-consensus/changelog.d/20250617_173548_javier.sagredo_remove_forkers_resource_reg.md
deleted file mode 100644
index a0b8f107f..000000000
--- a/ouroboros-consensus/changelog.d/20250617_173548_javier.sagredo_remove_forkers_resource_reg.md
+++ /dev/null
@@ -1,32 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
--->
-
-### Patch
-
-- The backing store of the V1 LedgerDB was only tracked in the
-  resource registry if we were starting from Genesis. Now the backing
-  store will be properly tracked in the resource registry even when we
-  start from a snapshot.
-
-- Closing the LedgerDB will no longer release all the open forkers,
-  but instead invalidate them by emptying the ldbForkers map, so that
-  the only possible operation that could be performed is closing them
-  in the LedgerDB clients, such as ChainSel or the forging loop.
-
-- Closing the forker is idempotent, and it was performed both when
-  calling `forkerClose` as well as when the resource registry of the
-  LedgerDB client was going out of scope. Now, `forkerClose` will
-  release the resource from the registry so this won't run twice.
-
-<!--
-### Non-Breaking
--->
-<!--
-### Breaking
-
-- A bullet item for the Breaking category.
-
--->
diff --git a/ouroboros-consensus/changelog.d/20250620_132627_jasataco_mempool_carry_vh.md b/ouroboros-consensus/changelog.d/20250620_132627_jasataco_mempool_carry_vh.md
deleted file mode 100644
index 2d6d63d60..000000000
--- a/ouroboros-consensus/changelog.d/20250620_132627_jasataco_mempool_carry_vh.md
+++ /dev/null
@@ -1,33 +0,0 @@
-<!--
-A new scriv changelog fragment.
-
-Uncomment the section that is right (remove the HTML comment wrapper).
-For top level release notes, leave all the headers commented out.
--->
-
-### Patch
-
-- The mempool will now carry its own forker instead of acquiring one on each
-  revalidation. This particularly implies that the mempool will no longer
-  re-sync under the hood while trying to add a transaction, and only the
-  background thread will perform such a re-sync.
-
-- The mempool now has its own registry in which it allocates forkers. The
-  background thread was moved to this inner registry such that it can access the
-  mempool internal registry, but an action to cancel it will still live in the
-  outer registry, to ensure the thread is closed before we attempt to close the
-  mempool internal registry. Otherwise we would run into a race condition if the
-  background thread would attempt a resync while the internal registry was being
-  closed.
-
-<!--
-### Non-Breaking
-
-- A bullet item for the Non-Breaking category.
-
--->
-
-### Breaking
-
-- Removed `getLedgerTablesAtFor` from the ChainDB API. Clients now have to
-  actually open a forker and manage it.
diff --git a/ouroboros-consensus/changelog.d/20250626_193647_alexander.esgen_ledgerdb_garbage_collect_states.md b/ouroboros-consensus/changelog.d/20250626_193647_alexander.esgen_ledgerdb_garbage_collect_states.md
deleted file mode 100644
index 9dfb07f31..000000000
--- a/ouroboros-consensus/changelog.d/20250626_193647_alexander.esgen_ledgerdb_garbage_collect_states.md
+++ /dev/null
@@ -1,9 +0,0 @@
-### Breaking
-
-- Changed pruning of immutable ledger states to happen on LedgerDB garbage
-  collection instead of directly on every block adoption. This is purely an
-  internal refactoring (with breaking API changes) supporting predictable ledger
-  snapshotting.
-
-- Avoid maintaining volatile ledger states during ledger replay, making it
-  slightly more efficient.
diff --git a/ouroboros-consensus/changelog.d/20250716_190237_alexander.esgen_tiebreaker_view.md b/ouroboros-consensus/changelog.d/20250716_190237_alexander.esgen_tiebreaker_view.md
deleted file mode 100644
index b4ade496d..000000000
--- a/ouroboros-consensus/changelog.d/20250716_190237_alexander.esgen_tiebreaker_view.md
+++ /dev/null
@@ -1,11 +0,0 @@
-### Breaking
-
-- Changed `SelectView` to be a data type instead of an associated type of
-  `ConsensusProtocol`, which is the combination of a `BlockNo` and a
-  `TiebreakerView`, which is a new associated type of `ConsensusProtocol`. This
-  makes it explicit that `ouroboros-consensus` is targeting longest chain
-  protocols.
-
-  - Removed `PBftSelectView`, use `SelectView PBft` instead.
-
-  - Removed `HardForkSelectView`, use `SelectView (HardForkProtocol xs)` instead.
diff --git a/ouroboros-consensus/changelog.d/20250721_172317_alexander.esgen_chaindb_loe_trigger_opt.md b/ouroboros-consensus/changelog.d/20250721_172317_alexander.esgen_chaindb_loe_trigger_opt.md
deleted file mode 100644
index 7861da51d..000000000
--- a/ouroboros-consensus/changelog.d/20250721_172317_alexander.esgen_chaindb_loe_trigger_opt.md
+++ /dev/null
@@ -1,4 +0,0 @@
-### Patch
-
-- Changed ChainSel reprocessing of blocks postponed by the Limited of Eagerness
-  (Genesis), which in particular should be more efficient.
diff --git a/ouroboros-consensus/changelog.d/20250723_161826_alexander.esgen_minor_chaindb_stuff.md b/ouroboros-consensus/changelog.d/20250723_161826_alexander.esgen_minor_chaindb_stuff.md
deleted file mode 100644
index 29ef8b44e..000000000
--- a/ouroboros-consensus/changelog.d/20250723_161826_alexander.esgen_minor_chaindb_stuff.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Breaking
-
-- Changed `AddedReprocessLoEBlocksToQueue` to take an `Enclosing' Word` (the queue size), just like `AddedBlockToQueue`.
diff --git a/ouroboros-consensus/changelog.d/20250723_161939_alexander.esgen_minor_chaindb_stuff.md b/ouroboros-consensus/changelog.d/20250723_161939_alexander.esgen_minor_chaindb_stuff.md
deleted file mode 100644
index 36bb55e97..000000000
--- a/ouroboros-consensus/changelog.d/20250723_161939_alexander.esgen_minor_chaindb_stuff.md
+++ /dev/null
@@ -1,3 +0,0 @@
-### Breaking
-
-- `PoppedBlockFromQueue` no longer takes an `Enclosing`. `PoppedBlockFromQueue RisingEdge` is replaced by `PoppingFromQueue`.
diff --git a/ouroboros-consensus/changelog.d/20250728_120728_coot_cardano_diffusion_integration.md b/ouroboros-consensus/changelog.d/20250728_120728_coot_cardano_diffusion_integration.md
deleted file mode 100644
index eb707ab7b..000000000
--- a/ouroboros-consensus/changelog.d/20250728_120728_coot_cardano_diffusion_integration.md
+++ /dev/null
@@ -1,9 +0,0 @@
-### Non-Breaking
-
-- Support `NodeToClientV_22`.
-- Using `io-classes-1.8.0.1`
-
-### Breaking
-
-- Using `LedgerRelayAccessPoint` rather than `RelayAccessPoint` in `Ouroboros.Consensus.Ledger.SupportsPeerSelection`.
-
diff --git a/ouroboros-consensus/changelog.d/20250729_124008_javier.sagredo_lsm1.md b/ouroboros-consensus/changelog.d/20250729_124008_javier.sagredo_lsm1.md
new file mode 100644
index 000000000..2ad1d8ab2
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20250729_124008_javier.sagredo_lsm1.md
@@ -0,0 +1,27 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+### Breaking
+
+- Implement LSM-trees backend for LedgerDB V2 handles.
+- Define new `LedgerDbBackendArgs` that will be provided by the node.
+- Drop `Eq (Ouroboros.Consensus.Storage.ChainDb.Impl.Types.TraceEvent blk)` instance.
+- Delete unused `Ouroboros.Consensus.Storage.LedgerDB.V1.Args.defaultLedgerDbFlavorArgs`.
+- LedgerDB V2 forker reading functions now also receive a LedgerState to deserialize values from LSM trees.
+- Expose `indexedPackByteArray` and define new `indexedUnpack` mirroring `unpack` from the `mempack` package.
diff --git a/ouroboros-consensus/changelog.d/20250801_172359_alexander.esgen_chainsel_fix_transient_loe.md b/ouroboros-consensus/changelog.d/20250801_172359_alexander.esgen_chainsel_fix_transient_loe.md
deleted file mode 100644
index 8d44f41f8..000000000
--- a/ouroboros-consensus/changelog.d/20250801_172359_alexander.esgen_chainsel_fix_transient_loe.md
+++ /dev/null
@@ -1,5 +0,0 @@
-### Breaking
-
-- Changed `SelectionChangedInfo.newTipTrigger` (contained in tracing types) to
-  be a `Maybe` to accurately reflect Ouroboros Genesis-related (Limit on
-  Eagerness) triggered chain selection.
diff --git a/ouroboros-consensus/changelog.d/20250811_130239_alexander.esgen_decouple_immutability.md b/ouroboros-consensus/changelog.d/20250811_130239_alexander.esgen_decouple_immutability.md
deleted file mode 100644
index 43ecf32dc..000000000
--- a/ouroboros-consensus/changelog.d/20250811_130239_alexander.esgen_decouple_immutability.md
+++ /dev/null
@@ -1,4 +0,0 @@
-### Breaking
-
-- Renamed `IgnoreBlockOlderThanK` to `IgnoreBlockOlderThanImmTip` for future-proofing.
-- Renamed and simplified `olderThanK` to `olderThanImmTip`.
diff --git a/ouroboros-consensus/changelog.d/20250811_150947_alexander.esgen_decouple_immutability.md b/ouroboros-consensus/changelog.d/20250811_150947_alexander.esgen_decouple_immutability.md
deleted file mode 100644
index c48e80ce5..000000000
--- a/ouroboros-consensus/changelog.d/20250811_150947_alexander.esgen_decouple_immutability.md
+++ /dev/null
@@ -1,7 +0,0 @@
-### Breaking
-
-- LedgerDB: generalized over the criterion used to determine which states are
-  volatile/immutable, in preparation for Ouroboros Peras.
-
-  Concretely, `LedgerDB.openDB` takes a new argument, `GetVolatileSuffix m blk`.
-  For Praos behavior, use `praosGetVolatileSuffix`.
diff --git a/ouroboros-consensus/changelog.d/20250829_100724_agustin.mista_expensive_invariants_flag.md b/ouroboros-consensus/changelog.d/20250829_100724_agustin.mista_expensive_invariants_flag.md
deleted file mode 100644
index 96580899b..000000000
--- a/ouroboros-consensus/changelog.d/20250829_100724_agustin.mista_expensive_invariants_flag.md
+++ /dev/null
@@ -1,6 +0,0 @@
-### Non-Breaking
-
-- Gate `NoThunks` invariant checks behind the `expensive-invariants` build to allow for:
-  + No invariant checking in production
-  + Cheap (domain-specific) invariant checking in regular CI
-  + Cheap and expensive invariant checking in nightly CI
diff --git a/ouroboros-consensus/changelog.d/20250917_101832_thomas.bagrel_peras_cert_db.md b/ouroboros-consensus/changelog.d/20250917_101832_thomas.bagrel_peras_cert_db.md
new file mode 100644
index 000000000..41170c18b
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20250917_101832_thomas.bagrel_peras_cert_db.md
@@ -0,0 +1,24 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Add modules `Ouroboros.Consensus.Storage.PerasCertDB{,.API,.Impl}`, notably defining the types`PerasCertDB`, `PerasCertSnapshot` (read-only snapshot of certs contained in the DB), and `AddPerasCertResult`; alongside their respective methods
+- Add modules `Test.Ouroboros.Storage.PerasCertDB{,.StateMachine,.Model}` for q-s-m testing of the `PerasCertDB` datatype. The corresponding tests are included in the test suite defined by `Test.Ouroboros.Storage`
diff --git a/ouroboros-consensus/changelog.d/20250917_144846_nicolas.bacquey_weighted_chain_selec.md b/ouroboros-consensus/changelog.d/20250917_144846_nicolas.bacquey_weighted_chain_selec.md
new file mode 100644
index 000000000..f9225fa24
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20250917_144846_nicolas.bacquey_weighted_chain_selec.md
@@ -0,0 +1,7 @@
+### Breaking
+
+- Make the `ChainDB` aware of the `PerasCertDB`, and modify the chain selection function accordingly. In practice, it means that the candidate fragment is now selected based on its Peras weight, instead of its length.
+
+  Note that if Peras is disabled (which is the default), there is no observable difference.
+
+- Add module `Ouroboros.Consensus.Peras.SelectView`, which introduces a `WeightedSelectView` to correctly measure the length of a chain fragment.
diff --git a/ouroboros-consensus/changelog.d/20250918_104810_thomas.bagrel_object_diffusion.md b/ouroboros-consensus/changelog.d/20250918_104810_thomas.bagrel_object_diffusion.md
new file mode 100644
index 000000000..fba0bcc16
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20250918_104810_thomas.bagrel_object_diffusion.md
@@ -0,0 +1,28 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Relies on a new version of `ouroboros-network` with support for ObjectDiffusion mini-protocol
+- Added modules `Ouroboros.Consensus.MiniProtocol.ObjectDiffusion{.Inbound,.Outbound}` with implementations of the ObjectDiffusion protocol (quite similar/inspired from TX-submission, except that client = inbound, server = outbound)
+- Added module `Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API` defining `ObjectPool{Reader,Writer}` interfaces, through which ObjectDiffusion accesses/stores the objects to send/that have been received.
+- Added modules `Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert` and `Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.PerasCert` containing definitions specific to `PerasCert` diffusion through the ObjectDiffusion mini-protocol 
+- Modifies `Ouroboros.Consensus.Node.Serialisation` to add CBOR serialisation (`SerialiseNodeToNode`) for `Point blk`, `Tip blk`, and  `PerasCert blk`
+- Added modules `Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke` and `Test.Consensus.MiniProtocol.ObjectDiffusion.PerasCert.Smoke` with smoke tests for the general ObjectDiffusion mini-protocol and for the `PerasCert`-specific instance of it
diff --git a/ouroboros-consensus/changelog.d/20250918_114333_thomas.bagrel_hfc_era_peras.md b/ouroboros-consensus/changelog.d/20250918_114333_thomas.bagrel_hfc_era_peras.md
new file mode 100644
index 000000000..912fa1517
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20250918_114333_thomas.bagrel_hfc_era_peras.md
@@ -0,0 +1,36 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Changes in the HFC types:
+  - `EraParams` now keeps track of an optional Peras round length.
+  - `Bound` now keeps track of an optional Peras round number.
+  - In the `Serialise` instances for `EraParams` and `Bound`, the encoders generate different CBOR depending on whether of not the Peras-relate components are present. The decoders act differently depending on the length of the CBOR list.
+- Changes in the HFC time translation queries:
+  - Two new top-level queries are exposed from `Ouroboros.Consensus.HardFork.History.Qry`:
+
+    ```haskell
+    perasRoundNoToSlot :: PerasRoundNo -> Qry SlotNo
+    slotToPerasRoundNo :: SlotNo -> Qry PerasRoundNo
+    ```
+
+- Add a roundtrip test that ensures that converting Peras round number to a slot and then back is an identity is added into the `Test.Consensus.HardFork.Summary` module.
+- Add a Peras-specific test into `Test.Consensus.HardFork.History` module.
diff --git a/ouroboros-consensus-cardano/changelog.d/20250902_113907_javier.sagredo_lmdb.md b/ouroboros-consensus/changelog.d/20251002_112501_javier.sagredo_lsm1.md
similarity index 87%
rename from ouroboros-consensus-cardano/changelog.d/20250902_113907_javier.sagredo_lmdb.md
rename to ouroboros-consensus/changelog.d/20251002_112501_javier.sagredo_lsm1.md
index 41b1fa620..5e9da7f4c 100644
--- a/ouroboros-consensus-cardano/changelog.d/20250902_113907_javier.sagredo_lmdb.md
+++ b/ouroboros-consensus/changelog.d/20251002_112501_javier.sagredo_lsm1.md
@@ -5,12 +5,10 @@ Uncomment the section that is right (remove the HTML comment wrapper).
 For top level release notes, leave all the headers commented out.
 -->
 
-<!--
 ### Patch
 
-- A bullet item for the Patch category.
+- Bump `cardano-ledger-core` dependency to 1.19.
 
--->
 <!--
 ### Non-Breaking
 
diff --git a/ouroboros-consensus/changelog.d/20251008_135933_javier.sagredo_fix_double_alloc.md b/ouroboros-consensus/changelog.d/20251008_135933_javier.sagredo_fix_double_alloc.md
new file mode 100644
index 000000000..456db3625
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20251008_135933_javier.sagredo_fix_double_alloc.md
@@ -0,0 +1,24 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+### Patch
+
+- Ensure the initial handle allocated by opening a forker is deallocated in all
+  situations.
+
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+<!--
+### Breaking
+
+- A bullet item for the Breaking category.
+
+-->
diff --git a/ouroboros-consensus/changelog.d/20250825_170621_javier.sagredo_snapshot_manager.md b/ouroboros-consensus/changelog.d/20251010_111745_javier.sagredo_version_tables.md
similarity index 64%
rename from ouroboros-consensus/changelog.d/20250825_170621_javier.sagredo_snapshot_manager.md
rename to ouroboros-consensus/changelog.d/20251010_111745_javier.sagredo_version_tables.md
index ce8fea39b..58cba7618 100644
--- a/ouroboros-consensus/changelog.d/20250825_170621_javier.sagredo_snapshot_manager.md
+++ b/ouroboros-consensus/changelog.d/20251010_111745_javier.sagredo_version_tables.md
@@ -17,6 +17,9 @@ For top level release notes, leave all the headers commented out.
 - A bullet item for the Non-Breaking category.
 
 -->
+
 ### Breaking
 
-- Group snapshot management functions in the new datatype `SnapshotManager`.
+- Version ledger tables encoding. Define `TablesCodecVersion1`.
+- InMemory snapshots used to store the tables in `<snap>/tables/tvar`. Now they
+  store the tables in `<snap>/tables`.
diff --git a/ouroboros-consensus/changelog.d/20251010_121126_javier.sagredo_extract_2.md b/ouroboros-consensus/changelog.d/20251010_121126_javier.sagredo_extract_2.md
new file mode 100644
index 000000000..ea9d4b5b1
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20251010_121126_javier.sagredo_extract_2.md
@@ -0,0 +1,29 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+<!--
+### Patch
+
+- A bullet item for the Patch category.
+
+-->
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+
+### Breaking
+
+- Extracted `Ouroboros.Consensus.Storage.LedgerDB.V2.LSM` into a separate sub-library `ouroboros-consensus-lsm`.
+- Extracted `Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB*` into a separate sub-library `ouroboros-consensus-lmdb`.
+- Define `Ouroboros.Consensus.Storage.LedgerDB.V2.Backend.Backend` class that allow for interaction with backends mainly opening them, and define instances for all existing V2 backends.
+- Define `Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Backend` class that allow for interaction with backends mainly opening them, and define instances for all existing V1 backends.
+- Define `Ouroboros.Consensus.Storage.LedgerDB.APIStreamingBackend` class that allows for streaming in/out from a backend, and define instances for all existing backends.
+- Delete `LedgerDbFlavorArgs`. Repurpose `LedgerDbBackendArgs` for the arguments needed by the `Backend` classes to initialize a backend, and expect it in `LedgerDbArgs`.
+- Delete `V1.FlavorImplSpecificTrace` and `V2.FlavorImplSpecificTrace` and use `Backend(SomeBackendTrace)` for those.
diff --git a/ouroboros-consensus/changelog.d/20251024_123836_javier.sagredo_bangs.md b/ouroboros-consensus/changelog.d/20251024_123836_javier.sagredo_bangs.md
new file mode 100644
index 000000000..44eaca5ec
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20251024_123836_javier.sagredo_bangs.md
@@ -0,0 +1,24 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+### Patch
+
+- Ensure the `LedgerDbArgs` are garbage collected once we start the LedgerDB.
+- Ensure the `ProtocolInfo` is garbage collected once we start Consensus.
+
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+<!--
+### Breaking
+
+- A bullet item for the Breaking category.
+
+-->
diff --git a/ouroboros-consensus/changelog.d/20251028_101139_alexander.esgen_ledgerdb_v1_race.md b/ouroboros-consensus/changelog.d/20251028_101139_alexander.esgen_ledgerdb_v1_race.md
new file mode 100644
index 000000000..dd8be2a52
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20251028_101139_alexander.esgen_ledgerdb_v1_race.md
@@ -0,0 +1,3 @@
+### Patch
+
+- Fix a race condition between chain switches and LedgerDB.V1 forker acquisition.
diff --git a/ouroboros-consensus/changelog.d/20251029_113014_javier.sagredo_fix_mempool_dangling_forker.md b/ouroboros-consensus/changelog.d/20251029_113014_javier.sagredo_fix_mempool_dangling_forker.md
new file mode 100644
index 000000000..34b35458d
--- /dev/null
+++ b/ouroboros-consensus/changelog.d/20251029_113014_javier.sagredo_fix_mempool_dangling_forker.md
@@ -0,0 +1,25 @@
+<!--
+A new scriv changelog fragment.
+
+Uncomment the section that is right (remove the HTML comment wrapper).
+For top level release notes, leave all the headers commented out.
+-->
+
+### Patch
+
+- Ensure Mempool always deallocates stale forkers, or rather that it does not
+  try to allocate a new one unless completely necessary and closes the old one
+  in the process.
+
+<!--
+### Non-Breaking
+
+- A bullet item for the Non-Breaking category.
+
+-->
+<!--
+### Breaking
+
+- A bullet item for the Breaking category.
+
+-->
diff --git a/ouroboros-consensus/ouroboros-consensus.cabal b/ouroboros-consensus/ouroboros-consensus.cabal
index 1c93bb8f2..091aeea1e 100644
--- a/ouroboros-consensus/ouroboros-consensus.cabal
+++ b/ouroboros-consensus/ouroboros-consensus.cabal
@@ -1,6 +1,6 @@
 cabal-version: 3.0
 name: ouroboros-consensus
-version: 0.27.0.0
+version: 0.28.0.0
 synopsis: Consensus layer for the Ouroboros blockchain protocol
 description: Consensus layer for the Ouroboros blockchain protocol.
 license: Apache-2.0
@@ -83,6 +83,7 @@ library
     Ouroboros.Consensus.Block.RealPoint
     Ouroboros.Consensus.Block.SupportsDiffusionPipelining
     Ouroboros.Consensus.Block.SupportsMetrics
+    Ouroboros.Consensus.Block.SupportsPeras
     Ouroboros.Consensus.Block.SupportsProtocol
     Ouroboros.Consensus.Block.SupportsSanityCheck
     Ouroboros.Consensus.BlockchainTime
@@ -190,6 +191,11 @@ library
     Ouroboros.Consensus.MiniProtocol.LocalStateQuery.Server
     Ouroboros.Consensus.MiniProtocol.LocalTxMonitor.Server
     Ouroboros.Consensus.MiniProtocol.LocalTxSubmission.Server
+    Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Inbound
+    Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+    Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.PerasCert
+    Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Outbound
+    Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert
     Ouroboros.Consensus.Node.GsmState
     Ouroboros.Consensus.Node.InitStorage
     Ouroboros.Consensus.Node.NetworkProtocolVersion
@@ -197,6 +203,8 @@ library
     Ouroboros.Consensus.Node.Run
     Ouroboros.Consensus.Node.Serialisation
     Ouroboros.Consensus.NodeId
+    Ouroboros.Consensus.Peras.SelectView
+    Ouroboros.Consensus.Peras.Weight
     Ouroboros.Consensus.Protocol.Abstract
     Ouroboros.Consensus.Protocol.BFT
     Ouroboros.Consensus.Protocol.LeaderSchedule
@@ -249,19 +257,19 @@ library
     Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
     Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API
     Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.InMemory
-    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB
-    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Bridge
-    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Status
     Ouroboros.Consensus.Storage.LedgerDB.V1.DbChangelog
     Ouroboros.Consensus.Storage.LedgerDB.V1.DiffSeq
     Ouroboros.Consensus.Storage.LedgerDB.V1.Forker
     Ouroboros.Consensus.Storage.LedgerDB.V1.Lock
     Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots
     Ouroboros.Consensus.Storage.LedgerDB.V2
-    Ouroboros.Consensus.Storage.LedgerDB.V2.Args
+    Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
     Ouroboros.Consensus.Storage.LedgerDB.V2.Forker
     Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory
     Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq
+    Ouroboros.Consensus.Storage.PerasCertDB
+    Ouroboros.Consensus.Storage.PerasCertDB.API
+    Ouroboros.Consensus.Storage.PerasCertDB.Impl
     Ouroboros.Consensus.Storage.Serialisation
     Ouroboros.Consensus.Storage.VolatileDB
     Ouroboros.Consensus.Storage.VolatileDB.API
@@ -276,6 +284,7 @@ library
     Ouroboros.Consensus.TypeFamilyWrappers
     Ouroboros.Consensus.Util
     Ouroboros.Consensus.Util.AnchoredFragment
+    Ouroboros.Consensus.Util.AnchoredSeq
     Ouroboros.Consensus.Util.Args
     Ouroboros.Consensus.Util.Assert
     Ouroboros.Consensus.Util.CBOR
@@ -312,9 +321,7 @@ library
     bytestring >=0.10 && <0.13,
     cardano-binary,
     cardano-crypto-class,
-    cardano-ledger-core ^>=1.18,
-    cardano-lmdb >=0.4,
-    cardano-lmdb-simple ^>=0.8,
+    cardano-ledger-core ^>=1.19,
     cardano-prelude,
     cardano-slotting,
     cardano-strict-containers,
@@ -324,6 +331,7 @@ library
     deepseq,
     diff-containers >=1.2,
     filelock,
+    filepath,
     fingertree-rm >=1.0,
     fs-api ^>=0.4,
     hashable,
@@ -347,7 +355,7 @@ library
     singletons,
     small-steps ^>=1.1,
     sop-core ^>=0.5,
-    sop-extras ^>=0.4,
+    sop-extras ^>=0.4.1,
     streaming,
     strict >=0.1 && <0.6,
     strict-checked-vars ^>=0.2,
@@ -369,6 +377,71 @@ library
     directory
     latex-svg-image
 
+library ouroboros-consensus-lsm
+  import: common-lib
+  visibility: public
+  hs-source-dirs: src/ouroboros-consensus-lsm
+  exposed-modules:
+    Ouroboros.Consensus.Storage.LedgerDB.V2.LSM
+
+  build-depends:
+    base >=4.14 && <4.22,
+    blockio,
+    containers >=0.5 && <0.8,
+    contra-tracer,
+    filepath,
+    fs-api ^>=0.4,
+    lsm-tree,
+    mempack,
+    mtl,
+    nothunks ^>=0.2,
+    ouroboros-consensus,
+    primitive,
+    random,
+    resource-registry ^>=0.1,
+    serialise ^>=0.2,
+    streaming,
+    text,
+    transformers,
+    vector ^>=0.13,
+
+  build-depends: text >=1.2.5.0 && <2.2
+
+library ouroboros-consensus-lmdb
+  import: common-lib
+  visibility: public
+  hs-source-dirs: src/ouroboros-consensus-lmdb
+  exposed-modules:
+    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB
+    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Bridge
+    Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Status
+
+  build-depends:
+    base >=4.14 && <4.22,
+    bytestring >=0.10 && <0.13,
+    cardano-lmdb >=0.4,
+    cardano-lmdb-simple ^>=0.8,
+    cardano-slotting,
+    containers >=0.5 && <0.8,
+    contra-tracer,
+    directory,
+    filepath,
+    fs-api ^>=0.4,
+    io-classes ^>=1.8.0.1,
+    mempack,
+    mtl,
+    nothunks ^>=0.2,
+    ouroboros-consensus,
+    rawlock ^>=0.1.1,
+    resource-registry,
+    serialise ^>=0.2,
+    sop-core,
+    streaming,
+    temporary,
+    text,
+
+  build-depends: text >=1.2.5.0 && <2.2
+
 library unstable-consensus-testlib
   import: common-lib
   visibility: public
@@ -525,7 +598,7 @@ library unstable-mock-block
     cardano-binary,
     cardano-crypto-class,
     cardano-ledger-core,
-    cardano-slotting:{cardano-slotting, testlib},
+    cardano-slotting,
     cborg,
     containers,
     deepseq,
@@ -596,6 +669,9 @@ test-suite consensus-test
     Test.Consensus.MiniProtocol.ChainSync.CSJ
     Test.Consensus.MiniProtocol.ChainSync.Client
     Test.Consensus.MiniProtocol.LocalStateQuery.Server
+    Test.Consensus.MiniProtocol.ObjectDiffusion.PerasCert.Smoke
+    Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke
+    Test.Consensus.Peras.WeightSnapshot
     Test.Consensus.Util.MonadSTM.NormalForm
     Test.Consensus.Util.Versioned
 
@@ -717,6 +793,9 @@ test-suite storage-test
     Test.Ouroboros.Storage.LedgerDB.V1.DbChangelog
     Test.Ouroboros.Storage.LedgerDB.V1.LMDB
     Test.Ouroboros.Storage.Orphans
+    Test.Ouroboros.Storage.PerasCertDB
+    Test.Ouroboros.Storage.PerasCertDB.Model
+    Test.Ouroboros.Storage.PerasCertDB.StateMachine
     Test.Ouroboros.Storage.VolatileDB
     Test.Ouroboros.Storage.VolatileDB.Mock
     Test.Ouroboros.Storage.VolatileDB.Model
@@ -748,7 +827,7 @@ test-suite storage-test
     mempack,
     mtl,
     nothunks,
-    ouroboros-consensus,
+    ouroboros-consensus:{ouroboros-consensus, ouroboros-consensus-lmdb, ouroboros-consensus-lsm},
     ouroboros-network-api,
     ouroboros-network-mock,
     ouroboros-network-protocols,
@@ -827,6 +906,20 @@ benchmark ChainSync-client-bench
     unstable-consensus-testlib,
     with-utf8,
 
+benchmark PerasCertDB-bench
+  import: common-bench
+  type: exitcode-stdio-1.0
+  hs-source-dirs: bench/PerasCertDB-bench
+  main-is: Main.hs
+  other-modules:
+  build-depends:
+    base,
+    cardano-ledger-core,
+    ouroboros-consensus,
+    ouroboros-network-api,
+    tasty-bench,
+    unstable-consensus-testlib,
+
 test-suite doctest
   import: common-test
   main-is: doctest.hs
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs b/ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs
similarity index 81%
rename from ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs
rename to ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs
index 919db9785..1a0044476 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB.hs
@@ -3,38 +3,46 @@
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE GADTs #-}
+{-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE PatternSynonyms #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TupleSections #-}
 {-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeData #-}
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
+{-# LANGUAGE UndecidableInstances #-}
 
 -- | A 'BackingStore' implementation based on [LMDB](http://www.lmdb.tech/doc/).
 module Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB
   ( -- * Opening a database
-    LMDBLimits (LMDBLimits, lmdbMapSize, lmdbMaxDatabases, lmdbMaxReaders)
-  , newLMDBBackingStore
-
-    -- * Errors
+    LMDB
+  , Backend (..)
+  , Args (LMDBBackingStoreArgs)
+  , LMDBLimits (LMDBLimits, lmdbMapSize, lmdbMaxDatabases, lmdbMaxReaders)
+  , mkLMDBArgs
+
+    -- * Streaming
+  , YieldArgs (YieldLMDB)
+  , mkLMDBYieldArgs
+  , SinkArgs (SinkLMDB)
+  , mkLMDBSinkArgs
+
+    -- * Exposed for testing
   , LMDBErr (..)
-
-    -- * Internals exposed for @snapshot-converter@
-  , DbSeqNo (..)
-  , LMDBMK (..)
-  , getDb
-  , initLMDBTable
-  , withDbSeqNoRWMaybeNull
   ) where
 
-import Cardano.Slotting.Slot (SlotNo, WithOrigin (At))
+import Cardano.Slotting.Slot (WithOrigin (At))
 import qualified Codec.Serialise as S (Serialise (..))
 import qualified Control.Concurrent.Class.MonadSTM.TVar as IOLike
 import Control.Monad (forM_, unless, void, when)
 import qualified Control.Monad.Class.MonadSTM as IOLike
 import Control.Monad.IO.Class (MonadIO (liftIO))
+import Control.Monad.Trans (lift)
+import Control.ResourceRegistry
 import qualified Control.Tracer as Trace
 import Data.Bifunctor (first)
 import Data.Functor (($>), (<&>))
@@ -43,6 +51,7 @@ import Data.Map (Map)
 import qualified Data.Map.Strict as Map
 import Data.MemPack
 import Data.Proxy
+import qualified Data.SOP.Dict as Dict
 import qualified Data.Set as Set
 import qualified Data.Text as Strict
 import qualified Database.LMDB.Simple as LMDB
@@ -52,11 +61,17 @@ import qualified Database.LMDB.Simple.Internal as LMDB.Internal
 import qualified Database.LMDB.Simple.TransactionHandle as TrH
 import GHC.Generics (Generic)
 import GHC.Stack (HasCallStack)
-import Ouroboros.Consensus.Ledger.Tables
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Ledger.Basics
 import qualified Ouroboros.Consensus.Ledger.Tables.Diff as Diff
+import Ouroboros.Consensus.Ledger.Tables.Utils (emptyLedgerTables)
+import Ouroboros.Consensus.Storage.LedgerDB.API
+import Ouroboros.Consensus.Storage.LedgerDB.Args
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
   ( SnapshotBackend (..)
   )
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Args as V1
+import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API as API
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Bridge as Bridge
 import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB.Status
@@ -70,10 +85,17 @@ import Ouroboros.Consensus.Util.IOLike
   , IOLike
   , MonadCatch (..)
   , MonadThrow (..)
+  , PrimState
   , bracket
   )
 import Ouroboros.Consensus.Util.IndexedMemPack
+import qualified Streaming as S
+import qualified Streaming.Prelude as S
+import System.Directory
 import qualified System.FS.API as FS
+import System.FS.IO
+import qualified System.FilePath as FilePath
+import System.IO.Temp
 
 {-------------------------------------------------------------------------------
   Database definition
@@ -793,3 +815,187 @@ prettyPrintLMDBErr = \case
   LMDBErrNotADir path ->
     "The path " <> show path <> " should be a directory but it is a file instead."
   LMDBErrClosed -> "The database has been closed."
+
+{-------------------------------------------------------------------------------
+  Backend
+-------------------------------------------------------------------------------}
+
+type data LMDB
+
+instance
+  ( HasLedgerTables l
+  , MonadIO m
+  , IOLike m
+  , MemPackIdx l EmptyMK ~ l EmptyMK
+  ) =>
+  Backend m LMDB l
+  where
+  data Args m LMDB
+    = LMDBBackingStoreArgs FilePath LMDBLimits (Dict.Dict MonadIOPrim m)
+  data Trace m LMDB
+    = OnDiskBackingStoreInitialise LMDB.Limits
+    | OnDiskBackingStoreTrace BackingStoreTrace
+    deriving (Eq, Show)
+
+  isRightBackendForSnapshot _ _ UTxOHDLMDBSnapshot = True
+  isRightBackendForSnapshot _ _ _ = False
+
+  newBackingStoreInitialiser trcr (LMDBBackingStoreArgs fs limits Dict.Dict) =
+    newLMDBBackingStore
+      (SomeBackendTrace . OnDiskBackingStoreTrace >$< trcr)
+      limits
+      (LiveLMDBFS $ FS.SomeHasFS $ ioHasFS $ FS.MountPoint fs)
+
+-- | Create arguments for initializing the LedgerDB using the LMDB backend.
+mkLMDBArgs ::
+  ( MonadIOPrim m
+  , HasLedgerTables (LedgerState blk)
+  , IOLike m
+  ) =>
+  V1.FlushFrequency -> FilePath -> LMDBLimits -> a -> (LedgerDbBackendArgs m blk, a)
+mkLMDBArgs flushing lmdbPath limits =
+  (,) $
+    LedgerDbBackendArgsV1 $
+      V1.V1Args flushing $
+        SomeBackendArgs $
+          LMDBBackingStoreArgs lmdbPath limits Dict.Dict
+
+class (MonadIO m, PrimState m ~ PrimState IO) => MonadIOPrim m
+instance (MonadIO m, PrimState m ~ PrimState IO) => MonadIOPrim m
+
+{-------------------------------------------------------------------------------
+  Streaming
+-------------------------------------------------------------------------------}
+
+instance (Ord (TxIn l), GetTip l, Monad m) => StreamingBackend m LMDB l where
+  data SinkArgs m LMDB l
+    = SinkLMDB
+        -- \| Chunk size
+        Int
+        -- \| bsWrite
+        ( SlotNo ->
+          (l EmptyMK, l EmptyMK) ->
+          LedgerTables l DiffMK ->
+          m ()
+        )
+        (l EmptyMK -> m ())
+
+  data YieldArgs m LMDB l
+    = YieldLMDB
+        Int
+        (LedgerBackingStoreValueHandle m l)
+
+  yield _ (YieldLMDB chunkSize valueHandle) = yieldLmdbS chunkSize valueHandle
+  sink _ (SinkLMDB chunkSize write copy) = sinkLmdbS chunkSize write copy
+
+sinkLmdbS ::
+  forall m l.
+  (Ord (TxIn l), GetTip l, Monad m) =>
+  Int ->
+  (SlotNo -> (l EmptyMK, l EmptyMK) -> LedgerTables l DiffMK -> m ()) ->
+  (l EmptyMK -> m ()) ->
+  Sink m l
+sinkLmdbS writeChunkSize bs copyTo hint s = do
+  r <- go writeChunkSize mempty s
+  lift $ copyTo hint
+  pure (fmap (,Nothing) r)
+ where
+  sl = withOrigin (error "unreachable") id $ pointSlot $ getTip hint
+
+  go 0 m s' = do
+    lift $ bs sl (hint, hint) (LedgerTables $ DiffMK $ Diff.fromMapInserts m)
+    go writeChunkSize mempty s'
+  go n m s' = do
+    mbs <- S.uncons s'
+    case mbs of
+      Nothing -> do
+        lift $ bs sl (hint, hint) (LedgerTables $ DiffMK $ Diff.fromMapInserts m)
+        S.effects s'
+      Just ((k, v), s'') ->
+        go (n - 1) (Map.insert k v m) s''
+
+yieldLmdbS ::
+  Monad m =>
+  Int ->
+  LedgerBackingStoreValueHandle m l ->
+  Yield m l
+yieldLmdbS readChunkSize bsvh hint k = do
+  r <- k (go (RangeQuery Nothing readChunkSize))
+  lift $ S.effects r
+ where
+  go p = do
+    (LedgerTables (ValuesMK values), mx) <- lift $ S.lift $ bsvhRangeRead bsvh hint p
+    case mx of
+      Nothing -> pure $ pure Nothing
+      Just x -> do
+        S.each $ Map.toList values
+        go (RangeQuery (Just . LedgerTables . KeysMK $ Set.singleton x) readChunkSize)
+
+-- | Create Yield args for LMDB
+mkLMDBYieldArgs ::
+  forall l.
+  ( HasCallStack
+  , HasLedgerTables l
+  , MemPackIdx l EmptyMK ~ l EmptyMK
+  ) =>
+  FilePath ->
+  LMDBLimits ->
+  l EmptyMK ->
+  ResourceRegistry IO ->
+  IO (YieldArgs IO LMDB l)
+mkLMDBYieldArgs fp limits hint reg = do
+  let (dbPath, snapName) = FilePath.splitFileName fp
+  tempDir <- getCanonicalTemporaryDirectory
+  let lmdbTemp = tempDir FilePath.</> "lmdb_streaming_in"
+  removePathForcibly lmdbTemp
+  _ <-
+    allocate
+      reg
+      (\_ -> createDirectory lmdbTemp)
+      (\_ -> removePathForcibly lmdbTemp)
+  (_, bs) <-
+    allocate
+      reg
+      ( \_ -> do
+          newLMDBBackingStore
+            Trace.nullTracer
+            limits
+            (LiveLMDBFS $ FS.SomeHasFS $ ioHasFS $ FS.MountPoint lmdbTemp)
+            (SnapshotsFS $ FS.SomeHasFS $ ioHasFS $ FS.MountPoint dbPath)
+            (InitFromCopy hint (FS.mkFsPath [snapName]))
+      )
+      bsClose
+  (_, bsvh) <- allocate reg (\_ -> bsValueHandle bs) bsvhClose
+  pure (YieldLMDB 1000 bsvh)
+
+-- | Create Sink args for LMDB
+mkLMDBSinkArgs ::
+  forall l.
+  ( HasCallStack
+  , HasLedgerTables l
+  , MemPackIdx l EmptyMK ~ l EmptyMK
+  ) =>
+  FilePath ->
+  LMDBLimits ->
+  l EmptyMK ->
+  ResourceRegistry IO ->
+  IO (SinkArgs IO LMDB l)
+mkLMDBSinkArgs fp limits hint reg = do
+  let (snapDir, snapName) = FilePath.splitFileName fp
+  tempDir <- getCanonicalTemporaryDirectory
+  let lmdbTemp = tempDir FilePath.</> "lmdb_streaming_out"
+  removePathForcibly lmdbTemp
+  _ <- allocate reg (\_ -> createDirectory lmdbTemp) (\_ -> removePathForcibly lmdbTemp)
+  (_, bs) <-
+    allocate
+      reg
+      ( \_ ->
+          newLMDBBackingStore
+            Trace.nullTracer
+            limits
+            (LiveLMDBFS $ FS.SomeHasFS $ ioHasFS $ FS.MountPoint lmdbTemp)
+            (SnapshotsFS $ FS.SomeHasFS $ ioHasFS $ FS.MountPoint snapDir)
+            (InitFromValues (At 0) hint emptyLedgerTables)
+      )
+      bsClose
+  pure $ SinkLMDB 1000 (bsWrite bs) (\h -> bsCopy bs h (FS.mkFsPath [snapName, "tables"]))
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs b/ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs
similarity index 96%
rename from ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs
rename to ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs
index 0978dd107..ff52b7734 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Bridge.hs
@@ -41,7 +41,7 @@ import Database.LMDB.Simple.Cursor (CursorM)
 import qualified Database.LMDB.Simple.Cursor as Cursor
 import qualified Database.LMDB.Simple.Internal as Internal
 import Foreign (Storable (peek, poke), castPtr)
-import GHC.Ptr (Ptr (..))
+import GHC.Exts
 import Ouroboros.Consensus.Util.IndexedMemPack
 
 instance Buffer MDB_val where
@@ -51,6 +51,15 @@ instance Buffer MDB_val where
   buffer (MDB_val _ (Ptr addr#)) _ f = f addr#
   {-# INLINE buffer #-}
 
+  mkBuffer ba# =
+    MDB_val
+      (fromIntegral (I# (sizeofByteArray# ba#)))
+      (Ptr (byteArrayContents# ba#))
+  {-# INLINE mkBuffer #-}
+
+  bufferHasToBePinned = True
+  {-# INLINE bufferHasToBePinned #-}
+
 {-------------------------------------------------------------------------------
   Internal: peek and poke
 -------------------------------------------------------------------------------}
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Status.hs b/ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Status.hs
similarity index 100%
rename from ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Status.hs
rename to ouroboros-consensus/src/ouroboros-consensus-lmdb/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/LMDB/Status.hs
diff --git a/ouroboros-consensus/src/ouroboros-consensus-lsm/Ouroboros/Consensus/Storage/LedgerDB/V2/LSM.hs b/ouroboros-consensus/src/ouroboros-consensus-lsm/Ouroboros/Consensus/Storage/LedgerDB/V2/LSM.hs
new file mode 100644
index 000000000..fb32c422b
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus-lsm/Ouroboros/Consensus/Storage/LedgerDB/V2/LSM.hs
@@ -0,0 +1,766 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE DeriveAnyClass #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TupleSections #-}
+{-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeData #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
+{-# LANGUAGE ViewPatterns #-}
+-- Needed for @NoThunks (Table m k v b)@
+{-# OPTIONS_GHC -Wno-orphans #-}
+
+-- | Implementation of the 'LedgerTablesHandle' interface with LSM trees.
+module Ouroboros.Consensus.Storage.LedgerDB.V2.LSM
+  ( -- * Backend API
+    LSM
+  , Backend (..)
+  , Args (LSMArgs)
+  , mkLSMArgs
+  , stdMkBlockIOFS
+
+    -- * Streaming
+  , YieldArgs (YieldLSM)
+  , mkLSMYieldArgs
+  , SinkArgs (SinkLSM)
+  , mkLSMSinkArgs
+
+    -- * Exported for tests
+  , LSM.Salt
+  , SomeHasFSAndBlockIO (..)
+  ) where
+
+import Codec.Serialise (decode)
+import qualified Control.Monad as Monad
+import Control.Monad.Trans (lift)
+import Control.Monad.Trans.Except
+import Control.ResourceRegistry
+import Control.Tracer
+import qualified Data.Foldable as Foldable
+import Data.Functor.Contravariant ((>$<))
+import qualified Data.List as List
+import qualified Data.Map.Strict as Map
+import Data.Maybe
+import Data.MemPack
+import qualified Data.Primitive.ByteArray as PBA
+import qualified Data.Set as Set
+import Data.String (fromString)
+import qualified Data.Text as T
+import qualified Data.Text as Text
+import Data.Typeable
+import qualified Data.Vector as V
+import qualified Data.Vector.Mutable as VM
+import qualified Data.Vector.Primitive as VP
+import Data.Void
+import Database.LSMTree (Salt, Session, Table)
+import qualified Database.LSMTree as LSM
+import GHC.Generics
+import NoThunks.Class
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Ledger.Abstract
+import Ouroboros.Consensus.Ledger.Extended
+import Ouroboros.Consensus.Ledger.SupportsProtocol
+import qualified Ouroboros.Consensus.Ledger.Tables.Diff as Diff
+import Ouroboros.Consensus.Ledger.Tables.Utils
+import Ouroboros.Consensus.Storage.LedgerDB.API
+import Ouroboros.Consensus.Storage.LedgerDB.Args
+import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
+import Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq
+import Ouroboros.Consensus.Util (chunks)
+import Ouroboros.Consensus.Util.CRC
+import Ouroboros.Consensus.Util.Enclose
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.IndexedMemPack
+import qualified Streaming as S
+import qualified Streaming.Prelude as S
+import System.FS.API
+import qualified System.FS.BlockIO.API as BIO
+import System.FS.BlockIO.IO
+import System.FilePath (splitDirectories, splitFileName)
+import System.Random
+import Prelude hiding (read)
+
+-- | Type alias for convenience
+type UTxOTable m = Table m TxInBytes TxOutBytes Void
+
+instance NoThunks (Table m txin txout Void) where
+  showTypeOf _ = "Table"
+  wNoThunks _ _ = pure Nothing
+
+data LSMClosedExn = LSMClosedExn
+  deriving (Show, Exception)
+
+{-------------------------------------------------------------------------------
+  TxOuts
+-------------------------------------------------------------------------------}
+
+newtype TxOutBytes = TxOutBytes {unTxOutBytes :: LSM.RawBytes}
+
+toTxOutBytes :: IndexedMemPack (l EmptyMK) (TxOut l) => l EmptyMK -> TxOut l -> TxOutBytes
+toTxOutBytes st txout =
+  let barr = indexedPackByteArray True st txout
+   in TxOutBytes $ LSM.RawBytes (VP.Vector 0 (PBA.sizeofByteArray barr) barr)
+
+fromTxOutBytes :: IndexedMemPack (l EmptyMK) (TxOut l) => l EmptyMK -> TxOutBytes -> TxOut l
+fromTxOutBytes st (TxOutBytes (LSM.RawBytes vec)) =
+  case indexedUnpackEither st vec of
+    Left err ->
+      error $
+        unlines
+          [ "There was an error deserializing a TxOut from the LSM backend."
+          , "This will likely result in a restart-crash loop."
+          , "The error: " <> show err
+          ]
+    Right v -> v
+
+instance LSM.SerialiseValue TxOutBytes where
+  serialiseValue = unTxOutBytes
+  deserialiseValue = TxOutBytes
+
+deriving via LSM.ResolveAsFirst TxOutBytes instance LSM.ResolveValue TxOutBytes
+
+{-------------------------------------------------------------------------------
+  TxIns
+-------------------------------------------------------------------------------}
+
+newtype TxInBytes = TxInBytes {unTxInBytes :: LSM.RawBytes}
+
+toTxInBytes :: MemPack (TxIn l) => Proxy l -> TxIn l -> TxInBytes
+toTxInBytes _ txin =
+  let barr = packByteArray True txin
+   in TxInBytes $ LSM.RawBytes (VP.Vector 0 (PBA.sizeofByteArray barr) barr)
+
+fromTxInBytes :: MemPack (TxIn l) => Proxy l -> TxInBytes -> TxIn l
+fromTxInBytes _ (TxInBytes (LSM.RawBytes vec)) =
+  case unpackEither vec of
+    Left err ->
+      error $
+        unlines
+          [ "There was an error deserializing a TxIn from the LSM backend."
+          , "This will likely result in a restart-crash loop."
+          , "The error: " <> show err
+          ]
+    Right v -> v
+
+instance LSM.SerialiseKey TxInBytes where
+  serialiseKey = unTxInBytes
+  deserialiseKey = TxInBytes
+
+{-------------------------------------------------------------------------------
+  LedgerTablesHandle
+-------------------------------------------------------------------------------}
+
+newLSMLedgerTablesHandle ::
+  forall m l.
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  Tracer m LedgerDBV2Trace ->
+  ResourceRegistry m ->
+  (ResourceKey m, UTxOTable m) ->
+  m (LedgerTablesHandle m l)
+newLSMLedgerTablesHandle tracer rr (resKey, t) = do
+  traceWith tracer TraceLedgerTablesHandleCreate
+  pure
+    LedgerTablesHandle
+      { close = implClose resKey
+      , duplicate = implDuplicate rr t tracer
+      , read = implRead t
+      , readRange = implReadRange t
+      , readAll = implReadAll t
+      , pushDiffs = implPushDiffs t
+      , takeHandleSnapshot = implTakeHandleSnapshot t
+      , tablesSize = pure Nothing
+      }
+
+{-# INLINE implClose #-}
+{-# INLINE implDuplicate #-}
+{-# INLINE implRead #-}
+{-# INLINE implReadRange #-}
+{-# INLINE implReadAll #-}
+{-# INLINE implPushDiffs #-}
+{-# INLINE implTakeHandleSnapshot #-}
+
+implClose :: IOLike m => ResourceKey m -> m ()
+implClose = Monad.void . release
+
+implDuplicate ::
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  ResourceRegistry m ->
+  UTxOTable m ->
+  Tracer m LedgerDBV2Trace ->
+  m (LedgerTablesHandle m l)
+implDuplicate rr t tracer = do
+  table <-
+    allocate
+      rr
+      (\_ -> LSM.duplicate t)
+      ( \t' -> do
+          traceWith tracer TraceLedgerTablesHandleClose
+          LSM.closeTable t'
+      )
+  newLSMLedgerTablesHandle tracer rr table
+
+implRead ::
+  forall m l.
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  UTxOTable m -> l EmptyMK -> LedgerTables l KeysMK -> m (LedgerTables l ValuesMK)
+implRead t st (LedgerTables (KeysMK keys)) = do
+  let vec' = V.create $ do
+        vec <- VM.new (Set.size keys)
+        Monad.foldM_
+          (\i x -> VM.write vec i (toTxInBytes (Proxy @l) x) >> pure (i + 1))
+          0
+          keys
+        pure vec
+  res <- LSM.lookups t vec'
+  pure
+    . LedgerTables
+    . ValuesMK
+    . Foldable.foldl'
+      ( \m (k, item) ->
+          case item of
+            LSM.Found v -> Map.insert (fromTxInBytes (Proxy @l) k) (fromTxOutBytes st v) m
+            LSM.NotFound -> m
+            LSM.FoundWithBlob{} -> m
+      )
+      Map.empty
+    $ V.zip vec' res
+
+implReadRange ::
+  forall m l.
+  (IOLike m, IndexedMemPack (l EmptyMK) (TxOut l)) =>
+  HasLedgerTables l =>
+  UTxOTable m ->
+  l EmptyMK ->
+  (Maybe (TxIn l), Int) ->
+  m (LedgerTables l ValuesMK, Maybe (TxIn l))
+implReadRange table st (mPrev, num) = do
+  entries <- maybe cursorFromStart cursorFromKey mPrev
+  pure
+    ( LedgerTables
+        . ValuesMK
+        . V.foldl'
+          ( \m -> \case
+              LSM.Entry k v -> Map.insert (fromTxInBytes (Proxy @l) k) (fromTxOutBytes st v) m
+              LSM.EntryWithBlob{} -> m
+          )
+          Map.empty
+        $ entries
+    , case snd <$> V.unsnoc entries of
+        Nothing -> Nothing
+        Just (LSM.Entry k _) -> Just (fromTxInBytes (Proxy @l) k)
+        Just (LSM.EntryWithBlob k _ _) -> Just (fromTxInBytes (Proxy @l) k)
+    )
+ where
+  cursorFromStart = LSM.withCursor table (LSM.take num)
+  -- Here we ask for one value more and we drop one value because the
+  -- cursor returns also the key at which it was opened.
+  cursorFromKey k = fmap (V.drop 1) $ LSM.withCursorAtOffset table (toTxInBytes (Proxy @l) k) (LSM.take $ num + 1)
+
+implReadAll ::
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  UTxOTable m ->
+  l EmptyMK ->
+  m (LedgerTables l ValuesMK)
+implReadAll t st =
+  let readAll' m = do
+        (v, n) <- implReadRange t st (m, 100000)
+        maybe (pure v) (fmap (ltliftA2 unionValues v) . readAll' . Just) n
+   in readAll' Nothing
+
+implPushDiffs ::
+  forall m l mk.
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  UTxOTable m -> l mk -> l DiffMK -> m ()
+implPushDiffs t _ !st1 = do
+  let LedgerTables (DiffMK (Diff.Diff diffs)) = projectLedgerTables st1
+  let vec = V.create $ do
+        vec' <- VM.new (Map.size diffs)
+        Monad.foldM_
+          (\idx (k, item) -> VM.write vec' idx (toTxInBytes (Proxy @l) k, (f item)) >> pure (idx + 1))
+          0
+          $ Map.toList diffs
+        pure vec'
+  LSM.updates t vec
+ where
+  f (Diff.Insert v) = LSM.Insert (toTxOutBytes (forgetLedgerTables st1) v) Nothing
+  f Diff.Delete = LSM.Delete
+
+implTakeHandleSnapshot :: IOLike m => UTxOTable m -> t -> String -> m (Maybe a)
+implTakeHandleSnapshot t _ snapshotName = do
+  LSM.saveSnapshot
+    (fromString snapshotName)
+    (LSM.SnapshotLabel $ Text.pack $ "UTxO table")
+    t
+  pure Nothing
+
+{-------------------------------------------------------------------------------
+  SnapshotManager
+-------------------------------------------------------------------------------}
+
+-- | Snapshots in LSM trees are split in two parts for now:
+--
+-- - The @state@ and @meta@ files in the usual location (@./ledger/<slotno>@ in
+--   the ChainDB).
+--
+-- - The ledger tables, which are stored in the LSM-trees session directory,
+--   under a @./lsm/snapshots/<slotno>@ directory.
+--
+-- Note that the name of the folder in which the @state@ file is and the name of
+-- the snapshot in the LSM-trees directory have to match. This means that if the
+-- user adds a suffix to the snapshot renaming the directory
+-- @./ledger/<slotno>@, they will also have to rename the directory
+-- @./lsm/snapshots/<slotno>@. Otherwise the initialization logic will exit with
+-- failure saying that the snapshot was not found.
+--
+-- There is [an issue open in
+-- LSM-trees](https://github.com/IntersectMBO/lsm-tree/issues/272) such that the
+-- ledger tables part of the snapshot could also be stored in the
+-- @./ledger/<slotno>@ directory, but it is not implemented yet.
+snapshotManager ::
+  ( IOLike m
+  , LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  ) =>
+  Session m ->
+  CodecConfig blk ->
+  Tracer m (TraceSnapshotEvent blk) ->
+  SomeHasFS m ->
+  SnapshotManager m m blk (StateRef m (ExtLedgerState blk))
+snapshotManager session ccfg tracer fs =
+  SnapshotManager
+    { listSnapshots = defaultListSnapshots fs
+    , deleteSnapshot = implDeleteSnapshot session fs tracer
+    , takeSnapshot = implTakeSnapshot ccfg tracer fs
+    }
+
+{-# INLINE implTakeSnapshot #-}
+{-# INLINE implDeleteSnapshot #-}
+
+implTakeSnapshot ::
+  ( IOLike m
+  , LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  ) =>
+  CodecConfig blk ->
+  Tracer m (TraceSnapshotEvent blk) ->
+  SomeHasFS m ->
+  Maybe String ->
+  StateRef m (ExtLedgerState blk) ->
+  m (Maybe (DiskSnapshot, RealPoint blk))
+implTakeSnapshot ccfg tracer shfs@(SomeHasFS hasFs) suffix st =
+  case pointToWithOriginRealPoint (castPoint (getTip $ state st)) of
+    Origin -> return Nothing
+    NotOrigin t -> do
+      let number = unSlotNo (realPointSlot t)
+          snapshot = DiskSnapshot number suffix
+      diskSnapshots <- defaultListSnapshots shfs
+      if List.any (== DiskSnapshot number suffix) diskSnapshots
+        then
+          return Nothing
+        else do
+          encloseTimedWith (TookSnapshot snapshot t >$< tracer) $
+            writeSnapshot snapshot
+          return $ Just (snapshot, t)
+ where
+  writeSnapshot ds = do
+    createDirectoryIfMissing hasFs True $ snapshotToDirPath ds
+    crc1 <- writeExtLedgerState shfs (encodeDiskExtLedgerState ccfg) (snapshotToStatePath ds) $ state st
+    crc2 <- takeHandleSnapshot (tables st) (state st) $ snapshotToDirName ds
+    writeSnapshotMetadata shfs ds $
+      SnapshotMetadata
+        { snapshotBackend = UTxOHDLSMSnapshot
+        , snapshotChecksum = maybe crc1 (crcOfConcat crc1) crc2
+        , snapshotTablesCodecVersion = TablesCodecVersion1
+        }
+
+-- | Delete snapshot from disk and also from the LSM tree database.
+implDeleteSnapshot ::
+  IOLike m =>
+  Session m ->
+  SomeHasFS m ->
+  Tracer m (TraceSnapshotEvent blk) ->
+  DiskSnapshot ->
+  m ()
+implDeleteSnapshot
+  session
+  (SomeHasFS HasFS{doesDirectoryExist, removeDirectoryRecursive})
+  tracer
+  ss = do
+    deleteState `finally` deleteLsmTable
+    traceWith tracer (DeletedSnapshot ss)
+   where
+    deleteState = do
+      let p = snapshotToDirPath ss
+      exists <- doesDirectoryExist p
+      Monad.when exists (removeDirectoryRecursive p)
+
+    deleteLsmTable =
+      LSM.deleteSnapshot
+        session
+        (fromString $ show (dsNumber ss) <> maybe "" ("_" <>) (dsSuffix ss))
+
+{-------------------------------------------------------------------------------
+  Creating the first handle
+-------------------------------------------------------------------------------}
+
+-- | Read snapshot from disk.
+--
+--   Fail on data corruption, i.e. when the checksum of the read data differs
+--   from the one tracked by @'DiskSnapshot'@.
+loadSnapshot ::
+  forall blk m.
+  ( LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  , IOLike m
+  ) =>
+  Tracer m LedgerDBV2Trace ->
+  ResourceRegistry m ->
+  CodecConfig blk ->
+  SomeHasFS m ->
+  Session m ->
+  DiskSnapshot ->
+  ExceptT (SnapshotFailure blk) m (LedgerSeq' m blk, RealPoint blk)
+loadSnapshot tracer rr ccfg fs session ds =
+  do
+    snapshotMeta <-
+      withExceptT (InitFailureRead . ReadMetadataError (snapshotToMetadataPath ds)) $
+        loadSnapshotMetadata fs ds
+    Monad.when (snapshotBackend snapshotMeta /= UTxOHDLSMSnapshot) $
+      throwE $
+        InitFailureRead $
+          ReadMetadataError (snapshotToMetadataPath ds) MetadataBackendMismatch
+    (extLedgerSt, checksumAsRead) <-
+      withExceptT
+        (InitFailureRead . ReadSnapshotFailed)
+        $ readExtLedgerState fs (decodeDiskExtLedgerState ccfg) decode (snapshotToStatePath ds)
+    case pointToWithOriginRealPoint (castPoint (getTip extLedgerSt)) of
+      Origin -> throwE InitFailureGenesis
+      NotOrigin pt -> do
+        values <-
+          lift $
+            allocate
+              rr
+              ( \_ ->
+                  LSM.openTableFromSnapshot
+                    session
+                    (fromString $ snapshotToDirName ds)
+                    (LSM.SnapshotLabel $ Text.pack $ "UTxO table")
+              )
+              ( \t -> do
+                  traceWith tracer TraceLedgerTablesHandleClose
+                  LSM.closeTable t
+              )
+        Monad.when
+          (checksumAsRead /= snapshotChecksum snapshotMeta)
+          $ throwE
+          $ InitFailureRead
+            ReadSnapshotDataCorruption
+        (,pt)
+          <$> lift (empty extLedgerSt values (newLSMLedgerTablesHandle tracer rr))
+
+-- | Create the initial LSM table from values, which should happen only at
+-- Genesis.
+tableFromValuesMK ::
+  forall m l.
+  (IOLike m, IndexedMemPack (l EmptyMK) (TxOut l), MemPack (TxIn l)) =>
+  Tracer m LedgerDBV2Trace ->
+  ResourceRegistry m ->
+  Session m ->
+  l EmptyMK ->
+  LedgerTables l ValuesMK ->
+  m (ResourceKey m, UTxOTable m)
+tableFromValuesMK tracer rr session st (LedgerTables (ValuesMK values)) = do
+  res@(_, table) <-
+    allocate
+      rr
+      ( \_ ->
+          LSM.newTableWith (LSM.defaultTableConfig{LSM.confFencePointerIndex = LSM.OrdinaryIndex}) session
+      )
+      ( \tb -> do
+          traceWith tracer TraceLedgerTablesHandleClose
+          LSM.closeTable tb
+      )
+  mapM_ (go table) $ chunks 1000 $ Map.toList values
+  pure res
+ where
+  go table items =
+    LSM.inserts table $
+      V.fromListN (length items) $
+        map (\(k, v) -> (toTxInBytes (Proxy @l) k, toTxOutBytes st v, Nothing)) items
+
+{-------------------------------------------------------------------------------
+  Helpers
+-------------------------------------------------------------------------------}
+
+stdMkBlockIOFS ::
+  FilePath -> ResourceRegistry IO -> IO (ResourceKey IO, SomeHasFSAndBlockIO IO)
+stdMkBlockIOFS fastStoragePath rr = do
+  (rk1, bio) <-
+    allocate
+      rr
+      (\_ -> ioHasBlockIO (MountPoint fastStoragePath) defaultIOCtxParams)
+      (BIO.close . snd)
+  pure (rk1, uncurry SomeHasFSAndBlockIO bio)
+
+{-------------------------------------------------------------------------------
+  Backend
+-------------------------------------------------------------------------------}
+
+type data LSM
+
+-- | Create arguments for initializing the LedgerDB using the LSM-trees backend.
+mkLSMArgs ::
+  ( LedgerSupportsProtocol blk
+  , LedgerDbSerialiseConstraints blk
+  ) =>
+  Proxy blk -> FilePath -> FilePath -> StdGen -> (LedgerDbBackendArgs IO blk, StdGen)
+mkLSMArgs _ fp fastStorage gen =
+  let (lsmSalt, gen') = genWord64 gen
+   in ( LedgerDbBackendArgsV2 $
+          SomeBackendArgs $
+            LSMArgs (mkFsPath $ splitDirectories fp) lsmSalt (stdMkBlockIOFS fastStorage)
+      , gen'
+      )
+
+instance
+  ( LedgerSupportsProtocol blk
+  , IOLike m
+  , LedgerDbSerialiseConstraints blk
+  , HasLedgerTables (LedgerState blk)
+  ) =>
+  Backend m LSM blk
+  where
+  data Args m LSM
+    = LSMArgs
+        FsPath
+        -- \^ The file path relative to the fast storage directory in which the LSM
+        -- trees database will be located.
+        Salt
+        (ResourceRegistry m -> m (ResourceKey m, SomeHasFSAndBlockIO m))
+
+  data Resources m LSM = LSMResources
+    { sessionKey :: !(ResourceKey m)
+    , sessionResource :: !(Session m)
+    , blockIOKey :: !(ResourceKey m)
+    }
+    deriving Generic
+
+  data Trace m LSM
+    = LSMTreeTrace !LSM.LSMTreeTrace
+    deriving Show
+
+  mkResources _ trcr (LSMArgs path salt mkFS) reg _ = do
+    (rk1, SomeHasFSAndBlockIO fs blockio) <- mkFS reg
+    session <-
+      allocate
+        reg
+        ( \_ ->
+            LSM.openSession
+              (BackendTrace . SomeBackendTrace . LSMTreeTrace >$< trcr)
+              fs
+              blockio
+              salt
+              path
+        )
+        LSM.closeSession
+    pure (LSMResources (fst session) (snd session) rk1)
+
+  releaseResources _ l = do
+    Monad.void . release . sessionKey $ l
+    Monad.void . release . blockIOKey $ l
+
+  newHandleFromSnapshot trcr reg ccfg shfs res ds = do
+    loadSnapshot trcr reg ccfg shfs (sessionResource res) ds
+
+  newHandleFromValues trcr reg res st = do
+    table <-
+      tableFromValuesMK trcr reg (sessionResource res) (forgetLedgerTables st) (ltprj st)
+    newLSMLedgerTablesHandle trcr reg table
+
+  snapshotManager _ res = Ouroboros.Consensus.Storage.LedgerDB.V2.LSM.snapshotManager (sessionResource res)
+
+instance
+  ( MemPack (TxIn l)
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  , IOLike m
+  ) =>
+  StreamingBackend m LSM l
+  where
+  data YieldArgs m LSM l
+    = -- \| Yield an LSM snapshot
+      YieldLSM
+        Int
+        (LedgerTablesHandle m l)
+
+  data SinkArgs m LSM l
+    = SinkLSM
+        -- \| Chunk size
+        Int
+        -- \| Snap name
+        String
+        (Session m)
+
+  yield _ (YieldLSM chunkSize hdl) = yieldLsmS chunkSize hdl
+
+  sink _ (SinkLSM chunkSize snapName session) = sinkLsmS chunkSize snapName session
+
+data SomeHasFSAndBlockIO m where
+  SomeHasFSAndBlockIO ::
+    (Eq h, Typeable h) => HasFS m h -> BIO.HasBlockIO m h -> SomeHasFSAndBlockIO m
+
+instance IOLike m => NoThunks (Resources m LSM) where
+  wNoThunks ctxt (LSMResources sk _ bk) = wNoThunks ctxt sk >> wNoThunks ctxt bk
+
+{-------------------------------------------------------------------------------
+  Streaming
+-------------------------------------------------------------------------------}
+
+yieldLsmS ::
+  Monad m =>
+  Int ->
+  LedgerTablesHandle m l ->
+  Yield m l
+yieldLsmS readChunkSize tb hint k = do
+  r <- k (go (Nothing, readChunkSize))
+  lift $ S.effects r
+ where
+  go p = do
+    (LedgerTables (ValuesMK values), mx) <- lift $ S.lift $ readRange tb hint p
+    if Map.null values
+      then pure $ pure Nothing
+      else do
+        S.each $ Map.toList values
+        go (mx, readChunkSize)
+
+sinkLsmS ::
+  forall m l.
+  ( MonadAsync m
+  , MonadMVar m
+  , MonadThrow (STM m)
+  , MonadMask m
+  , MonadST m
+  , MonadEvaluate m
+  , MemPack (TxIn l)
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  Int ->
+  String ->
+  Session m ->
+  Sink m l
+sinkLsmS writeChunkSize snapName session st s = do
+  tb :: UTxOTable m <- lift $ LSM.newTable session
+  r <- go tb writeChunkSize mempty s
+  lift $
+    LSM.saveSnapshot
+      (LSM.toSnapshotName snapName)
+      (LSM.SnapshotLabel $ T.pack "UTxO table")
+      tb
+  lift $ LSM.closeTable tb
+  pure (fmap (,Nothing) r)
+ where
+  go tb 0 m s' = do
+    lift $
+      LSM.inserts tb $
+        V.fromList [(toTxInBytes (Proxy @l) k, toTxOutBytes st v, Nothing) | (k, v) <- m]
+    go tb writeChunkSize mempty s'
+  go tb n m s' = do
+    mbs <- S.uncons s'
+    case mbs of
+      Nothing -> do
+        lift $
+          LSM.inserts tb $
+            V.fromList
+              [(toTxInBytes (Proxy @l) k, toTxOutBytes st v, Nothing) | (k, v) <- m]
+        S.effects s'
+      Just (item, s'') -> go tb (n - 1) (item : m) s''
+
+-- | Create Yield arguments for LSM
+mkLSMYieldArgs ::
+  ( IOLike m
+  , HasLedgerTables l
+  , IndexedMemPack (l EmptyMK) (TxOut l)
+  ) =>
+  -- | The filepath in which the LSM database lives. Must not have a trailing slash!
+  FilePath ->
+  -- | The complete name of the snapshot to open, so @<slotno>[_<suffix>]@.
+  String ->
+  -- | Usually 'stdMkBlockIOFS'
+  (FilePath -> ResourceRegistry m -> m (a, SomeHasFSAndBlockIO m)) ->
+  -- | Usually 'newStdGen'
+  (m StdGen) ->
+  l EmptyMK ->
+  ResourceRegistry m ->
+  m (YieldArgs m LSM l)
+mkLSMYieldArgs fp snapName mkFS mkGen _ reg = do
+  (_, SomeHasFSAndBlockIO hasFS blockIO) <- mkFS fp reg
+  salt <- fst . genWord64 <$> mkGen
+  (_, session) <-
+    allocate reg (\_ -> LSM.openSession nullTracer hasFS blockIO salt (mkFsPath [])) LSM.closeSession
+  tb <-
+    allocate
+      reg
+      ( \_ ->
+          LSM.openTableFromSnapshot
+            session
+            (LSM.toSnapshotName snapName)
+            (LSM.SnapshotLabel $ T.pack "UTxO table")
+      )
+      LSM.closeTable
+  YieldLSM 1000 <$> newLSMLedgerTablesHandle nullTracer reg tb
+
+-- | Create Sink arguments for LSM
+mkLSMSinkArgs ::
+  IOLike m =>
+  -- | The filepath in which the LSM database should be opened. Must not have a trailing slash!
+  FilePath ->
+  -- | The complete name of the snapshot to be created, so @<slotno>[_<suffix>]@.
+  String ->
+  -- | Usually 'stdMkBlockIOFS'
+  (FilePath -> ResourceRegistry m -> m (a, SomeHasFSAndBlockIO m)) ->
+  -- | Usually 'newStdGen'
+  (m StdGen) ->
+  l EmptyMK ->
+  ResourceRegistry m ->
+  m (SinkArgs m LSM l)
+mkLSMSinkArgs
+  (splitFileName -> (fp, lsmDir))
+  snapName
+  mkFS
+  mkGen
+  _
+  reg =
+    do
+      (_, SomeHasFSAndBlockIO hasFS blockIO) <- mkFS fp reg
+      removeDirectoryRecursive hasFS lsmFsPath
+      createDirectory hasFS lsmFsPath
+      salt <- fst . genWord64 <$> mkGen
+      (_, session) <-
+        allocate reg (\_ -> LSM.newSession nullTracer hasFS blockIO salt lsmFsPath) LSM.closeSession
+      pure (SinkLSM 1000 snapName session)
+   where
+    lsmFsPath = mkFsPath [lsmDir]
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block.hs
index 0ee718be4..7c8b020e3 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block.hs
@@ -8,5 +8,6 @@ import Ouroboros.Consensus.Block.NestedContent as X
 import Ouroboros.Consensus.Block.RealPoint as X
 import Ouroboros.Consensus.Block.SupportsDiffusionPipelining as X
 import Ouroboros.Consensus.Block.SupportsMetrics as X
+import Ouroboros.Consensus.Block.SupportsPeras as X
 import Ouroboros.Consensus.Block.SupportsProtocol as X
 import Ouroboros.Consensus.Block.SupportsSanityCheck as X
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/Forging.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/Forging.hs
index ec05ba26a..a73a18da1 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/Forging.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/Forging.hs
@@ -10,6 +10,7 @@
 
 module Ouroboros.Consensus.Block.Forging
   ( BlockForging (..)
+  , MkBlockForging (..)
   , CannotForge
   , ForgeStateInfo
   , ForgeStateUpdateError
@@ -141,8 +142,23 @@ data BlockForging m blk = BlockForging
   -- even when used as part of the hard fork combinator.
   --
   -- PRECONDITION: 'checkCanForge' returned @Right ()@.
+  , finalize :: m ()
+  -- ^ Clean up any unmanaged resources.
+  --
+  -- Such resources may include KES keys that require explicit erasing
+  -- ("secure forgetting"), and threads that connect to a KES agent.
+  -- This method will be run once when the block forging thread
+  -- terminates, whether cleanly or due to an exception.
   }
 
+-- | 'MkBlockForging' is a wrapper around a monadic action that allocates a
+-- 'BlockForging', potentially allocating other linked resources like KES
+-- HotKeys, that *MUST* be finalized when the 'BlockForging' is no longer in
+-- use. Users of this code must call the 'finalize' function on the returned 'BlockForging' at least once after terminating otherwise allocated resources
+-- may leak.
+newtype MkBlockForging m blk
+  = MkBlockForging {mkBlockForging :: m (BlockForging m blk)}
+
 data ShouldForge blk
   = -- | Before check whether we are a leader in this slot, we tried to update
     --  our forge state ('updateForgeState'), but it failed. We will not check
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/SupportsPeras.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/SupportsPeras.hs
new file mode 100644
index 000000000..bdfd9c826
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Block/SupportsPeras.hs
@@ -0,0 +1,185 @@
+{-# LANGUAGE DeriveAnyClass #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
+
+module Ouroboros.Consensus.Block.SupportsPeras
+  ( PerasRoundNo (..)
+  , PerasWeight (..)
+  , boostPerCert
+  , BlockSupportsPeras (..)
+  , PerasCert (..)
+  , ValidatedPerasCert (..)
+  , makePerasCfg
+  , HasPerasCert (..)
+  , getPerasCertRound
+  , getPerasCertBoostedBlock
+  , getPerasCertBoost
+
+    -- * Ouroboros Peras round length
+  , PerasRoundLength (..)
+  , defaultPerasRoundLength
+  ) where
+
+import Codec.Serialise (Serialise (..))
+import Codec.Serialise.Decoding (decodeListLenOf)
+import Codec.Serialise.Encoding (encodeListLen)
+import Data.Monoid (Sum (..))
+import Data.Proxy (Proxy (..))
+import Data.Word (Word64)
+import GHC.Generics (Generic)
+import NoThunks.Class
+import Ouroboros.Consensus.Block.Abstract
+import Ouroboros.Consensus.Util
+import Ouroboros.Consensus.Util.Condense
+import Quiet (Quiet (..))
+
+newtype PerasRoundNo = PerasRoundNo {unPerasRoundNo :: Word64}
+  deriving Show via Quiet PerasRoundNo
+  deriving stock Generic
+  deriving newtype (Enum, Eq, Ord, NoThunks, Serialise)
+
+instance Condense PerasRoundNo where
+  condense = show . unPerasRoundNo
+
+instance ShowProxy PerasRoundNo where
+  showProxy _ = "PerasRoundNo"
+
+newtype PerasWeight = PerasWeight {unPerasWeight :: Word64}
+  deriving Show via Quiet PerasWeight
+  deriving stock Generic
+  deriving newtype (Eq, Ord, NoThunks)
+  deriving (Semigroup, Monoid) via Sum Word64
+
+instance Condense PerasWeight where
+  condense = show . unPerasWeight
+
+-- | TODO: this will become a Ledger protocol parameter
+-- see https://github.com/tweag/cardano-peras/issues/119
+boostPerCert :: PerasWeight
+boostPerCert = PerasWeight 15
+
+-- TODO using 'Validated' for extra safety? Or some @.Unsafe@ module?
+data ValidatedPerasCert blk = ValidatedPerasCert
+  { vpcCert :: !(PerasCert blk)
+  , vpcCertBoost :: !PerasWeight
+  }
+  deriving stock (Show, Eq, Ord, Generic)
+  deriving anyclass NoThunks
+
+{-------------------------------------------------------------------------------
+  Ouroboros Peras round length
+-------------------------------------------------------------------------------}
+
+newtype PerasRoundLength = PerasRoundLength {unPerasRoundLength :: Word64}
+  deriving stock (Show, Eq, Ord)
+  deriving newtype (NoThunks, Num)
+
+-- | See the Protocol parameters section of the Peras design report:
+--   https://tweag.github.io/cardano-peras/peras-design.pdf#section.2.1
+-- TODO: this will become a Ledger protocol parameter
+-- see https://github.com/tweag/cardano-peras/issues/119
+defaultPerasRoundLength :: PerasRoundLength
+defaultPerasRoundLength = 90
+
+class
+  ( Show (PerasCfg blk)
+  , NoThunks (PerasCert blk)
+  ) =>
+  BlockSupportsPeras blk
+  where
+  data PerasCfg blk
+
+  data PerasCert blk
+
+  data PerasValidationErr blk
+
+  validatePerasCert ::
+    PerasCfg blk ->
+    PerasCert blk ->
+    Either (PerasValidationErr blk) (ValidatedPerasCert blk)
+
+-- TODO: degenerate instance for all blks to get things to compile
+-- see https://github.com/tweag/cardano-peras/issues/73
+instance StandardHash blk => BlockSupportsPeras blk where
+  newtype PerasCfg blk = PerasCfg
+    { -- TODO: eventually, this will come from the
+      -- protocol parameters from the ledger state
+      -- see https://github.com/tweag/cardano-peras/issues/119
+      perasCfgWeightBoost :: PerasWeight
+    }
+    deriving stock (Show, Eq)
+
+  data PerasCert blk = PerasCert
+    { pcCertRound :: PerasRoundNo
+    , pcCertBoostedBlock :: Point blk
+    }
+    deriving stock (Generic, Eq, Ord, Show)
+    deriving anyclass NoThunks
+
+  -- TODO: enrich with actual error types
+  -- see https://github.com/tweag/cardano-peras/issues/120
+  data PerasValidationErr blk
+    = PerasValidationErr
+    deriving stock (Show, Eq)
+
+  -- TODO: perform actual validation against all
+  -- possible 'PerasValidationErr' variants
+  -- see https://github.com/tweag/cardano-peras/issues/120
+  validatePerasCert cfg cert =
+    Right
+      ValidatedPerasCert
+        { vpcCert = cert
+        , vpcCertBoost = perasCfgWeightBoost cfg
+        }
+
+instance ShowProxy blk => ShowProxy (PerasCert blk) where
+  showProxy _ = "PerasCert " <> showProxy (Proxy @blk)
+
+instance Serialise (HeaderHash blk) => Serialise (PerasCert blk) where
+  encode PerasCert{pcCertRound, pcCertBoostedBlock} =
+    encodeListLen 2
+      <> encode pcCertRound
+      <> encode pcCertBoostedBlock
+  decode = do
+    decodeListLenOf 2
+    pcCertRound <- decode
+    pcCertBoostedBlock <- decode
+    pure $ PerasCert{pcCertRound, pcCertBoostedBlock}
+
+-- | Derive a 'PerasCfg' from a 'BlockConfig'
+--
+-- TODO: this currently doesn't depend on 'BlockConfig' at all, but likely will
+-- depend on it in the future
+-- see https://github.com/tweag/cardano-peras/issues/73
+makePerasCfg :: Maybe (BlockConfig blk) -> PerasCfg blk
+makePerasCfg _ =
+  PerasCfg
+    { perasCfgWeightBoost = boostPerCert
+    }
+
+class StandardHash blk => HasPerasCert cert blk where
+  getPerasCert :: cert blk -> PerasCert blk
+
+instance StandardHash blk => HasPerasCert PerasCert blk where
+  getPerasCert = id
+
+instance StandardHash blk => HasPerasCert ValidatedPerasCert blk where
+  getPerasCert = vpcCert
+
+getPerasCertRound :: HasPerasCert cert blk => cert blk -> PerasRoundNo
+getPerasCertRound = pcCertRound . getPerasCert
+
+getPerasCertBoostedBlock :: HasPerasCert cert blk => cert blk -> Point blk
+getPerasCertBoostedBlock = pcCertBoostedBlock . getPerasCert
+
+getPerasCertBoost :: ValidatedPerasCert blk -> PerasWeight
+getPerasCertBoost = vpcCertBoost
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Config/SecurityParam.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Config/SecurityParam.hs
index bebe022e8..ce06787e5 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Config/SecurityParam.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Config/SecurityParam.hs
@@ -3,24 +3,42 @@
 {-# LANGUAGE GeneralizedNewtypeDeriving #-}
 {-# OPTIONS_GHC -Wno-orphans #-}
 
-module Ouroboros.Consensus.Config.SecurityParam (SecurityParam (..)) where
+module Ouroboros.Consensus.Config.SecurityParam
+  ( SecurityParam (..)
+  , maxRollbackWeight
+  ) where
 
 import Cardano.Binary
 import Cardano.Ledger.BaseTypes.NonZero
 import Data.Word
 import GHC.Generics (Generic)
 import NoThunks.Class (NoThunks)
+import Ouroboros.Consensus.Block.SupportsPeras (PerasWeight (..))
 import Quiet
 
 -- | Protocol security parameter
 --
--- We interpret this as the number of rollbacks we support.
+-- In longest-chain protocols, we interpret this as the number of rollbacks we
+-- support.
 --
 -- i.e., k == 1: we can roll back at most one block
 --       k == 2: we can roll back at most two blocks, etc
 --
 -- NOTE: This talks about the number of /blocks/ we can roll back, not
 -- the number of /slots/.
+--
+-- In weightiest-chain protocols (such as Ouroboros Peras), we interpret this as
+-- the maximum amount of weight we can roll back. Here, the total weight of a
+-- chain (fragment) is defined to be its length plus the sum of all weight
+-- boosts given to some of its blocks on the chain (fragment).
+--
+-- i.e. k == 30: we can roll back at most 30 unweighted blocks, or two blocks
+-- each having additional weight 14. In the latter case, the chain fragment has
+-- total weight @2 + 2 * 14 = 30@.
 newtype SecurityParam = SecurityParam {maxRollbacks :: NonZero Word64}
   deriving (Eq, Generic, NoThunks, ToCBOR, FromCBOR)
   deriving Show via Quiet SecurityParam
+
+-- | The maximum amount of weight we can roll back.
+maxRollbackWeight :: SecurityParam -> PerasWeight
+maxRollbackWeight = PerasWeight . unNonZero . maxRollbacks
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/Diff.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/Diff.hs
index 1521969d4..1cd42db9d 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/Diff.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/Diff.hs
@@ -35,6 +35,7 @@ module Ouroboros.Consensus.Fragment.Diff
 import Data.Word (Word64)
 import GHC.Stack (HasCallStack)
 import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight
 import Ouroboros.Network.AnchoredFragment
   ( AnchoredFragment
   , AnchoredSeq (..)
@@ -73,12 +74,31 @@ getTip = castPoint . AF.headPoint . getSuffix
 getAnchorPoint :: ChainDiff b -> Point b
 getAnchorPoint = castPoint . AF.anchorPoint . getSuffix
 
--- | Return 'True' iff applying the 'ChainDiff' to a chain @C@ will result in
--- a chain shorter than @C@, i.e., the number of blocks to roll back is
--- greater than the length of the new elements in the suffix to add.
-rollbackExceedsSuffix :: HasHeader b => ChainDiff b -> Bool
-rollbackExceedsSuffix (ChainDiff nbRollback suffix) =
-  nbRollback > fromIntegral (AF.length suffix)
+-- | Return 'True' iff applying the 'ChainDiff' to the given chain @C@ will
+-- result in a chain with less weight than @C@, i.e., the suffix of @C@ to roll
+-- back has more weight than suffix is adding.
+rollbackExceedsSuffix ::
+  forall b0 b1 b2.
+  ( HasHeader b0
+  , HasHeader b1
+  , HasHeader b2
+  , HeaderHash b0 ~ HeaderHash b1
+  , HeaderHash b0 ~ HeaderHash b2
+  ) =>
+  PerasWeightSnapshot b0 ->
+  -- | The chain @C@ the diff is applied to.
+  AnchoredFragment b1 ->
+  ChainDiff b2 ->
+  Bool
+rollbackExceedsSuffix weights curChain (ChainDiff nbRollback suffix) =
+  weightOf suffixToRollBack > weightOf suffix
+ where
+  suffixToRollBack = AF.anchorNewest nbRollback curChain
+
+  weightOf ::
+    (HasHeader b, HeaderHash b ~ HeaderHash b0) =>
+    AnchoredFragment b -> PerasWeight
+  weightOf = totalWeightOfFragment weights
 
 {-------------------------------------------------------------------------------
   Constructors
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/ValidatedDiff.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/ValidatedDiff.hs
index 0d31d8f3f..0a18a5430 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/ValidatedDiff.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Fragment/ValidatedDiff.hs
@@ -13,7 +13,6 @@ module Ouroboros.Consensus.Fragment.ValidatedDiff
   , getChainDiff
   , getLedger
   , new
-  , rollbackExceedsSuffix
   , toValidatedFragment
 
     -- * Monadic
@@ -96,9 +95,6 @@ toValidatedFragment ::
 toValidatedFragment (UnsafeValidatedChainDiff cs l) =
   VF.ValidatedFragment (Diff.getSuffix cs) l
 
-rollbackExceedsSuffix :: HasHeader b => ValidatedChainDiff b l -> Bool
-rollbackExceedsSuffix = Diff.rollbackExceedsSuffix . getChainDiff
-
 {-------------------------------------------------------------------------------
   Monadic
 -------------------------------------------------------------------------------}
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Abstract.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Abstract.hs
index 7498024f6..b2a07369d 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Abstract.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Abstract.hs
@@ -67,6 +67,6 @@ neverForksHardForkSummary ::
   LedgerState blk mk ->
   HardFork.Summary '[blk]
 neverForksHardForkSummary getParams cfg _st =
-  HardFork.neverForksSummary eraEpochSize eraSlotLength eraGenesisWin
+  HardFork.neverForksSummary eraEpochSize eraSlotLength eraGenesisWin eraPerasRoundLength
  where
   HardFork.EraParams{..} = getParams cfg
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Binary.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Binary.hs
index 48c66660c..03e9d271e 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Binary.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Binary.hs
@@ -3,15 +3,18 @@
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeFamilies #-}
 
 module Ouroboros.Consensus.HardFork.Combinator.Embed.Binary (protocolInfoBinary) where
 
 import Control.Exception (assert)
+import qualified Control.Tracer as Tracer
 import Data.Align (alignWith)
 import Data.SOP.Counting (exactlyTwo)
 import Data.SOP.Functors (Flip (..))
-import Data.SOP.OptNP (OptNP (..))
+import Data.SOP.OptNP (NonEmptyOptNP, OptNP (..))
 import Data.SOP.Strict (NP (..))
+import Data.Text (Text)
 import Data.These (These (..))
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
@@ -29,22 +32,22 @@ import Ouroboros.Consensus.TypeFamilyWrappers
 -------------------------------------------------------------------------------}
 
 protocolInfoBinary ::
-  forall m blk1 blk2.
+  forall m kesAgentTrace blk1 blk2.
   (CanHardFork '[blk1, blk2], Monad m) =>
   -- First era
   ProtocolInfo blk1 ->
-  m [BlockForging m blk1] ->
+  (Tracer.Tracer m kesAgentTrace -> m [MkBlockForging m blk1]) ->
   History.EraParams ->
   (ConsensusConfig (BlockProtocol blk1) -> PartialConsensusConfig (BlockProtocol blk1)) ->
   (LedgerConfig blk1 -> PartialLedgerConfig blk1) ->
   -- Second era
   ProtocolInfo blk2 ->
-  m [BlockForging m blk2] ->
+  (Tracer.Tracer m kesAgentTrace -> m [MkBlockForging m blk2]) ->
   History.EraParams ->
   (ConsensusConfig (BlockProtocol blk2) -> PartialConsensusConfig (BlockProtocol blk2)) ->
   (LedgerConfig blk2 -> PartialLedgerConfig blk2) ->
   ( ProtocolInfo (HardForkBlock '[blk1, blk2])
-  , m [BlockForging m (HardForkBlock '[blk1, blk2])]
+  , Tracer.Tracer m kesAgentTrace -> m [MkBlockForging m (HardForkBlock '[blk1, blk2])]
   )
 protocolInfoBinary
   protocolInfo1
@@ -107,7 +110,7 @@ protocolInfoBinary
                         headerStateChainDep initHeaderState1
               }
         }
-    , alignWith alignBlockForging <$> blockForging1 <*> blockForging2
+    , \tr -> alignWith alignBlockForging <$> blockForging1 tr <*> blockForging2 tr
     )
    where
     ProtocolInfo
@@ -146,18 +149,24 @@ protocolInfoBinary
     shape = History.Shape $ exactlyTwo eraParams1 eraParams2
 
     alignBlockForging ::
-      These (BlockForging m blk1) (BlockForging m blk2) ->
-      BlockForging m (HardForkBlock '[blk1, blk2])
+      These (MkBlockForging m blk1) (MkBlockForging m blk2) ->
+      MkBlockForging m (HardForkBlock '[blk1, blk2])
     alignBlockForging = \case
       This bf1 ->
         hardForkBlockForging
-          (forgeLabel bf1)
+          mkForgeLabel
           (OptCons bf1 $ OptSkip OptNil)
       That bf2 ->
         hardForkBlockForging
-          (forgeLabel bf2)
+          mkForgeLabel
           (OptSkip $ OptCons bf2 OptNil)
       These bf1 bf2 ->
         hardForkBlockForging
-          (forgeLabel bf1 <> "-" <> forgeLabel bf2)
+          mkForgeLabel
           (OptCons bf1 $ OptCons bf2 OptNil)
+
+    mkForgeLabel :: NonEmptyOptNP (BlockForging m) '[blk1, blk2] -> Text
+    mkForgeLabel = \case
+      OptCons bf1 (OptCons bf2 OptNil) -> forgeLabel bf1 <> "-" <> forgeLabel bf2
+      OptCons bf1 (OptSkip OptNil) -> forgeLabel bf1
+      OptSkip (OptCons bf2 OptNil) -> forgeLabel bf2
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Unary.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Unary.hs
index f720673d5..2186ee5a4 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Unary.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Embed/Unary.hs
@@ -434,6 +434,7 @@ instance Functor m => Isomorphic (BlockForging m) where
     BlockForging
       { forgeLabel = forgeLabel
       , canBeLeader = project' (Proxy @(WrapCanBeLeader blk)) canBeLeader
+      , finalize = finalize
       , updateForgeState = \cfg sno tickedChainDepSt ->
           project
             <$> updateForgeState
@@ -485,6 +486,7 @@ instance Functor m => Isomorphic (BlockForging m) where
     BlockForging
       { forgeLabel = forgeLabel
       , canBeLeader = inject' (Proxy @(WrapCanBeLeader blk)) canBeLeader
+      , finalize = finalize
       , updateForgeState = \cfg sno tickedChainDepSt ->
           inject
             <$> updateForgeState
@@ -519,6 +521,12 @@ instance Functor m => Isomorphic (BlockForging m) where
         . State.fromTZ
         . tickedHardForkChainDepStatePerEra
 
+instance Functor m => Isomorphic (MkBlockForging m) where
+  project (MkBlockForging blockForgingM) =
+    MkBlockForging $ project <$> blockForgingM
+  inject (MkBlockForging blockForgingM) =
+    MkBlockForging $ inject <$> blockForgingM
+
 instance Isomorphic ProtocolInfo where
   project ::
     forall blk.
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Forging.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Forging.hs
index a8f60c355..939a4c08c 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Forging.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/Combinator/Forging.hs
@@ -14,9 +14,12 @@ module Ouroboros.Consensus.HardFork.Combinator.Forging
   , hardForkBlockForging
   ) where
 
+import Control.Monad (void)
 import Data.Functor.Product
 import Data.Maybe (fromMaybe)
+import Data.SOP (Top)
 import Data.SOP.BasicFunctors
+import Data.SOP.Constraint (All)
 import Data.SOP.Functors (Product2 (..))
 import Data.SOP.InPairs (InPairs)
 import qualified Data.SOP.InPairs as InPairs
@@ -79,17 +82,20 @@ hardForkBlockForging ::
   (CanHardFork xs, Monad m) =>
   -- | Used as the 'forgeLabel', the labels of the given 'BlockForging's will
   -- be ignored.
-  Text ->
-  NonEmptyOptNP (BlockForging m) xs ->
-  BlockForging m (HardForkBlock xs)
-hardForkBlockForging label blockForging =
-  BlockForging
-    { forgeLabel = label
-    , canBeLeader = hardForkCanBeLeader blockForging
-    , updateForgeState = hardForkUpdateForgeState blockForging
-    , checkCanForge = hardForkCheckCanForge blockForging
-    , forgeBlock = hardForkForgeBlock blockForging
-    }
+  (NonEmptyOptNP (BlockForging m) xs -> Text) ->
+  NonEmptyOptNP (MkBlockForging m) xs ->
+  MkBlockForging m (HardForkBlock xs)
+hardForkBlockForging labelF mkBlockForgings = MkBlockForging $ do
+  blockForgings <- htraverse' mkBlockForging mkBlockForgings
+  pure
+    BlockForging
+      { forgeLabel = labelF blockForgings
+      , canBeLeader = hardForkCanBeLeader blockForgings
+      , updateForgeState = hardForkUpdateForgeState blockForgings
+      , checkCanForge = hardForkCheckCanForge blockForgings
+      , forgeBlock = hardForkForgeBlock blockForgings
+      , finalize = hardForkFinalize blockForgings
+      }
 
 hardForkCanBeLeader ::
   CanHardFork xs =>
@@ -98,6 +104,12 @@ hardForkCanBeLeader =
   SomeErasCanBeLeader
     . hmap (WrapCanBeLeader . canBeLeader)
 
+hardForkFinalize ::
+  (Monad m, All Top xs) =>
+  NonEmptyOptNP (BlockForging m) xs -> m ()
+hardForkFinalize blockForging =
+  void $ htraverse_ finalize blockForging
+
 -- | POSTCONDITION: the returned 'ForgeStateUpdateInfo' is from the same era as
 -- the ticked 'ChainDepState'.
 hardForkUpdateForgeState ::
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/EraParams.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/EraParams.hs
index e0784c8d3..4bcbc7778 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/EraParams.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/EraParams.hs
@@ -1,9 +1,13 @@
+{-# LANGUAGE BangPatterns #-}
 {-# LANGUAGE DeriveAnyClass #-}
+{-# LANGUAGE DeriveFunctor #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingStrategies #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GeneralisedNewtypeDeriving #-}
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE PatternSynonyms #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE UndecidableInstances #-}
@@ -12,17 +16,23 @@ module Ouroboros.Consensus.HardFork.History.EraParams
   ( -- * API
     EraParams (..)
   , SafeZone (..)
+  , PerasEnabled
+  , pattern PerasEnabled
+  , pattern NoPerasEnabled
+  , PerasEnabledT (..)
+  , fromPerasEnabled
 
     -- * Defaults
   , defaultEraParams
   ) where
 
-import Cardano.Binary (enforceSize)
+import Cardano.Binary (DecoderError (DecoderErrorCustom), cborError)
 import Cardano.Ledger.BaseTypes (unNonZero)
 import Codec.CBOR.Decoding (Decoder, decodeListLen, decodeWord8)
 import Codec.CBOR.Encoding (Encoding, encodeListLen, encodeWord8)
 import Codec.Serialise (Serialise (..))
-import Control.Monad (void)
+import Control.Monad (ap, liftM, void)
+import Control.Monad.Trans.Class
 import Data.Word
 import GHC.Generics (Generic)
 import NoThunks.Class (NoThunks)
@@ -136,10 +146,57 @@ data EraParams = EraParams
   , eraSlotLength :: !SlotLength
   , eraSafeZone :: !SafeZone
   , eraGenesisWin :: !GenesisWindow
+  , eraPerasRoundLength :: !(PerasEnabled PerasRoundLength)
+  -- ^ Optional, as not every era will be Peras-enabled
   }
   deriving stock (Show, Eq, Generic)
   deriving anyclass NoThunks
 
+-- | A marker for era parameters that are Peras-specific
+--   and are not present in pre-Peras eras
+newtype PerasEnabled a = MkPerasEnabled (Maybe a)
+  deriving stock (Show, Eq, Ord, Generic)
+  deriving anyclass NoThunks
+  deriving newtype (Functor, Applicative, Monad)
+
+pattern PerasEnabled :: a -> PerasEnabled a
+pattern PerasEnabled x <- MkPerasEnabled (Just !x)
+  where
+    PerasEnabled !x = MkPerasEnabled (Just x)
+
+pattern NoPerasEnabled :: PerasEnabled a
+pattern NoPerasEnabled = MkPerasEnabled Nothing
+
+{-# COMPLETE PerasEnabled, NoPerasEnabled #-}
+
+-- | A 'fromMaybe'-like eliminator for 'PerasEnabled'
+fromPerasEnabled :: a -> PerasEnabled a -> a
+fromPerasEnabled defaultValue =
+  \case
+    NoPerasEnabled -> defaultValue
+    PerasEnabled value -> value
+
+-- | A 'MaybeT'-line monad transformer.
+--
+--   Used solely for the Peras-related hard fork combinator queries,
+--   see 'Ouroboros.Consensus.HardFork.History.Qry'.
+newtype PerasEnabledT m a = PerasEnabledT {runPerasEnabledT :: m (PerasEnabled a)}
+  deriving stock Functor
+
+instance (Functor m, Monad m) => Applicative (PerasEnabledT m) where
+  pure = PerasEnabledT . pure . PerasEnabled
+  (<*>) = ap
+
+instance Monad m => Monad (PerasEnabledT m) where
+  x >>= f = PerasEnabledT $ do
+    v <- runPerasEnabledT x
+    case v of
+      NoPerasEnabled -> pure NoPerasEnabled
+      PerasEnabled y -> runPerasEnabledT (f y)
+
+instance MonadTrans PerasEnabledT where
+  lift = PerasEnabledT . liftM PerasEnabled
+
 -- | Default 'EraParams'
 --
 -- We set
@@ -147,6 +204,7 @@ data EraParams = EraParams
 -- * epoch size to @10k@ slots
 -- * the safe zone to @2k@ slots
 -- * the upper bound to 'NoLowerBound'
+-- * the Peras Round Length is unset
 --
 -- This is primarily useful for tests.
 defaultEraParams :: SecurityParam -> SlotLength -> EraParams
@@ -156,6 +214,8 @@ defaultEraParams (SecurityParam k) slotLength =
     , eraSlotLength = slotLength
     , eraSafeZone = StandardSafeZone (unNonZero k * 2)
     , eraGenesisWin = GenesisWindow (unNonZero k * 2)
+    , -- Peras is disabled by default
+      eraPerasRoundLength = NoPerasEnabled
     }
 
 -- | Zone in which it is guaranteed that no hard fork can take place
@@ -235,17 +295,27 @@ decodeSafeBeforeEpoch = do
 instance Serialise EraParams where
   encode EraParams{..} =
     mconcat $
-      [ encodeListLen 4
+      [ encodeListLen $ case eraPerasRoundLength of
+          NoPerasEnabled -> 4
+          PerasEnabled{} -> 5
       , encode (unEpochSize eraEpochSize)
       , encode eraSlotLength
       , encode eraSafeZone
       , encode (unGenesisWindow eraGenesisWin)
       ]
+        <> case eraPerasRoundLength of
+          NoPerasEnabled -> []
+          PerasEnabled rl -> [encode (unPerasRoundLength rl)]
 
   decode = do
-    enforceSize "EraParams" 4
+    len <- decodeListLen
     eraEpochSize <- EpochSize <$> decode
     eraSlotLength <- decode
     eraSafeZone <- decode
     eraGenesisWin <- GenesisWindow <$> decode
+    eraPerasRoundLength <-
+      case len of
+        4 -> pure NoPerasEnabled
+        5 -> PerasEnabled . PerasRoundLength <$> decode
+        _ -> cborError (DecoderErrorCustom "EraParams" "unexpected list length")
     return EraParams{..}
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Qry.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Qry.hs
index 9c4844c75..786c26943 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Qry.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Qry.hs
@@ -42,12 +42,15 @@ module Ouroboros.Consensus.HardFork.History.Qry
   , slotToSlotLength
   , slotToWallclock
   , wallclockToSlot
+  , perasRoundNoToSlot
+  , slotToPerasRoundNo
   ) where
 
 import Codec.Serialise (Serialise (..))
 import Control.Exception (throw)
 import Control.Monad (ap, guard, liftM, (>=>))
 import Control.Monad.Except ()
+import Control.Monad.Trans.Class
 import Data.Bifunctor
 import Data.Fixed (divMod')
 import Data.Foldable (toList)
@@ -126,6 +129,8 @@ import Quiet
 
       These are equal by (INV-2a).
 
+   5. Slot to Peras round translation.
+
   This means that for values at that boundary, it does not matter if we use
   this era or the next era for the translation. However, this is only true for
   these 4 translations. If we are returning the era parameters directly, then
@@ -182,12 +187,16 @@ newtype TimeInSlot = TimeInSlot {getTimeInSlot :: NominalDiffTime} deriving Gene
 newtype SlotInEra = SlotInEra {getSlotInEra :: Word64} deriving Generic
 newtype SlotInEpoch = SlotInEpoch {getSlotInEpoch :: Word64} deriving Generic
 newtype EpochInEra = EpochInEra {getEpochInEra :: Word64} deriving Generic
+newtype PerasRoundNoInEra = PerasRoundNoInEra {getPerasRoundNoInEra :: Word64} deriving Generic
+newtype SlotInPerasRound = SlotInPerasRound {getSlotInPerasRound :: Word64} deriving Generic
 
 deriving via Quiet TimeInEra instance Show TimeInEra
 deriving via Quiet TimeInSlot instance Show TimeInSlot
 deriving via Quiet SlotInEra instance Show SlotInEra
 deriving via Quiet SlotInEpoch instance Show SlotInEpoch
 deriving via Quiet EpochInEra instance Show EpochInEra
+deriving via Quiet PerasRoundNoInEra instance Show PerasRoundNoInEra
+deriving via Quiet SlotInPerasRound instance Show SlotInPerasRound
 
 {-------------------------------------------------------------------------------
   Expressions
@@ -212,23 +221,30 @@ data Expr (f :: Type -> Type) :: Type -> Type where
   EAbsToRelTime :: Expr f RelativeTime -> Expr f TimeInEra
   EAbsToRelSlot :: Expr f SlotNo -> Expr f SlotInEra
   EAbsToRelEpoch :: Expr f EpochNo -> Expr f EpochInEra
+  EAbsToRelPerasRoundNo :: Expr f PerasRoundNo -> Expr f (PerasEnabled PerasRoundNoInEra)
   -- Convert from era-relative to absolute
 
   ERelToAbsTime :: Expr f TimeInEra -> Expr f RelativeTime
   ERelToAbsSlot :: Expr f (SlotInEra, TimeInSlot) -> Expr f SlotNo
   ERelToAbsEpoch :: Expr f (EpochInEra, SlotInEpoch) -> Expr f EpochNo
+  ERelToAbsPerasRoundNo ::
+    Expr f (PerasEnabled PerasRoundNoInEra) -> Expr f (PerasEnabled PerasRoundNo)
   -- Convert between relative values
 
   ERelTimeToSlot :: Expr f TimeInEra -> Expr f (SlotInEra, TimeInSlot)
   ERelSlotToTime :: Expr f SlotInEra -> Expr f TimeInEra
   ERelSlotToEpoch :: Expr f SlotInEra -> Expr f (EpochInEra, SlotInEpoch)
   ERelEpochToSlot :: Expr f EpochInEra -> Expr f SlotInEra
+  ERelPerasRoundNoToSlot :: Expr f (PerasEnabled PerasRoundNoInEra) -> Expr f (PerasEnabled SlotInEra)
+  ERelSlotToPerasRoundNo ::
+    Expr f SlotInEra -> Expr f (PerasEnabled (PerasRoundNoInEra, SlotInPerasRound))
   -- Get era parameters
 
   -- The arguments are used for bound checks
   ESlotLength :: Expr f SlotNo -> Expr f SlotLength
   EEpochSize :: Expr f EpochNo -> Expr f EpochSize
   EGenesisWindow :: Expr f SlotNo -> Expr f GenesisWindow
+  EPerasRoundLength :: Expr f PerasRoundNo -> Expr f (PerasEnabled PerasRoundLength)
 
 {-------------------------------------------------------------------------------
   Interpreter
@@ -247,6 +263,11 @@ evalExprInEra EraSummary{..} = \(ClosedExpr e) -> go e
       EraUnbounded -> return ()
       EraEnd b -> guard $ p b
 
+  guardEndPeras :: (Bound -> PerasEnabledT Maybe Bool) -> PerasEnabledT Maybe ()
+  guardEndPeras p = case eraEnd of
+    EraUnbounded -> pure ()
+    EraEnd end -> lift . guard =<< p end
+
   go :: Expr Identity a -> Maybe a
   go (EVar a) =
     return $ runIdentity a
@@ -279,6 +300,13 @@ evalExprInEra EraSummary{..} = \(ClosedExpr e) -> go e
     e <- go expr
     guard (e >= boundEpoch eraStart)
     return $ EpochInEra (countEpochs e (boundEpoch eraStart))
+  go (EAbsToRelPerasRoundNo expr) =
+    runPerasEnabledT $ do
+      eraStartPerasRound <- PerasEnabledT . Just $ boundPerasRound eraStart
+      absPerasRoundNo <- lift $ go expr
+      lift . guard $ absPerasRoundNo >= eraStartPerasRound
+      let roundInEra = countPerasRounds absPerasRoundNo eraStartPerasRound
+      pure . PerasRoundNoInEra $ roundInEra
 
   -- Convert relative to absolute
   --
@@ -304,6 +332,15 @@ evalExprInEra EraSummary{..} = \(ClosedExpr e) -> go e
       absEpoch < boundEpoch end
         || absEpoch == boundEpoch end && getSlotInEpoch s == 0
     return absEpoch
+  go (ERelToAbsPerasRoundNo expr) = runPerasEnabledT $ do
+    eraStartPerasRound <- PerasEnabledT . Just $ boundPerasRound eraStart
+    relPerasRound <- PerasEnabledT $ go expr
+    let absPerasRound = addPerasRounds (getPerasRoundNoInEra relPerasRound) eraStartPerasRound
+
+    guardEndPeras $ \end -> do
+      eraEndPerasRound <- PerasEnabledT . Just $ boundPerasRound end
+      pure $ absPerasRound <= eraEndPerasRound
+    pure absPerasRound
 
   -- Convert between relative values
   --
@@ -321,6 +358,14 @@ evalExprInEra EraSummary{..} = \(ClosedExpr e) -> go e
   go (ERelEpochToSlot expr) = do
     e <- go expr
     return $ SlotInEra (getEpochInEra e * epochSize)
+  go (ERelPerasRoundNoToSlot expr) = runPerasEnabledT $ do
+    PerasRoundNoInEra relPerasRoundNo <- PerasEnabledT $ go expr
+    PerasRoundLength perasRoundLength <- PerasEnabledT . Just $ eraPerasRoundLength
+    pure $ SlotInEra (relPerasRoundNo * perasRoundLength)
+  go (ERelSlotToPerasRoundNo expr) = runPerasEnabledT $ do
+    SlotInEra relSlot <- lift $ go expr
+    PerasRoundLength perasRoundLength <- PerasEnabledT . Just $ eraPerasRoundLength
+    pure . bimap PerasRoundNoInEra SlotInPerasRound $ relSlot `divMod` perasRoundLength
 
   -- Get era parameters
   --
@@ -342,6 +387,14 @@ evalExprInEra EraSummary{..} = \(ClosedExpr e) -> go e
     guard $ s >= boundSlot eraStart
     guardEnd $ \end -> s < boundSlot end
     return eraGenesisWin
+  go (EPerasRoundLength expr) = runPerasEnabledT $ do
+    eraStartPerasRound <- PerasEnabledT . Just $ boundPerasRound eraStart
+    absPerasRound <- lift $ go expr
+    lift . guard $ absPerasRound >= eraStartPerasRound
+    guardEndPeras $ \end -> do
+      eraEndPerasRound <- PerasEnabledT . Just $ boundPerasRound end
+      pure $ absPerasRound < eraEndPerasRound
+    PerasEnabledT . Just $ eraPerasRoundLength
 
 {-------------------------------------------------------------------------------
   PastHorizonException
@@ -499,7 +552,7 @@ slotToEpoch' absSlot =
 -- | Translate 'SlotNo' to its corresponding 'EpochNo'
 --
 -- Additionally returns the relative slot within this epoch and how many
--- slots are left in this slot.
+-- slots are left in this epoch.
 slotToEpoch :: SlotNo -> Qry (EpochNo, Word64, Word64)
 slotToEpoch absSlot =
   aux <$> qryFromExpr (slotToEpochExpr absSlot)
@@ -528,6 +581,38 @@ epochToSize :: EpochNo -> Qry EpochSize
 epochToSize absEpoch =
   qryFromExpr (epochToSizeExpr absEpoch)
 
+-- | Translate 'PerasRoundNo' to the 'SlotNo' of the first slot in that Peras round
+--
+-- Additionally returns the length of the round.
+perasRoundNoToSlot :: PerasRoundNo -> Qry (PerasEnabled (SlotNo, PerasRoundLength))
+perasRoundNoToSlot perasRoundNo = runPerasEnabledT $ do
+  relSlot <-
+    PerasEnabledT $ qryFromExpr (ERelPerasRoundNoToSlot (EAbsToRelPerasRoundNo (ELit perasRoundNo)))
+  absSlot <- lift $ qryFromExpr (ERelToAbsSlot (EPair (ELit relSlot) (ELit (TimeInSlot 0))))
+  roundLength <- PerasEnabledT $ qryFromExpr (perasRoundNoPerasRoundLengthExpr perasRoundNo)
+  pure (absSlot, roundLength)
+
+-- | Translate 'SlotNo' to its corresponding 'PerasRoundNo'
+--
+-- Additionally returns the relative slot within this round and how many
+-- slots are left in this round.
+slotToPerasRoundNo :: SlotNo -> Qry (PerasEnabled (PerasRoundNo, Word64, Word64))
+slotToPerasRoundNo absSlot = runPerasEnabledT $ do
+  (relPerasRoundNo, slotInPerasRound) <-
+    PerasEnabledT $
+      qryFromExpr (ERelSlotToPerasRoundNo (EAbsToRelSlot (ELit absSlot)))
+  absPerasRoundNo <-
+    PerasEnabledT $
+      qryFromExpr (ERelToAbsPerasRoundNo (ELit (PerasEnabled relPerasRoundNo)))
+  roundLength <-
+    PerasEnabledT $
+      qryFromExpr (perasRoundNoPerasRoundLengthExpr absPerasRoundNo)
+  pure $
+    ( absPerasRoundNo
+    , getSlotInPerasRound slotInPerasRound
+    , unPerasRoundLength roundLength - getSlotInPerasRound slotInPerasRound
+    )
+
 {-------------------------------------------------------------------------------
   Supporting expressions for the queries above
 -------------------------------------------------------------------------------}
@@ -581,6 +666,10 @@ slotToGenesisWindow :: SlotNo -> Expr f GenesisWindow
 slotToGenesisWindow absSlot =
   EGenesisWindow (ELit absSlot)
 
+perasRoundNoPerasRoundLengthExpr :: PerasRoundNo -> Expr f (PerasEnabled PerasRoundLength)
+perasRoundNoPerasRoundLengthExpr absPerasRoundNo =
+  EPerasRoundLength (ELit absPerasRoundNo)
+
 {-------------------------------------------------------------------------------
   'Show' instances
 -------------------------------------------------------------------------------}
@@ -629,13 +718,18 @@ instance Show (ClosedExpr a) where
         EAbsToRelTime e -> showString "EAbsToRelTime " . go n 11 e
         EAbsToRelSlot e -> showString "EAbsToRelSlot " . go n 11 e
         EAbsToRelEpoch e -> showString "EAbsToRelEpoch " . go n 11 e
+        EAbsToRelPerasRoundNo e -> showString "EAbsToRelPerasRoundNo " . go n 11 e
         ERelToAbsTime e -> showString "ERelToAbsTime " . go n 11 e
         ERelToAbsSlot e -> showString "ERelToAbsSlot " . go n 11 e
         ERelToAbsEpoch e -> showString "ERelToAbsEpoch " . go n 11 e
+        ERelToAbsPerasRoundNo e -> showString "ERelToAbsPerasRoundNo " . go n 11 e
         ERelTimeToSlot e -> showString "ERelTimeToSlot " . go n 11 e
         ERelSlotToTime e -> showString "ERelSlotToTime " . go n 11 e
         ERelSlotToEpoch e -> showString "ERelSlotToEpoch " . go n 11 e
         ERelEpochToSlot e -> showString "ERelEpochToSlot " . go n 11 e
+        ERelPerasRoundNoToSlot e -> showString "ERelPerasRoundNoToSlot " . go n 11 e
+        ERelSlotToPerasRoundNo e -> showString "ERelSlotToPerasRoundNo " . go n 11 e
         ESlotLength e -> showString "ESlotLength " . go n 11 e
         EEpochSize e -> showString "EEpochSize " . go n 11 e
         EGenesisWindow e -> showString "EGenesisWindow " . go n 11 e
+        EPerasRoundLength e -> showString "EPerasRoundLength " . go n 11 e
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Summary.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Summary.hs
index 0ef241f4a..03b71562e 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Summary.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Summary.hs
@@ -47,7 +47,7 @@ module Ouroboros.Consensus.HardFork.History.Summary
   , summaryInit
   ) where
 
-import Cardano.Binary (enforceSize)
+import Cardano.Binary (DecoderError (DecoderErrorCustom), cborError, decodeListLen, enforceSize)
 import Codec.CBOR.Decoding
   ( TokenType (TypeNull)
   , decodeNull
@@ -83,6 +83,8 @@ data Bound = Bound
   { boundTime :: !RelativeTime
   , boundSlot :: !SlotNo
   , boundEpoch :: !EpochNo
+  , boundPerasRound :: !(PerasEnabled PerasRoundNo)
+  -- ^ Optional, as not every era will be Peras-enabled
   }
   deriving stock (Show, Eq, Generic)
   deriving anyclass NoThunks
@@ -93,6 +95,9 @@ initBound =
     { boundTime = RelativeTime 0
     , boundSlot = SlotNo 0
     , boundEpoch = EpochNo 0
+    , -- TODO(geo2a): we may want to make this configurable,
+      -- see https://github.com/tweag/cardano-peras/issues/112
+      boundPerasRound = NoPerasEnabled
     }
 
 -- | Version of 'mkUpperBound' when the upper bound may not be known
@@ -122,12 +127,16 @@ mkUpperBound EraParams{..} lo hiEpoch =
     { boundTime = addRelTime inEraTime $ boundTime lo
     , boundSlot = addSlots inEraSlots $ boundSlot lo
     , boundEpoch = hiEpoch
+    , boundPerasRound = addPerasRounds <$> inEraPerasRounds <*> boundPerasRound lo
     }
  where
   inEraEpochs, inEraSlots :: Word64
   inEraEpochs = countEpochs hiEpoch (boundEpoch lo)
   inEraSlots = inEraEpochs * unEpochSize eraEpochSize
 
+  inEraPerasRounds :: PerasEnabled Word64
+  inEraPerasRounds = div <$> PerasEnabled inEraSlots <*> (unPerasRoundLength <$> eraPerasRoundLength)
+
   inEraTime :: NominalDiffTime
   inEraTime = fromIntegral inEraSlots * getSlotLength eraSlotLength
 
@@ -182,6 +191,10 @@ slotToEpochBound EraParams{eraEpochSize = EpochSize epochSize} lo hiSlot =
 -- >       t' - t             ==     ((s' - s) * slotLen)
 -- >      (t' - t) / slotLen  ==       s' - s
 -- > s + ((t' - t) / slotLen) ==       s'
+--
+-- Ouroboros Peras adds an invariant relating epoch size and Peras voting round lengths:
+-- > epochSize % perasRoundLength == 0
+-- i.e. the round length should divide the epoch size
 data EraSummary = EraSummary
   { eraStart :: !Bound
   -- ^ Inclusive lower bound
@@ -219,8 +232,9 @@ newtype Summary xs = Summary {getSummary :: NonEmpty xs EraSummary}
 -------------------------------------------------------------------------------}
 
 -- | 'Summary' for a ledger that never forks
-neverForksSummary :: EpochSize -> SlotLength -> GenesisWindow -> Summary '[x]
-neverForksSummary epochSize slotLen genesisWindow =
+neverForksSummary ::
+  EpochSize -> SlotLength -> GenesisWindow -> PerasEnabled PerasRoundLength -> Summary '[x]
+neverForksSummary epochSize slotLen genesisWindow perasRoundLength =
   Summary $
     NonEmptyOne $
       EraSummary
@@ -232,6 +246,7 @@ neverForksSummary epochSize slotLen genesisWindow =
               , eraSlotLength = slotLen
               , eraSafeZone = UnsafeIndefiniteSafeZone
               , eraGenesisWin = genesisWindow
+              , eraPerasRoundLength = perasRoundLength
               }
         }
 
@@ -331,8 +346,19 @@ summarize ::
   Transitions xs ->
   Summary xs
 summarize ledgerTip = \(Shape shape) (Transitions transitions) ->
-  Summary $ go initBound shape transitions
+  Summary $ go initBoundWithPeras shape transitions
  where
+  -- as noted in the haddock, this function is only used for testing purposes,
+  -- therefore we make the initial era is Peras-enabled, which means
+  -- we only test Peras-enabled eras. It is rather difficult
+  -- to parameterise the test suite, as it requires also parameterise many non-test functions, like
+  -- 'HF.initBound'.
+  --
+  -- TODO(geo2a): revisit this hard-coding of enabling Peras when
+  -- we're further into the integration process
+  -- see https://github.com/tweag/cardano-peras/issues/112
+  initBoundWithPeras = initBound{boundPerasRound = PerasEnabled . PerasRoundNo $ 0}
+
   go ::
     Bound -> -- Lower bound for current era
     Exactly (x ': xs) EraParams -> -- params for all eras
@@ -471,6 +497,21 @@ invariantSummary = \(Summary summary) ->
               , " (INV-2b)"
               ]
 
+        case eraPerasRoundLength curParams of
+          NoPerasEnabled -> pure ()
+          PerasEnabled perasRoundLength ->
+            unless
+              ( (unEpochSize $ eraEpochSize curParams)
+                  `mod` (unPerasRoundLength perasRoundLength)
+                  == 0
+              )
+              $ throwError
+              $ mconcat
+                [ "Invalid Peras round length "
+                , show curSummary
+                , " (Peras round length does not divide epoch size)"
+                ]
+
         go curEnd next
    where
     curStart :: Bound
@@ -484,18 +525,27 @@ invariantSummary = \(Summary summary) ->
 
 instance Serialise Bound where
   encode Bound{..} =
-    mconcat
-      [ encodeListLen 3
+    mconcat $
+      [ encodeListLen $ case boundPerasRound of
+          NoPerasEnabled -> 3
+          PerasEnabled{} -> 4
       , encode boundTime
       , encode boundSlot
       , encode boundEpoch
       ]
+        <> case boundPerasRound of
+          NoPerasEnabled -> []
+          PerasEnabled bound -> [encode bound]
 
   decode = do
-    enforceSize "Bound" 3
+    len <- decodeListLen
     boundTime <- decode
     boundSlot <- decode
     boundEpoch <- decode
+    boundPerasRound <- case len of
+      3 -> pure NoPerasEnabled
+      4 -> PerasEnabled <$> decode
+      _ -> cborError (DecoderErrorCustom "Bound" "unexpected list length")
     return Bound{..}
 
 instance Serialise EraEnd where
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Util.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Util.hs
index daf8fd443..7cdebd4ea 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Util.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/HardFork/History/Util.hs
@@ -2,8 +2,10 @@ module Ouroboros.Consensus.HardFork.History.Util
   ( -- * Adding and subtracting slots/epochs
     addEpochs
   , addSlots
+  , addPerasRounds
   , countEpochs
   , countSlots
+  , countPerasRounds
   , subSlots
   ) where
 
@@ -26,6 +28,9 @@ subSlots n (SlotNo x) = assert (x >= n) $ SlotNo (x - n)
 addEpochs :: Word64 -> EpochNo -> EpochNo
 addEpochs n (EpochNo x) = EpochNo (x + n)
 
+addPerasRounds :: Word64 -> PerasRoundNo -> PerasRoundNo
+addPerasRounds n (PerasRoundNo x) = PerasRoundNo (x + n)
+
 -- | @countSlots to fr@ counts the slots from @fr@ to @to@ (@to >= fr@)
 countSlots :: HasCallStack => SlotNo -> SlotNo -> Word64
 countSlots (SlotNo to) (SlotNo fr) = assert (to >= fr) $ to - fr
@@ -37,3 +42,8 @@ countEpochs :: HasCallStack => EpochNo -> EpochNo -> Word64
 countEpochs (EpochNo to) (EpochNo fr) = assert (to >= fr) $ to - fr
  where
   _ = keepRedundantConstraint (Proxy :: Proxy HasCallStack)
+
+countPerasRounds :: HasCallStack => PerasRoundNo -> PerasRoundNo -> Word64
+countPerasRounds (PerasRoundNo to) (PerasRoundNo fr) = assert (to >= fr) $ to - fr
+ where
+  _ = keepRedundantConstraint (Proxy :: Proxy HasCallStack)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Mempool/Update.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Mempool/Update.hs
index 395375086..37f599f25 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Mempool/Update.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Mempool/Update.hs
@@ -405,31 +405,44 @@ implSyncWithLedger mpEnv =
       -- For that reason, we read the state again here in the same STM
       -- transaction in which we acquire the internal state of the mempool.
       --
-      -- This implies that the watcher might be triggered again with the same
-      -- state from the point of view of the mempool, if after the watcher saw a
-      -- new state and this read for re-syncing, the state has changed. The
-      -- watcher will see it once again and trigger re-validation again. Just
-      -- for performance reasons, we will avoid re-validating the mempool if the
-      -- state didn't change.
+      -- The following interleaving could happen:
+      --
+      -- - [ChainSel thread] We adopt a new block B at the tip of our selection.
+      --
+      -- - [Mempool sync thread] The Watcher wakes up, seeing that the tip has
+      --   changed to B, records it as the fingerprint, and invokes
+      --   implSyncWithLedger, but doesn't reach withTMVarAnd here.
+      --
+      -- - [ChainSel thread] Adopt a new block C.
+      --
+      -- - [Mempool thread] Execute withTMVarAnd here, obtaining the ledger
+      --   state for C and syncing the mempool with C.
+      --
+      -- - [Mempool thread] The Watcher wakes up again, seeing that the tip has
+      --   changed from B to C, and invokes implSyncWithLedger. This time,
+      --   nothing needs to be done, resulting in TraceMempoolSyncNotNeeded.
+      --
+      -- Just for performance reasons, we will avoid re-validating the mempool
+      -- if the state didn't change.
       withTMVarAnd istate (const $ getCurrentLedgerState ldgrInterface registry) $
         \is (MempoolLedgerDBView ls meFrk) -> do
-          eFrk <- meFrk
-          case eFrk of
-            -- This case should happen only if the tip has moved again, this time
-            -- to a separate fork, since the background thread saw a change in the
-            -- tip, which should happen very rarely
-            Left{} -> do
-              traceWith trcr TraceMempoolTipMovedBetweenSTMBlocks
-              pure (Nothing, is)
-            Right frk -> do
-              let (slot, ls') = tickLedgerState cfg $ ForgeInUnknownSlot ls
-              if pointHash (isTip is) == castHash (getTipHash ls) && isSlotNo is == slot
-                then do
-                  -- The tip didn't change, put the same state.
-                  traceWith trcr $ TraceMempoolSyncNotNeeded (isTip is)
-                  pure (Just (snapshotFromIS is), is)
-                else do
-                  -- The tip changed, we have to revalidate
+          let (slot, ls') = tickLedgerState cfg $ ForgeInUnknownSlot ls
+          if pointHash (isTip is) == castHash (getTipHash ls) && isSlotNo is == slot
+            then do
+              -- The tip didn't change, put the same state.
+              traceWith trcr $ TraceMempoolSyncNotNeeded (isTip is)
+              pure (Just (snapshotFromIS is), is)
+            else do
+              -- The tip changed, we have to revalidate
+              eFrk <- meFrk
+              case eFrk of
+                -- This case should happen only if the tip has moved again, this time
+                -- to a separate fork, since the background thread saw a change in the
+                -- tip, which should happen very rarely
+                Left{} -> do
+                  traceWith trcr TraceMempoolTipMovedBetweenSTMBlocks
+                  pure (Nothing, is)
+                Right frk -> do
                   modifyMVar_
                     forkerMVar
                     ( \oldFrk -> do
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/BlockFetch/ClientInterface.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/BlockFetch/ClientInterface.hs
index bdf45723e..a630e3d10 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/BlockFetch/ClientInterface.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/BlockFetch/ClientInterface.hs
@@ -33,6 +33,7 @@ import Ouroboros.Consensus.Ledger.SupportsProtocol
   )
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client as CSClient
 import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client.Jumping as CSJumping
+import Ouroboros.Consensus.Peras.Weight (PerasWeightSnapshot)
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( AddBlockPromise
   , ChainDB
@@ -45,14 +46,15 @@ import qualified Ouroboros.Consensus.Storage.ChainDB.API.Types.InvalidBlockPunis
 import Ouroboros.Consensus.Util.AnchoredFragment
 import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.Orphans ()
+import Ouroboros.Consensus.Util.STM
 import Ouroboros.Network.AnchoredFragment (AnchoredFragment)
 import qualified Ouroboros.Network.AnchoredFragment as AF
 import Ouroboros.Network.Block (MaxSlotNo)
 import Ouroboros.Network.BlockFetch.ConsensusInterface
   ( BlockFetchConsensusInterface (..)
+  , ChainComparison (..)
   , ChainSelStarvation
   , FetchMode (..)
-  , FromConsensus (..)
   , PraosFetchMode (..)
   , mkReadFetchMode
   )
@@ -66,6 +68,7 @@ data ChainDbView m blk = ChainDbView
   , getMaxSlotNo :: STM m MaxSlotNo
   , addBlockAsync :: InvalidBlockPunishment m -> blk -> m (AddBlockPromise m blk)
   , getChainSelStarvation :: STM m ChainSelStarvation
+  , getPerasWeightSnapshot :: STM m (WithFingerprint (PerasWeightSnapshot blk))
   }
 
 defaultChainDbView :: ChainDB m blk -> ChainDbView m blk
@@ -77,6 +80,7 @@ defaultChainDbView chainDB =
     , getMaxSlotNo = ChainDB.getMaxSlotNo chainDB
     , addBlockAsync = ChainDB.addBlockAsync chainDB
     , getChainSelStarvation = ChainDB.getChainSelStarvation chainDB
+    , getPerasWeightSnapshot = ChainDB.getPerasWeightSnapshot chainDB
     }
 
 readFetchModeDefault ::
@@ -226,6 +230,16 @@ mkBlockFetchConsensusInterface
     readFetchedMaxSlotNo :: STM m MaxSlotNo
     readFetchedMaxSlotNo = getMaxSlotNo chainDB
 
+    readChainComparison :: STM m (WithFingerprint (ChainComparison (HeaderWithTime blk)))
+    readChainComparison =
+      fmap mkChainComparison <$> getPerasWeightSnapshot chainDB
+     where
+      mkChainComparison weights =
+        ChainComparison
+          { plausibleCandidateChain = plausibleCandidateChain weights
+          , compareCandidateChains = compareCandidateChains weights
+          }
+
     -- Note that @ours@ comes from the ChainDB and @cand@ from the ChainSync
     -- client.
     --
@@ -241,10 +255,11 @@ mkBlockFetchConsensusInterface
     -- fragment, our current chain might have changed.
     plausibleCandidateChain ::
       HasCallStack =>
+      PerasWeightSnapshot blk ->
       AnchoredFragment (HeaderWithTime blk) ->
       AnchoredFragment (HeaderWithTime blk) ->
       Bool
-    plausibleCandidateChain ours cand
+    plausibleCandidateChain weights ours cand =
       -- 1. The ChainDB maintains the invariant that the anchor of our fragment
       --    corresponds to the immutable tip.
       --
@@ -258,52 +273,27 @@ mkBlockFetchConsensusInterface
       --    point. This means that we are no longer guaranteed that the
       --    precondition holds.
       --
-      -- 4. Our chain's anchor can only move forward. We can detect this by
-      --    looking at the block/slot numbers of the anchors: When the anchor
-      --    advances, either the block number increases (usual case), or the
-      --    block number stays the same, but the slot number increases (EBB
-      --    case).
-      --
-      | anchorBlockNoAndSlot cand < anchorBlockNoAndSlot ours -- (4)
-        =
-          case (AF.null ours, AF.null cand) of
-            -- Both are non-empty, the precondition trivially holds.
-            (False, False) -> preferAnchoredCandidate bcfg ours cand
-            -- The candidate is shorter than our chain and, worse, we'd have to
-            -- roll back past our immutable tip (the anchor of @cand@).
-            (_, True) -> False
-            -- As argued above we can only reach this case when our chain's anchor
-            -- has changed (4).
-            --
-            -- It is impossible for our chain to change /and/ still be empty: the
-            -- anchor of our chain only changes when a new block becomes
-            -- immutable. For a new block to become immutable, we must have
-            -- extended our chain with at least @k + 1@ blocks. Which means our
-            -- fragment can't be empty.
-            (True, _) -> error "impossible"
-      | otherwise =
-          preferAnchoredCandidate bcfg ours cand
-     where
-      anchorBlockNoAndSlot ::
-        AnchoredFragment (HeaderWithTime blk) ->
-        (WithOrigin BlockNo, WithOrigin SlotNo)
-      anchorBlockNoAndSlot frag =
-        (AF.anchorToBlockNo a, AF.anchorToSlotNo a)
-       where
-        a = AF.anchor frag
+      -- 4. Therefore, we check whether the candidate fragments still intersects
+      --    with our fragment; if not, then it is only a matter of time until the
+      --    ChainSync client disconnects from that peer.
+      case AF.intersectionPoint ours cand of
+        -- REVIEW: Hmm, maybe we want to change 'preferAnchoredCandidates' to
+        -- also just return 'False' in this case (and we remove the
+        -- precondition).
+        Nothing -> False
+        Just _ -> preferAnchoredCandidate bcfg weights ours cand
 
     compareCandidateChains ::
+      PerasWeightSnapshot blk ->
       AnchoredFragment (HeaderWithTime blk) ->
       AnchoredFragment (HeaderWithTime blk) ->
       Ordering
     compareCandidateChains = compareAnchoredFragments bcfg
 
-    headerForgeUTCTime :: FromConsensus (HeaderWithTime blk) -> STM m UTCTime
+    headerForgeUTCTime :: HeaderWithTime blk -> UTCTime
     headerForgeUTCTime =
-      pure
-        . fromRelativeTime (SupportsNode.getSystemStart bcfg)
+      fromRelativeTime (SupportsNode.getSystemStart bcfg)
         . hwtSlotRelativeTime
-        . unFromConsensus
 
     readChainSelStarvation = getChainSelStarvation chainDB
 
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ChainSync/Client.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ChainSync/Client.hs
index ec16c91ec..fcb0e2538 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ChainSync/Client.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ChainSync/Client.hs
@@ -124,6 +124,7 @@ import qualified Ouroboros.Consensus.MiniProtocol.ChainSync.Client.Jumping as Ju
 import Ouroboros.Consensus.MiniProtocol.ChainSync.Client.State
 import Ouroboros.Consensus.Node.GsmState (GsmState (..))
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
+import Ouroboros.Consensus.Peras.Weight (emptyPerasWeightSnapshot)
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Storage.ChainDB (ChainDB)
 import qualified Ouroboros.Consensus.Storage.ChainDB as ChainDB
@@ -1833,7 +1834,12 @@ checkTime cfgEnv dynEnv intEnv =
   checkPreferTheirsOverOurs kis
     | -- Precondition is fulfilled as ourFrag and theirFrag intersect by
       -- construction.
-      preferAnchoredCandidate (configBlock cfg) ourFrag theirFrag =
+      preferAnchoredCandidate
+        (configBlock cfg)
+        -- TODO: remove this entire check, see https://github.com/tweag/cardano-peras/issues/64
+        emptyPerasWeightSnapshot
+        ourFrag
+        theirFrag =
         pure ()
     | otherwise =
         throwSTM $
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Inbound.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Inbound.hs
new file mode 100644
index 000000000..f72299d0f
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Inbound.hs
@@ -0,0 +1,454 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE DeriveAnyClass #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingStrategies #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE ImportQualifiedPost #-}
+{-# LANGUAGE KindSignatures #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE RecordWildCards #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+module Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Inbound
+  ( objectDiffusionInbound
+  , TraceObjectDiffusionInbound (..)
+  , ObjectDiffusionInboundError (..)
+  , NumObjectsProcessed (..)
+  ) where
+
+import Cardano.Prelude (catMaybes, (&))
+import Control.Concurrent.Class.MonadSTM.Strict.TVar.Checked
+import Control.Exception (assert)
+import Control.Monad (when)
+import Control.Monad.Class.MonadSTM
+import Control.Monad.Class.MonadThrow
+import Control.Tracer (Tracer, traceWith)
+import Data.Foldable as Foldable (foldl', toList)
+import Data.List qualified as List
+import Data.List.NonEmpty qualified as NonEmpty
+import Data.Map.Strict (Map)
+import Data.Map.Strict qualified as Map
+import Data.Sequence.Strict (StrictSeq)
+import Data.Sequence.Strict qualified as Seq
+import Data.Set (Set)
+import Data.Set qualified as Set
+import Data.Word (Word64)
+import GHC.Generics (Generic)
+import Network.TypedProtocol.Core (N (Z), Nat (..), natToInt)
+import NoThunks.Class (NoThunks (..))
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+import Ouroboros.Consensus.Util.NormalForm.Invariant (noThunksInvariant)
+import Ouroboros.Network.ControlMessage
+import Ouroboros.Network.NodeToNode.Version (NodeToNodeVersion)
+import Ouroboros.Network.Protocol.ObjectDiffusion.Inbound
+import Ouroboros.Network.Protocol.ObjectDiffusion.Type
+
+-- Note: This module is inspired from TxSubmission inbound side.
+
+newtype NumObjectsProcessed
+  = NumObjectsProcessed
+  { getNumObjectsProcessed :: Word64
+  }
+  deriving (Eq, Show)
+
+data TraceObjectDiffusionInbound objectId object
+  = -- | Number of objects just about to be inserted.
+    TraceObjectDiffusionInboundCollectedObjects Int
+  | -- | Just processed object pass/fail breakdown.
+    TraceObjectDiffusionInboundAddedObjects NumObjectsProcessed
+  | -- | Received a 'ControlMessage' from the outbound peer governor, and about
+    -- to act on it.
+    TraceObjectDiffusionInboundRecvControlMessage ControlMessage
+  | TraceObjectDiffusionInboundCanRequestMoreObjects Int
+  | TraceObjectDiffusionInboundCannotRequestMoreObjects Int
+  deriving (Eq, Show)
+
+data ObjectDiffusionInboundError
+  = ProtocolErrorObjectNotRequested
+  | ProtocolErrorObjectIdsNotRequested
+  | ProtocolErrorObjectIdAlreadyKnown
+  | ProtocolErrorObjectIdsDuplicate
+  deriving Show
+
+instance Exception ObjectDiffusionInboundError where
+  displayException ProtocolErrorObjectNotRequested =
+    "The peer replied with a object we did not ask for."
+  displayException ProtocolErrorObjectIdsNotRequested =
+    "The peer replied with more objectIds than we asked for."
+  displayException ProtocolErrorObjectIdAlreadyKnown =
+    "The peer replied with an objectId that it has already sent us previously."
+  displayException ProtocolErrorObjectIdsDuplicate =
+    "The peer replied with a batch of objectIds containing a duplicate."
+
+-- | Information maintained internally in the 'objectDiffusionInbound'
+-- implementation.
+data InboundSt objectId object = InboundSt
+  { numIdsInFlight :: !NumObjectIdsReq
+  -- ^ The number of object identifiers that we have requested but
+  -- which have not yet been replied to. We need to track this to keep
+  -- our requests within the limit on the 'outstandingFifo' size.
+  , outstandingFifo :: !(StrictSeq objectId)
+  -- ^ This mirrors the queue of objects that the outbound peer has available
+  -- for us. Objects are kept in the order in which the outbound peer
+  -- advertised them to us. This is the same order in which we submit them to
+  -- the objectPool. It is also the order we acknowledge them.
+  , canRequestNext :: !(Set objectId)
+  -- ^ The objectIds that we can request. These are a subset of the
+  -- 'outstandingFifo' that we have not yet requested or not have in the pool
+  -- already. This is not ordered to illustrate the fact that we can
+  -- request objects out of order.
+  , pendingObjects :: !(Map objectId (Maybe object))
+  -- ^ Objects we have successfully downloaded (or decided intentionally to
+  -- skip download) but have not yet added to the objectPool or acknowledged.
+  --
+  -- Object IDs in this 'Map' are mapped to 'Nothing' if we notice that
+  -- they are already in the objectPool. That way we can skip requesting them
+  -- from the outbound peer, but still acknowledge them when the time comes.
+  , numToAckOnNextReq :: !NumObjectIdsAck
+  -- ^ The number of objects we can acknowledge on our next request
+  -- for more object IDs. Their corresponding IDs have already been removed
+  -- from 'outstandingFifo'.
+  }
+  deriving stock (Show, Generic)
+  deriving anyclass NoThunks
+
+initialInboundSt :: InboundSt objectId object
+initialInboundSt = InboundSt 0 Seq.empty Set.empty Map.empty 0
+
+objectDiffusionInbound ::
+  forall objectId object m.
+  ( Ord objectId
+  , NoThunks objectId
+  , NoThunks object
+  , MonadSTM m
+  , MonadThrow m
+  ) =>
+  Tracer m (TraceObjectDiffusionInbound objectId object) ->
+  -- | Maximum values for outstanding FIFO length, number of IDs to request,
+  -- and number of objects to request
+  (NumObjectsOutstanding, NumObjectIdsReq, NumObjectsReq) ->
+  ObjectPoolWriter objectId object m ->
+  NodeToNodeVersion ->
+  ControlMessageSTM m ->
+  ObjectDiffusionInboundPipelined objectId object m ()
+objectDiffusionInbound
+  tracer
+  (maxFifoLength, maxNumIdsToReq, maxNumObjectsToReq)
+  ObjectPoolWriter{..}
+  _version
+  controlMessageSTM =
+    ObjectDiffusionInboundPipelined $!
+      checkState initialInboundSt & go Zero
+   where
+    canRequestMoreObjects :: InboundSt k object -> Bool
+    canRequestMoreObjects !st =
+      not (Set.null (canRequestNext st))
+
+    -- Computes how many new IDs we can request so that receiving all of them
+    -- won't make 'outstandingFifo' exceed 'maxFifoLength'.
+    numIdsToReq :: InboundSt objectId object -> NumObjectIdsReq
+    numIdsToReq !st =
+      maxNumIdsToReq
+        `min` ( fromIntegral maxFifoLength
+                  - (fromIntegral $ Seq.length $ outstandingFifo st)
+                  - numIdsInFlight st
+              )
+
+    -- Updates 'InboundSt' with new object IDs and return the updated 'InboundSt'.
+    --
+    -- Collected object IDs that are already in the objectPool are pre-emptively
+    -- acknowledged so that we don't need to bother requesting them from the
+    -- outbound peer.
+    preAcknowledge ::
+      InboundSt objectId object ->
+      (objectId -> Bool) ->
+      [objectId] ->
+      InboundSt objectId object
+    preAcknowledge !st _ collectedIds | null collectedIds = st
+    preAcknowledge !st poolHasObject collectedIds =
+      let
+        -- Divide the collected IDs in two parts: those that are already in the
+        -- objectPool and those that are not.
+        (alreadyObtained, notYetObtained) =
+          List.partition
+            poolHasObject
+            collectedIds
+
+        -- The objects that we intentionally don't request, because they are
+        -- already in the objectPool, will need to be acknowledged.
+        -- So we extend 'pendingObjects' with those objects (so of course they
+        -- have no corresponding reply).
+        pendingObjects' =
+          foldl'
+            (\accMap objectId -> Map.insert objectId Nothing accMap)
+            (pendingObjects st)
+            alreadyObtained
+
+        -- We initially extend 'outstandingFifo' with the all the collected IDs
+        -- (to properly mirror the server state).
+        outstandingFifo' = outstandingFifo st <> Seq.fromList collectedIds
+
+        -- Now check if the update of 'pendingObjects' let us acknowledge a prefix
+        -- of the 'outstandingFifo', as we do in 'goCollect' -> 'CollectObjects'.
+        (objectIdsToAck, outstandingFifo'') =
+          Seq.spanl (`Map.member` pendingObjects') outstandingFifo'
+
+        -- If so we can remove them from the 'pendingObjects' structure.
+        --
+        -- Note that unlike in TX-Submission, we made sure the outstanding FIFO
+        -- couldn't have duplicate IDs, so we don't have to worry about re-adding
+        -- the duplicate IDs to 'pendingObjects' for future acknowledgment.
+        pendingObjects'' =
+          Foldable.foldl'
+            (flip Map.delete)
+            pendingObjects'
+            objectIdsToAck
+
+        !st' =
+          st
+            { canRequestNext = canRequestNext st <> (Set.fromList notYetObtained)
+            , pendingObjects = pendingObjects''
+            , outstandingFifo = outstandingFifo''
+            , numToAckOnNextReq =
+                numToAckOnNextReq st
+                  + fromIntegral (Seq.length objectIdsToAck)
+            }
+       in
+        st'
+
+    go ::
+      forall (n :: N).
+      Nat n ->
+      InboundSt objectId object ->
+      InboundStIdle n objectId object m ()
+    go n !st = WithEffect $ do
+      -- Check whether we should continue engaging in the protocol.
+      ctrlMsg <- atomically controlMessageSTM
+      traceWith tracer $
+        TraceObjectDiffusionInboundRecvControlMessage ctrlMsg
+      case ctrlMsg of
+        -- The peer selection governor is asking us to terminate the connection.
+        Terminate ->
+          pure $! terminateAfterDrain n
+        -- Otherwise, we can continue the protocol normally.
+        _continue -> case n of
+          -- We didn't pipeline any requests, so there are no replies in flight
+          -- (nothing to collect)
+          Zero -> do
+            if canRequestMoreObjects st
+              then do
+                -- There are no replies in flight, but we do know some more objects
+                -- we can ask for, so lets ask for them and more objectIds in a
+                -- pipelined way.
+                traceWith tracer $
+                  TraceObjectDiffusionInboundCanRequestMoreObjects (natToInt n)
+                pure $! checkState st & goReqObjectsAndObjectIdsPipelined Zero
+              else do
+                -- There's no replies in flight, and we have no more objects we can
+                -- ask for so the only remaining thing to do is to ask for more
+                -- objectIds. Since this is the only thing to do now, we make this a
+                -- blocking call.
+                traceWith tracer $
+                  TraceObjectDiffusionInboundCannotRequestMoreObjects (natToInt n)
+                pure $! checkState st & goReqObjectIdsBlocking
+
+          -- We have pipelined some requests, so there are some replies in flight.
+          Succ n' ->
+            if canRequestMoreObjects st
+              then do
+                -- We have replies in flight and we should eagerly collect them if
+                -- available, but there are objects to request too so we
+                -- should *not* block waiting for replies.
+                -- So we ask for new objects and objectIds in a pipelined way.
+                traceWith tracer $
+                  TraceObjectDiffusionInboundCanRequestMoreObjects (natToInt n)
+                pure $!
+                  CollectPipelined
+                    (Just (checkState st & goReqObjectsAndObjectIdsPipelined (Succ n')))
+                    (\collected -> checkState st & goCollect n' collected)
+              else do
+                traceWith tracer $
+                  TraceObjectDiffusionInboundCannotRequestMoreObjects (natToInt n)
+                -- In this case we can theoretically only collect replies or request
+                -- new object IDs.
+                --
+                -- But it's important not to pipeline more requests for objectIds now
+                -- because if we did, then immediately after sending the request (but
+                -- having not yet received a response to either this or the other
+                -- pipelined requests), we would directly re-enter this code path,
+                -- resulting us in filling the pipeline with an unbounded number of
+                -- requests.
+                --
+                -- So we instead block until we collect a reply.
+                pure $!
+                  CollectPipelined
+                    Nothing
+                    (\collected -> checkState st & goCollect n' collected)
+
+    goCollect ::
+      forall (n :: N).
+      Nat n ->
+      Collect objectId object ->
+      InboundSt objectId object ->
+      InboundStIdle n objectId object m ()
+    goCollect n collect !st = case collect of
+      CollectObjectIds numIdsRequested collectedIds -> WithEffect $ do
+        let numCollectedIds = length collectedIds
+            collectedIdsSet = Set.fromList collectedIds
+
+        -- Check they didn't send more than we asked for. We don't need to
+        -- check for a minimum: the blocking case checks for non-zero
+        -- elsewhere, and for the non-blocking case it is quite normal for
+        -- them to send us none.
+        when (numCollectedIds > fromIntegral numIdsRequested) $
+          throwIO ProtocolErrorObjectIdsNotRequested
+
+        -- Check that the server didn't send IDs that were already in the
+        -- outstanding FIFO
+        when (any (`Set.member` collectedIdsSet) (outstandingFifo st)) $
+          throwIO ProtocolErrorObjectIdAlreadyKnown
+
+        -- Check that the server didn't send duplicate IDs in its response
+        when (Set.size collectedIdsSet /= numCollectedIds) $
+          throwIO ProtocolErrorObjectIdsDuplicate
+
+        -- We extend our outstanding FIFO with the newly received objectIds by
+        -- calling 'preAcknowledge' which will also pre-emptively acknowledge the
+        -- objectIds that we already have in the pool and thus don't need to
+        -- request.
+        let !st' = st{numIdsInFlight = numIdsInFlight st - numIdsRequested}
+        poolHasObject <- atomically $ opwHasObject
+        let !st'' = preAcknowledge st' poolHasObject collectedIds
+        pure $! checkState st'' & go n
+      CollectObjects requestedIds collectedObjects -> WithEffect $ do
+        let requestedIdsSet = Set.fromList requestedIds
+            obtainedIdsSet = Set.fromList (opwObjectId <$> collectedObjects)
+
+        -- To start with we have to verify that the objects they have sent us are
+        -- exactly the objects we asked for, not more, not less.
+        when (requestedIdsSet /= obtainedIdsSet) $
+          throwIO ProtocolErrorObjectNotRequested
+
+        traceWith tracer $
+          TraceObjectDiffusionInboundCollectedObjects (length collectedObjects)
+
+        -- We update 'pendingObjects' with the newly obtained objects
+        let pendingObjects' =
+              foldl'
+                (\accMap object -> Map.insert (opwObjectId object) (Just object) accMap)
+                (pendingObjects st)
+                collectedObjects
+
+            -- We then find the longest prefix of 'outstandingFifo' for which we have
+            -- all the corresponding IDs in 'pendingObjects'.
+            -- We remove this prefix from 'outstandingFifo'.
+            (objectIdsToAck, outstandingFifo') =
+              Seq.spanl (`Map.member` pendingObjects') (outstandingFifo st)
+
+            -- And also remove these entries from 'pendingObjects'.
+            --
+            -- Note that unlike in TX-Submission, we made sure the outstanding FIFO
+            -- couldn't have duplicate IDs, so we don't have to worry about re-adding
+            -- the duplicate IDs to 'pendingObjects' for future acknowledgment.
+            pendingObjects'' =
+              Foldable.foldl'
+                (flip Map.delete)
+                pendingObjects'
+                objectIdsToAck
+
+            -- These are the objects we need to submit to the object pool
+            objectsToAck =
+              catMaybes $
+                (((Map.!) pendingObjects') <$> toList objectIdsToAck)
+
+        opwAddObjects objectsToAck
+        traceWith tracer $
+          TraceObjectDiffusionInboundAddedObjects
+            (NumObjectsProcessed (fromIntegral $ length objectsToAck))
+
+        let !st' =
+              st
+                { pendingObjects = pendingObjects''
+                , outstandingFifo = outstandingFifo'
+                , numToAckOnNextReq =
+                    numToAckOnNextReq st
+                      + fromIntegral (Seq.length objectIdsToAck)
+                }
+        pure $! checkState st' & go n
+
+    goReqObjectIdsBlocking ::
+      InboundSt objectId object ->
+      InboundStIdle 'Z objectId object m ()
+    goReqObjectIdsBlocking !st =
+      let numIdsToRequest = numIdsToReq st
+          -- We should only request new object IDs in a blocking way if we have
+          -- absolutely nothing else we can do.
+          !st' =
+            st
+              { numToAckOnNextReq = 0
+              , numIdsInFlight = numIdsToRequest
+              }
+       in assert
+            ( numIdsInFlight st == 0
+                && Seq.null (outstandingFifo st)
+                && Set.null (canRequestNext st)
+                && Map.null (pendingObjects st)
+            )
+            $ SendMsgRequestObjectIdsBlocking
+              (numToAckOnNextReq st)
+              numIdsToRequest
+              ( \neCollectedIds ->
+                  checkState st' & goCollect Zero (CollectObjectIds numIdsToRequest (NonEmpty.toList neCollectedIds))
+              )
+
+    goReqObjectsAndObjectIdsPipelined ::
+      forall (n :: N).
+      Nat n ->
+      InboundSt objectId object ->
+      InboundStIdle n objectId object m ()
+    goReqObjectsAndObjectIdsPipelined n !st =
+      -- TODO: This implementation is deliberately naive, we pick in an
+      -- arbitrary order. We may want to revisit this later.
+      let (toRequest, canRequestNext') =
+            Set.splitAt (fromIntegral maxNumObjectsToReq) (canRequestNext st)
+          !st' = st{canRequestNext = canRequestNext'}
+       in SendMsgRequestObjectsPipelined
+            (toList toRequest)
+            (checkState st' & goReqObjectIdsPipelined (Succ n))
+
+    goReqObjectIdsPipelined ::
+      forall (n :: N).
+      Nat n ->
+      InboundSt objectId object ->
+      InboundStIdle n objectId object m ()
+    goReqObjectIdsPipelined n !st =
+      let numIdsToRequest = numIdsToReq st
+       in if numIdsToRequest <= 0
+            then checkState st & go n
+            else
+              let !st' =
+                    st
+                      { numIdsInFlight =
+                          numIdsInFlight st
+                            + numIdsToRequest
+                      , numToAckOnNextReq = 0
+                      }
+               in SendMsgRequestObjectIdsPipelined
+                    (numToAckOnNextReq st)
+                    numIdsToRequest
+                    (checkState st' & go (Succ n))
+
+    -- Ignore all outstanding replies to messages we pipelined ("drain"), and then
+    -- terminate.
+    terminateAfterDrain ::
+      Nat n -> InboundStIdle n objectId object m ()
+    terminateAfterDrain = \case
+      Zero -> SendMsgDone ()
+      Succ n -> CollectPipelined Nothing $ \_ignoredMsg -> terminateAfterDrain n
+
+-- | Helper to ensure that the `InboundSt` is free of unexpected thunks and
+-- stays strict during the whole process
+checkState :: NoThunks s => s -> s
+checkState !st = checkInvariant (noThunksInvariant st) st
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/API.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/API.hs
new file mode 100644
index 000000000..2f949d8b3
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/API.hs
@@ -0,0 +1,59 @@
+-- | API for reading from and writing to object pools in the ObjectDiffusion
+-- miniprotocol.
+--
+-- The underlying object pool can be any database, such as a 'PerasCertDb' in
+-- Peras certificate diffusion.
+--
+-- 'ObjectPoolReader' is used on the outbound side of the protocol. Objects in
+-- the pool are ordered by a strictly increasing ticket number ('ticketNo'),
+-- which represents their time of arrival. Ticket numbers are local to each
+-- node, unlike object IDs, which are global. Object IDs are not used for
+-- ordering, since objects may arrive slightly out of order from peers.
+--
+-- To read from the pool, one requests objects with a ticket number strictly
+-- greater than the last known one. 'oprZeroTicketNo' provides an initial ticket
+-- number for the first request.
+--
+-- 'ObjectPoolWriter' is used on the inbound side of the protocol. It allows
+-- checking whether an object is already present (to avoid re-requesting it) and
+-- appending new objects. Ticket numbers are not part of the inbound interface,
+-- but are used internally: newly added objects always receive a ticket number
+-- strictly greater than those of older ones.
+--
+-- This API design is inspired by 'MempoolSnapshot' from the TX-submission
+-- miniprotocol, see:
+-- <https://ouroboros-consensus.cardano.intersectmbo.org/haddocks/ouroboros-consensus/Ouroboros-Consensus-Mempool-API.html#t:MempoolSnapshot>
+module Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+  ( ObjectPoolReader (..)
+  , ObjectPoolWriter (..)
+  ) where
+
+import Control.Concurrent.Class.MonadSTM.Strict (STM)
+import Data.Word (Word64)
+
+-- | Interface used by the outbound side of object diffusion as its source of
+-- objects to give to the remote side.
+data ObjectPoolReader objectId object ticketNo m
+  = ObjectPoolReader
+  { oprObjectId :: object -> objectId
+  -- ^ Return the id of the specified object
+  , oprZeroTicketNo :: ticketNo
+  -- ^ Ticket number before the first item in the pool.
+  , oprObjectsAfter :: ticketNo -> Word64 -> STM m [(ticketNo, objectId, m object)]
+  -- ^ Get the list of objects available in the pool with a ticketNo greater
+  -- than the specified one. The number of returned objects is capped by the
+  -- given Word64. Only the IDs and ticketNos of the objects are directly
+  -- accessible; each actual object must be loaded through a monadic action.
+  }
+
+-- | Interface used by the inbound side of object diffusion when receiving
+-- objects.
+data ObjectPoolWriter objectId object m
+  = ObjectPoolWriter
+  { opwObjectId :: object -> objectId
+  -- ^ Return the id of the specified object
+  , opwAddObjects :: [object] -> m ()
+  -- ^ Add a batch of objects to the objectPool.
+  , opwHasObject :: STM m (objectId -> Bool)
+  -- ^ Check if the object pool contains an object with the given id
+  }
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/PerasCert.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/PerasCert.hs
new file mode 100644
index 000000000..1e9e96634
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/ObjectPool/PerasCert.hs
@@ -0,0 +1,108 @@
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE StandaloneDeriving #-}
+
+-- | Instantiate 'ObjectPoolReader' and 'ObjectPoolWriter' using Peras
+-- certificates from the 'PerasCertDB' (or the 'ChainDB' which is wrapping the
+-- 'PerasCertDB').
+module Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.PerasCert
+  ( makePerasCertPoolReaderFromCertDB
+  , makePerasCertPoolWriterFromCertDB
+  , makePerasCertPoolReaderFromChainDB
+  , makePerasCertPoolWriterFromChainDB
+  ) where
+
+import qualified Data.Map as Map
+import GHC.Exception (throw)
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+import Ouroboros.Consensus.Storage.ChainDB.API (ChainDB)
+import qualified Ouroboros.Consensus.Storage.ChainDB.API as ChainDB
+import Ouroboros.Consensus.Storage.PerasCertDB.API
+  ( PerasCertDB
+  , PerasCertSnapshot
+  , PerasCertTicketNo
+  )
+import qualified Ouroboros.Consensus.Storage.PerasCertDB.API as PerasCertDB
+import Ouroboros.Consensus.Util.IOLike
+
+makePerasCertPoolReaderFromSnapshot ::
+  (IOLike m, StandardHash blk) =>
+  STM m (PerasCertSnapshot blk) ->
+  ObjectPoolReader PerasRoundNo (PerasCert blk) PerasCertTicketNo m
+makePerasCertPoolReaderFromSnapshot getCertSnapshot =
+  ObjectPoolReader
+    { oprObjectId = getPerasCertRound
+    , oprZeroTicketNo = PerasCertDB.zeroPerasCertTicketNo
+    , oprObjectsAfter = \lastKnown limit -> do
+        certSnapshot <- getCertSnapshot
+        pure $
+          take (fromIntegral limit) $
+            [ (ticketNo, getPerasCertRound cert, pure (getPerasCert cert))
+            | (ticketNo, cert) <-
+                Map.toAscList $
+                  PerasCertDB.getCertsAfter certSnapshot lastKnown
+            ]
+    }
+
+makePerasCertPoolReaderFromCertDB ::
+  (IOLike m, StandardHash blk) =>
+  PerasCertDB m blk -> ObjectPoolReader PerasRoundNo (PerasCert blk) PerasCertTicketNo m
+makePerasCertPoolReaderFromCertDB perasCertDB =
+  makePerasCertPoolReaderFromSnapshot (PerasCertDB.getCertSnapshot perasCertDB)
+
+makePerasCertPoolWriterFromCertDB ::
+  (StandardHash blk, IOLike m) =>
+  PerasCertDB m blk -> ObjectPoolWriter PerasRoundNo (PerasCert blk) m
+makePerasCertPoolWriterFromCertDB perasCertDB =
+  ObjectPoolWriter
+    { opwObjectId = getPerasCertRound
+    , opwAddObjects = \certs -> do
+        validatePerasCerts certs
+          >>= mapM_ (PerasCertDB.addCert perasCertDB)
+    , opwHasObject = do
+        certSnapshot <- PerasCertDB.getCertSnapshot perasCertDB
+        pure $ PerasCertDB.containsCert certSnapshot
+    }
+
+makePerasCertPoolReaderFromChainDB ::
+  (IOLike m, StandardHash blk) =>
+  ChainDB m blk -> ObjectPoolReader PerasRoundNo (PerasCert blk) PerasCertTicketNo m
+makePerasCertPoolReaderFromChainDB chainDB =
+  makePerasCertPoolReaderFromSnapshot (ChainDB.getPerasCertSnapshot chainDB)
+
+makePerasCertPoolWriterFromChainDB ::
+  (StandardHash blk, IOLike m) =>
+  ChainDB m blk -> ObjectPoolWriter PerasRoundNo (PerasCert blk) m
+makePerasCertPoolWriterFromChainDB chainDB =
+  ObjectPoolWriter
+    { opwObjectId = getPerasCertRound
+    , opwAddObjects = \certs -> do
+        validatePerasCerts certs
+          >>= mapM_ (ChainDB.addPerasCertAsync chainDB)
+    , opwHasObject = do
+        certSnapshot <- ChainDB.getPerasCertSnapshot chainDB
+        pure $ PerasCertDB.containsCert certSnapshot
+    }
+
+data PerasCertInboundException
+  = forall blk. PerasCertValidationError (PerasValidationErr blk)
+
+deriving instance Show PerasCertInboundException
+
+instance Exception PerasCertInboundException
+
+-- | Validate a list of 'PerasCert's, throwing a 'PerasCertInboundException' if
+-- any of them are invalid.
+validatePerasCerts ::
+  (StandardHash blk, MonadThrow m) =>
+  [PerasCert blk] ->
+  m [ValidatedPerasCert blk]
+validatePerasCerts certs = do
+  let perasCfg = makePerasCfg Nothing
+  -- TODO replace the mocked-up Nothing with a real
+  -- 'BlockConfig' when all the plumbing is in place
+  -- see https://github.com/tweag/cardano-peras/issues/73
+  -- see https://github.com/tweag/cardano-peras/issues/120
+  case traverse (validatePerasCert perasCfg) certs of
+    Left validationErr -> throw (PerasCertValidationError validationErr)
+    Right validatedCerts -> return validatedCerts
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Outbound.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Outbound.hs
new file mode 100644
index 000000000..34c90b983
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/Outbound.hs
@@ -0,0 +1,244 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE ImportQualifiedPost #-}
+{-# LANGUAGE RecordWildCards #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+module Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Outbound
+  ( objectDiffusionOutbound
+  , TraceObjectDiffusionOutbound (..)
+  , ObjectDiffusionOutboundError (..)
+  ) where
+
+import Control.Exception (assert)
+import Control.Monad (forM, unless, when)
+import Control.Monad.Class.MonadSTM
+import Control.Monad.Class.MonadThrow
+import Control.Tracer (Tracer, traceWith)
+import Data.List.NonEmpty qualified as NonEmpty
+import Data.Sequence.Strict (StrictSeq)
+import Data.Sequence.Strict qualified as Seq
+import Data.Set qualified as Set
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+import Ouroboros.Network.NodeToNode.Version (NodeToNodeVersion)
+import Ouroboros.Network.Protocol.ObjectDiffusion.Outbound
+import Ouroboros.Network.Protocol.ObjectDiffusion.Type
+
+-- Note: This module is inspired from TxSubmission outbound side.
+
+data TraceObjectDiffusionOutbound objectId object
+  = TraceObjectDiffusionOutboundRecvMsgRequestObjectIds NumObjectIdsReq
+  | -- | The IDs to be sent in the response
+    TraceObjectDiffusionOutboundSendMsgReplyObjectIds [objectId]
+  | -- | The IDs of the objects requested.
+    TraceObjectDiffusionOutboundRecvMsgRequestObjects
+      [objectId]
+  | -- | The objects to be sent in the response.
+    TraceObjectDiffusionOutboundSendMsgReplyObjects
+      [object]
+  | -- | Received 'MsgDone'
+    TraceObjectDiffusionOutboundTerminated
+  deriving Show
+
+data ObjectDiffusionOutboundError
+  = ProtocolErrorAckedTooManyObjectIds
+  | ProtocolErrorRequestedNothing
+  | ProtocolErrorRequestedTooManyObjectIds NumObjectIdsReq NumObjectsOutstanding
+  | ProtocolErrorRequestBlocking
+  | ProtocolErrorRequestNonBlocking
+  | ProtocolErrorRequestedUnavailableObject
+  | ProtocolErrorRequestedDuplicateObject
+  deriving Show
+
+instance Exception ObjectDiffusionOutboundError where
+  displayException ProtocolErrorAckedTooManyObjectIds =
+    "The peer tried to acknowledged more objectIds than are available to do so."
+  displayException (ProtocolErrorRequestedTooManyObjectIds reqNo maxUnacked) =
+    "The peer requested "
+      ++ show reqNo
+      ++ " objectIds which would put the "
+      ++ "total in flight over the limit of "
+      ++ show maxUnacked
+  displayException ProtocolErrorRequestedNothing =
+    "The peer requested zero objectIds."
+  displayException ProtocolErrorRequestBlocking =
+    "The peer made a blocking request for more objectIds when there are still "
+      ++ "unacknowledged objectIds. It should have used a non-blocking request."
+  displayException ProtocolErrorRequestNonBlocking =
+    "The peer made a non-blocking request for more objectIds when there are "
+      ++ "no unacknowledged objectIds. It should have used a blocking request."
+  displayException ProtocolErrorRequestedUnavailableObject =
+    "The peer requested an object which is not available, either "
+      ++ "because it was never available or because it was previously requested."
+  displayException ProtocolErrorRequestedDuplicateObject =
+    "The peer requested the same object twice."
+
+data OutboundSt objectId object ticketNo = OutboundSt
+  { outstandingFifo :: !(StrictSeq object)
+  , lastTicketNo :: !ticketNo
+  }
+
+objectDiffusionOutbound ::
+  forall objectId object ticketNo m.
+  (Ord objectId, Ord ticketNo, MonadSTM m, MonadThrow m) =>
+  Tracer m (TraceObjectDiffusionOutbound objectId object) ->
+  -- | Maximum number of unacknowledged objectIds allowed
+  NumObjectsOutstanding ->
+  ObjectPoolReader objectId object ticketNo m ->
+  NodeToNodeVersion ->
+  ObjectDiffusionOutbound objectId object m ()
+objectDiffusionOutbound tracer maxFifoLength ObjectPoolReader{..} _version =
+  ObjectDiffusionOutbound (pure (makeBundle $ OutboundSt Seq.empty oprZeroTicketNo))
+ where
+  makeBundle :: OutboundSt objectId object ticketNo -> OutboundStIdle objectId object m ()
+  makeBundle !st =
+    OutboundStIdle
+      { recvMsgRequestObjectIds = recvMsgRequestObjectIds st
+      , recvMsgRequestObjects = recvMsgRequestObjects st
+      , recvMsgDone = traceWith tracer TraceObjectDiffusionOutboundTerminated
+      }
+
+  updateStNewObjects ::
+    OutboundSt objectId object ticketNo ->
+    [(object, ticketNo)] ->
+    OutboundSt objectId object ticketNo
+  updateStNewObjects !OutboundSt{..} newObjectsWithTicketNos =
+    -- These objects should all be fresh
+    assert (all (\(_, ticketNo) -> ticketNo > lastTicketNo) newObjectsWithTicketNos) $
+      let !outstandingFifo' =
+            outstandingFifo
+              <> (Seq.fromList $ fst <$> newObjectsWithTicketNos)
+          !lastTicketNo'
+            | null newObjectsWithTicketNos = lastTicketNo
+            | otherwise = snd $ last newObjectsWithTicketNos
+       in OutboundSt
+            { outstandingFifo = outstandingFifo'
+            , lastTicketNo = lastTicketNo'
+            }
+
+  recvMsgRequestObjectIds ::
+    forall blocking.
+    OutboundSt objectId object ticketNo ->
+    SingBlockingStyle blocking ->
+    NumObjectIdsAck ->
+    NumObjectIdsReq ->
+    m (OutboundStObjectIds blocking objectId object m ())
+  recvMsgRequestObjectIds !st@OutboundSt{..} blocking numIdsToAck numIdsToReq = do
+    traceWith tracer (TraceObjectDiffusionOutboundRecvMsgRequestObjectIds numIdsToReq)
+
+    when (numIdsToAck > fromIntegral (Seq.length outstandingFifo)) $
+      throwIO ProtocolErrorAckedTooManyObjectIds
+
+    when
+      ( Seq.length outstandingFifo
+          - fromIntegral numIdsToAck
+          + fromIntegral numIdsToReq
+          > fromIntegral maxFifoLength
+      )
+      $ throwIO (ProtocolErrorRequestedTooManyObjectIds numIdsToReq maxFifoLength)
+
+    -- First we update our FIFO to remove the number of objectIds that the
+    -- inbound peer has acknowledged.
+    let !outstandingFifo' = Seq.drop (fromIntegral numIdsToAck) outstandingFifo
+        -- must specify the type here otherwise GHC complains about mismatch objectId types
+        st' :: OutboundSt objectId object ticketNo
+        !st' = st{outstandingFifo = outstandingFifo'}
+
+    -- Grab info about any new objects after the last object ticketNo we've
+    -- seen, up to the number that the peer has requested.
+    case blocking of
+      -----------------------------------------------------------------------
+      SingBlocking -> do
+        when (numIdsToReq == 0) $
+          throwIO ProtocolErrorRequestedNothing
+        unless (Seq.null outstandingFifo') $
+          throwIO ProtocolErrorRequestBlocking
+
+        newContent <- atomically $ do
+          newObjectsWithTicketNos <-
+            oprObjectsAfter
+              lastTicketNo
+              (fromIntegral numIdsToReq)
+          check (not $ null newObjectsWithTicketNos)
+          pure newObjectsWithTicketNos
+
+        newObjectsWithTicketNos <- forM newContent $
+          \(ticketNo, _, getObject) -> do
+            object <- getObject
+            pure (object, ticketNo)
+
+        let !newIds = oprObjectId . fst <$> newObjectsWithTicketNos
+            st'' = updateStNewObjects st' newObjectsWithTicketNos
+
+        traceWith tracer (TraceObjectDiffusionOutboundSendMsgReplyObjectIds newIds)
+
+        -- Assert objects is non-empty: we blocked until objects was
+        -- non-null, and we know numIdsToReq > 0, hence
+        -- `take numIdsToReq objects` is non-null.
+        assert (not $ null newObjectsWithTicketNos) $
+          pure $
+            SendMsgReplyObjectIds
+              (BlockingReply (NonEmpty.fromList $ newIds))
+              (makeBundle st'')
+
+      -----------------------------------------------------------------------
+      SingNonBlocking -> do
+        when (numIdsToReq == 0 && numIdsToAck == 0) $
+          throwIO ProtocolErrorRequestedNothing
+        when (Seq.null outstandingFifo') $
+          throwIO ProtocolErrorRequestNonBlocking
+
+        newContent <-
+          atomically $
+            oprObjectsAfter lastTicketNo (fromIntegral numIdsToReq)
+        newObjectsWithTicketNos <- forM newContent $
+          \(ticketNo, _, getObject) -> do
+            object <- getObject
+            pure (object, ticketNo)
+
+        let !newIds = oprObjectId . fst <$> newObjectsWithTicketNos
+            st'' = updateStNewObjects st' newObjectsWithTicketNos
+
+        traceWith tracer (TraceObjectDiffusionOutboundSendMsgReplyObjectIds newIds)
+
+        pure (SendMsgReplyObjectIds (NonBlockingReply newIds) (makeBundle st''))
+
+  recvMsgRequestObjects ::
+    OutboundSt objectId object ticketNo ->
+    [objectId] ->
+    m (OutboundStObjects objectId object m ())
+  recvMsgRequestObjects !st@OutboundSt{..} requestedIds = do
+    traceWith tracer (TraceObjectDiffusionOutboundRecvMsgRequestObjects requestedIds)
+
+    -- All the objects correspond to advertised objectIds are already in the
+    -- outstandingFifo. So we don't need to read from the object pool here.
+
+    -- I've optimized the search to do only one traversal of 'outstandingFifo'.
+    -- When the 'requestedIds' is exactly the whole 'outstandingFifo', then this
+    -- should take O(n * log n) time.
+    --
+    -- TODO: We might need to revisit the underlying 'outstandingFifo' data
+    -- structure and the search if performance isn't sufficient when we'll use
+    -- ObjectDiffusion for votes diffusion (and not just cert diffusion).
+
+    let requestedIdsSet = Set.fromList requestedIds
+
+    when (Set.size requestedIdsSet /= length requestedIds) $
+      throwIO ProtocolErrorRequestedDuplicateObject
+
+    let requestedObjects =
+          foldr
+            ( \obj acc ->
+                if Set.member (oprObjectId obj) requestedIdsSet
+                  then obj : acc
+                  else acc
+            )
+            []
+            outstandingFifo
+
+    when (Set.size requestedIdsSet /= length requestedObjects) $
+      throwIO ProtocolErrorRequestedUnavailableObject
+
+    traceWith tracer (TraceObjectDiffusionOutboundSendMsgReplyObjects requestedObjects)
+
+    pure (SendMsgReplyObjects requestedObjects (makeBundle st))
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/PerasCert.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/PerasCert.hs
new file mode 100644
index 000000000..ba0ba934a
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/MiniProtocol/ObjectDiffusion/PerasCert.hs
@@ -0,0 +1,41 @@
+-- | This module defines type aliases for the ObjectDiffusion protocol applied
+-- to PerasCert diffusion.
+module Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.PerasCert
+  ( TracePerasCertDiffusionInbound
+  , TracePerasCertDiffusionOutbound
+  , PerasCertPoolReader
+  , PerasCertPoolWriter
+  , PerasCertDiffusionInboundPipelined
+  , PerasCertDiffusionOutbound
+  , PerasCertDiffusion
+  ) where
+
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Inbound
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Outbound
+import Ouroboros.Consensus.Storage.PerasCertDB.API
+import Ouroboros.Network.Protocol.ObjectDiffusion.Inbound (ObjectDiffusionInboundPipelined)
+import Ouroboros.Network.Protocol.ObjectDiffusion.Outbound (ObjectDiffusionOutbound)
+import Ouroboros.Network.Protocol.ObjectDiffusion.Type (ObjectDiffusion)
+
+type TracePerasCertDiffusionInbound blk =
+  TraceObjectDiffusionInbound PerasRoundNo (PerasCert blk)
+
+type TracePerasCertDiffusionOutbound blk =
+  TraceObjectDiffusionOutbound PerasRoundNo (PerasCert blk)
+
+type PerasCertPoolReader blk m =
+  ObjectPoolReader PerasRoundNo (PerasCert blk) PerasCertTicketNo m
+
+type PerasCertPoolWriter blk m =
+  ObjectPoolWriter PerasRoundNo (PerasCert blk) m
+
+type PerasCertDiffusionInboundPipelined blk m a =
+  ObjectDiffusionInboundPipelined PerasRoundNo (PerasCert blk) m a
+
+type PerasCertDiffusionOutbound blk m a =
+  ObjectDiffusionOutbound PerasRoundNo (PerasCert blk) m a
+
+type PerasCertDiffusion blk =
+  ObjectDiffusion PerasRoundNo (PerasCert blk)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/ProtocolInfo.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/ProtocolInfo.hs
index 496977b85..eea51e42f 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/ProtocolInfo.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/ProtocolInfo.hs
@@ -35,7 +35,7 @@ enumCoreNodes (NumCoreNodes numNodes) =
 
 -- | Data required to run the specified protocol.
 data ProtocolInfo b = ProtocolInfo
-  { pInfoConfig :: TopLevelConfig b
+  { pInfoConfig :: !(TopLevelConfig b)
   , pInfoInitLedger :: ExtLedgerState b ValuesMK
   -- ^ At genesis, this LedgerState must contain the UTxOs for the initial
   -- era (which for Cardano is Byron that has void tables).
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/Serialisation.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/Serialisation.hs
index 6520aae47..6a4fc8722 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/Serialisation.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Node/Serialisation.hs
@@ -6,8 +6,11 @@
 {-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE PolyKinds #-}
 {-# LANGUAGE RankNTypes #-}
+{-# LANGUAGE RecordWildCards #-}
+{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE StandaloneKindSignatures #-}
+{-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE UndecidableInstances #-}
 
 -- | Serialisation for sending things across the network.
@@ -33,8 +36,8 @@ module Ouroboros.Consensus.Node.Serialisation
   , Some (..)
   ) where
 
-import Codec.CBOR.Decoding (Decoder)
-import Codec.CBOR.Encoding (Encoding)
+import Codec.CBOR.Decoding (Decoder, decodeListLenOf)
+import Codec.CBOR.Encoding (Encoding, encodeListLen)
 import Codec.Serialise (Serialise (decode, encode))
 import Data.Kind
 import Data.SOP.BasicFunctors
@@ -47,7 +50,15 @@ import Ouroboros.Consensus.Ledger.SupportsMempool
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
 import Ouroboros.Consensus.TypeFamilyWrappers
 import Ouroboros.Consensus.Util (Some (..))
-import Ouroboros.Network.Block (unwrapCBORinCBOR, wrapCBORinCBOR)
+import Ouroboros.Network.Block
+  ( Tip
+  , decodePoint
+  , decodeTip
+  , encodePoint
+  , encodeTip
+  , unwrapCBORinCBOR
+  , wrapCBORinCBOR
+  )
 
 {-------------------------------------------------------------------------------
   NodeToNode
@@ -173,6 +184,29 @@ deriving newtype instance
   SerialiseNodeToNode blk (GenTxId blk) =>
   SerialiseNodeToNode blk (WrapGenTxId blk)
 
+instance ConvertRawHash blk => SerialiseNodeToNode blk (Point blk) where
+  encodeNodeToNode _ccfg _version = encodePoint $ encodeRawHash (Proxy @blk)
+  decodeNodeToNode _ccfg _version = decodePoint $ decodeRawHash (Proxy @blk)
+
+instance ConvertRawHash blk => SerialiseNodeToNode blk (Tip blk) where
+  encodeNodeToNode _ccfg _version = encodeTip $ encodeRawHash (Proxy @blk)
+  decodeNodeToNode _ccfg _version = decodeTip $ decodeRawHash (Proxy @blk)
+
+instance SerialiseNodeToNode blk PerasRoundNo where
+  encodeNodeToNode _ccfg _version = encode
+  decodeNodeToNode _ccfg _version = decode
+instance ConvertRawHash blk => SerialiseNodeToNode blk (PerasCert blk) where
+  -- Consistent with the 'Serialise' instance for 'PerasCert' defined in Ouroboros.Consensus.Block.SupportsPeras
+  encodeNodeToNode ccfg version PerasCert{..} =
+    encodeListLen 2
+      <> encodeNodeToNode ccfg version pcCertRound
+      <> encodeNodeToNode ccfg version pcCertBoostedBlock
+  decodeNodeToNode ccfg version = do
+    decodeListLenOf 2
+    pcCertRound <- decodeNodeToNode ccfg version
+    pcCertBoostedBlock <- decodeNodeToNode ccfg version
+    pure $ PerasCert pcCertRound pcCertBoostedBlock
+
 deriving newtype instance
   SerialiseNodeToClient blk (GenTxId blk) =>
   SerialiseNodeToClient blk (WrapGenTxId blk)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/SelectView.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/SelectView.hs
new file mode 100644
index 000000000..04e4eed8e
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/SelectView.hs
@@ -0,0 +1,141 @@
+{-# LANGUAGE DerivingStrategies #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeOperators #-}
+{-# LANGUAGE UndecidableInstances #-}
+{-# LANGUAGE ViewPatterns #-}
+
+module Ouroboros.Consensus.Peras.SelectView
+  ( -- * 'WeightedSelectView'
+    WeightedSelectView (..)
+  , wsvTotalWeight
+  , weightedSelectView
+
+    -- * Utility: 'WithEmptyFragment'
+  , WithEmptyFragment (..)
+  , withEmptyFragmentFromMaybe
+  , withEmptyFragmentToMaybe
+  ) where
+
+import Data.Function (on)
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight
+import Ouroboros.Consensus.Protocol.Abstract
+import Ouroboros.Network.AnchoredFragment (AnchoredFragment)
+import qualified Ouroboros.Network.AnchoredFragment as AF
+
+{-------------------------------------------------------------------------------
+  Weighted select views
+-------------------------------------------------------------------------------}
+
+-- | Information from a non-empty chain fragment for a weighted chain comparison
+-- against other fragments with the same anchor.
+--
+-- Comparisons of fragments with different anchors are not possible in general,
+-- as the fragments might not intersect, and so some blocks after their
+-- intersection (and hence their weight boost) are unknown.
+data WeightedSelectView proto = WeightedSelectView
+  { wsvBlockNo :: !BlockNo
+  -- ^ The 'BlockNo' at the tip of a fragment.
+  , wsvWeightBoost :: !PerasWeight
+  -- ^ The weight boost of a fragment (w.r.t. a particular anchor).
+  , wsvTiebreaker :: TiebreakerView proto
+  -- ^ Lazy because it is only needed when 'wsvTotalWeight' is inconclusive.
+  }
+
+deriving stock instance Show (TiebreakerView proto) => Show (WeightedSelectView proto)
+deriving stock instance Eq (TiebreakerView proto) => Eq (WeightedSelectView proto)
+
+-- TODO: More type safety to prevent people from accidentally comparing
+-- 'WeightedSelectView's obtained from fragments with different anchors?
+-- Something ST-trick like?
+
+-- | The total weight, ie the sum of 'wsvBlockNo' and 'wsvBoostedWeight'.
+wsvTotalWeight :: WeightedSelectView proto -> PerasWeight
+-- could be cached, but then we need to be careful to maintain the invariant
+wsvTotalWeight wsv =
+  PerasWeight (unBlockNo (wsvBlockNo wsv)) <> wsvWeightBoost wsv
+
+instance Ord (TiebreakerView proto) => Ord (WeightedSelectView proto) where
+  compare =
+    mconcat
+      [ compare `on` wsvTotalWeight
+      , compare `on` wsvTiebreaker
+      ]
+
+instance ChainOrder (TiebreakerView proto) => ChainOrder (WeightedSelectView proto) where
+  type ChainOrderConfig (WeightedSelectView proto) = ChainOrderConfig (TiebreakerView proto)
+
+  preferCandidate cfg ours cand =
+    case compare (wsvTotalWeight ours) (wsvTotalWeight cand) of
+      LT -> True
+      EQ -> preferCandidate cfg (wsvTiebreaker ours) (wsvTiebreaker cand)
+      GT -> False
+
+-- | Get the 'WeightedSelectView' for a fragment using the given
+-- 'PerasWeightSnapshot'. Note that this is only meanigful for comparisons
+-- against other fragments /with the same anchor/.
+--
+-- Returns 'EmptyFragment' iff the input fragment is empty.
+weightedSelectView ::
+  ( GetHeader1 h
+  , HasHeader (h blk)
+  , HeaderHash blk ~ HeaderHash (h blk)
+  , BlockSupportsProtocol blk
+  ) =>
+  BlockConfig blk ->
+  PerasWeightSnapshot blk ->
+  AnchoredFragment (h blk) ->
+  WithEmptyFragment (WeightedSelectView (BlockProtocol blk))
+weightedSelectView bcfg weights = \case
+  AF.Empty{} -> EmptyFragment
+  frag@(_ AF.:> (getHeader1 -> hdr)) ->
+    NonEmptyFragment
+      WeightedSelectView
+        { wsvBlockNo = blockNo hdr
+        , wsvWeightBoost = weightBoostOfFragment weights frag
+        , wsvTiebreaker = tiebreakerView bcfg hdr
+        }
+
+{-------------------------------------------------------------------------------
+  WithEmptyFragment
+-------------------------------------------------------------------------------}
+
+-- | Attach the possibility of an empty fragment to a type.
+data WithEmptyFragment a = EmptyFragment | NonEmptyFragment !a
+  deriving stock (Show, Eq)
+
+withEmptyFragmentToMaybe :: WithEmptyFragment a -> Maybe a
+withEmptyFragmentToMaybe = \case
+  EmptyFragment -> Nothing
+  NonEmptyFragment a -> Just a
+
+withEmptyFragmentFromMaybe :: Maybe a -> WithEmptyFragment a
+withEmptyFragmentFromMaybe = \case
+  Nothing -> EmptyFragment
+  Just a -> NonEmptyFragment a
+
+-- | Prefer non-empty fragments to empty ones.
+instance Ord a => Ord (WithEmptyFragment a) where
+  compare = \cases
+    EmptyFragment EmptyFragment -> EQ
+    EmptyFragment NonEmptyFragment{} -> LT
+    NonEmptyFragment{} EmptyFragment -> GT
+    (NonEmptyFragment a) (NonEmptyFragment b) -> compare a b
+
+-- | Prefer non-empty fragments to empty ones. This instance assumes that the
+-- underlying fragments all have the same anchor.
+instance ChainOrder a => ChainOrder (WithEmptyFragment a) where
+  type ChainOrderConfig (WithEmptyFragment a) = ChainOrderConfig a
+
+  preferCandidate cfg = \cases
+    -- We prefer any non-empty fragment to the empty fragment.
+    EmptyFragment NonEmptyFragment{} -> True
+    -- We never prefer the empty fragment to our selection (even if it is also
+    -- empty).
+    _ EmptyFragment -> False
+    -- Otherwise, defer to @'ChainOrder' a@.
+    (NonEmptyFragment ours) (NonEmptyFragment cand) ->
+      preferCandidate cfg ours cand
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/Weight.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/Weight.hs
new file mode 100644
index 000000000..d122f9da8
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Peras/Weight.hs
@@ -0,0 +1,389 @@
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeOperators #-}
+
+-- | Data structure for tracking the weight of blocks due to Peras boosts.
+module Ouroboros.Consensus.Peras.Weight
+  ( -- * 'PerasWeightSnapshot' type
+    PerasWeightSnapshot
+
+    -- * Construction
+  , emptyPerasWeightSnapshot
+  , mkPerasWeightSnapshot
+
+    -- * Conversion
+  , perasWeightSnapshotToList
+
+    -- * Insertion
+  , addToPerasWeightSnapshot
+
+    -- * Pruning
+  , prunePerasWeightSnapshot
+
+    -- * Query
+  , isEmptyPerasWeightSnapshot
+  , weightBoostOfPoint
+  , weightBoostOfFragment
+  , totalWeightOfFragment
+  , takeVolatileSuffix
+  ) where
+
+import Data.Foldable as Foldable (foldl')
+import Data.Map.Strict (Map)
+import qualified Data.Map.Strict as Map
+import GHC.Generics (Generic)
+import NoThunks.Class
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Config.SecurityParam
+import Ouroboros.Consensus.Util.AnchoredSeq (takeLongestSuffix)
+import Ouroboros.Network.AnchoredFragment (AnchoredFragment)
+import qualified Ouroboros.Network.AnchoredFragment as AF
+
+-- | Data structure for tracking the weight of blocks due to Peras boosts.
+newtype PerasWeightSnapshot blk = PerasWeightSnapshot
+  { getPerasWeightSnapshot :: Map (Point blk) PerasWeight
+  }
+  deriving stock Eq
+  deriving Generic
+  deriving newtype NoThunks
+
+instance StandardHash blk => Show (PerasWeightSnapshot blk) where
+  show = show . perasWeightSnapshotToList
+
+-- | An empty 'PerasWeightSnapshot' not containing any boosted blocks.
+emptyPerasWeightSnapshot :: PerasWeightSnapshot blk
+emptyPerasWeightSnapshot = PerasWeightSnapshot Map.empty
+
+-- | Create a weight snapshot from a list of boosted points with an associated
+-- weight. In case of duplicate points, their weights are combined.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> snap = mkPerasWeightSnapshot weights
+-- >>> snap
+-- [(Point Origin,PerasWeight 3),(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 4),(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+mkPerasWeightSnapshot ::
+  StandardHash blk =>
+  [(Point blk, PerasWeight)] ->
+  PerasWeightSnapshot blk
+mkPerasWeightSnapshot =
+  Foldable.foldl'
+    (\s (pt, weight) -> addToPerasWeightSnapshot pt weight s)
+    emptyPerasWeightSnapshot
+
+-- | Return the list of boosted points with their associated weight, sorted
+-- based on their point. Does not contain duplicate points.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> snap = mkPerasWeightSnapshot weights
+-- >>> perasWeightSnapshotToList snap
+-- [(Point Origin,PerasWeight 3),(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 4),(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+perasWeightSnapshotToList :: PerasWeightSnapshot blk -> [(Point blk, PerasWeight)]
+perasWeightSnapshotToList = Map.toAscList . getPerasWeightSnapshot
+
+-- | Add weight for the given point to the 'PerasWeightSnapshot'. If the point
+-- already has some weight, it is added on top.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   ]
+-- :}
+--
+-- >>> snap0 = mkPerasWeightSnapshot weights
+-- >>> snap0
+-- [(Point Origin,PerasWeight 3),(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 2)]
+--
+-- >>> snap1 = addToPerasWeightSnapshot (BlockPoint 3 "bar") (PerasWeight 2) snap0
+-- >>> snap1
+-- [(Point Origin,PerasWeight 3),(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 2),(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+--
+-- >>> snap2 = addToPerasWeightSnapshot (BlockPoint 2 "foo") (PerasWeight 2) snap1
+-- >>> snap2
+-- [(Point Origin,PerasWeight 3),(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 4),(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+addToPerasWeightSnapshot ::
+  StandardHash blk =>
+  Point blk ->
+  PerasWeight ->
+  PerasWeightSnapshot blk ->
+  PerasWeightSnapshot blk
+addToPerasWeightSnapshot pt weight =
+  PerasWeightSnapshot . Map.insertWith (<>) pt weight . getPerasWeightSnapshot
+
+-- | Prune the given 'PerasWeightSnapshot' by removing the weight of all blocks
+-- strictly older than the given slot.
+--
+-- This function is used to get garbage-collect boosted blocks blocks which are
+-- older than our immutable tip as we will never adopt a chain containing them.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> snap = mkPerasWeightSnapshot weights
+--
+-- >>> prunePerasWeightSnapshot (SlotNo 2) snap
+-- [(Point (At (Block {blockPointSlot = SlotNo 2, blockPointHash = "foo"})),PerasWeight 4),(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+--
+-- >>> prunePerasWeightSnapshot (SlotNo 3) snap
+-- [(Point (At (Block {blockPointSlot = SlotNo 3, blockPointHash = "bar"})),PerasWeight 2)]
+prunePerasWeightSnapshot ::
+  SlotNo ->
+  PerasWeightSnapshot blk ->
+  PerasWeightSnapshot blk
+prunePerasWeightSnapshot slot =
+  PerasWeightSnapshot . Map.dropWhileAntitone isTooOld . getPerasWeightSnapshot
+ where
+  isTooOld :: Point blk -> Bool
+  isTooOld pt = pointSlot pt < NotOrigin slot
+
+-- | Check whether the snapshot contains weights for any blocks.
+--
+-- >>> isEmptyPerasWeightSnapshot emptyPerasWeightSnapshot
+-- True
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> snap = mkPerasWeightSnapshot weights
+--
+-- >>> isEmptyPerasWeightSnapshot snap
+-- False
+isEmptyPerasWeightSnapshot :: PerasWeightSnapshot blk -> Bool
+isEmptyPerasWeightSnapshot = Map.null . getPerasWeightSnapshot
+
+-- | Get the weight boost for a point, or @'mempty' :: 'PerasWeight'@ otherwise.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> snap = mkPerasWeightSnapshot weights
+--
+-- >>> weightBoostOfPoint snap (BlockPoint 2 "foo")
+-- PerasWeight 4
+--
+-- >>> weightBoostOfPoint snap (BlockPoint 2 "baz")
+-- PerasWeight 0
+weightBoostOfPoint ::
+  forall blk.
+  StandardHash blk =>
+  PerasWeightSnapshot blk -> Point blk -> PerasWeight
+weightBoostOfPoint (PerasWeightSnapshot weightByPoint) pt =
+  Map.findWithDefault mempty pt weightByPoint
+
+-- | Get the weight boost for a fragment, ie the sum of all
+-- 'weightBoostOfPoint' for all points on the fragment (excluding the anchor).
+--
+-- Note that this quantity is relative to the anchor of the fragment, so it
+-- should only be compared against other fragments with the same anchor.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> :{
+-- snap = mkPerasWeightSnapshot weights
+-- foo = HeaderFields (SlotNo 2) (BlockNo 1) "foo"
+-- bar = HeaderFields (SlotNo 3) (BlockNo 2) "bar"
+-- frag0 :: AnchoredFragment (HeaderFields Blk)
+-- frag0 = Empty AnchorGenesis :> foo :> bar
+-- :}
+--
+-- >>> weightBoostOfFragment snap frag0
+-- PerasWeight 6
+--
+-- Only keeping the last block from @frag0@:
+--
+-- >>> frag1 = AF.anchorNewest 1 frag0
+-- >>> weightBoostOfFragment snap frag1
+-- PerasWeight 2
+--
+-- Dropping the head from @frag0@, and instead adding an unboosted point:
+--
+-- >>> frag2 = AF.dropNewest 1 frag0 :> HeaderFields (SlotNo 4) (BlockNo 2) "baz"
+-- >>> weightBoostOfFragment snap frag2
+-- PerasWeight 4
+weightBoostOfFragment ::
+  forall blk h.
+  (StandardHash blk, HasHeader h, HeaderHash blk ~ HeaderHash h) =>
+  PerasWeightSnapshot blk ->
+  AnchoredFragment h ->
+  PerasWeight
+weightBoostOfFragment weightSnap frag
+  | Map.null $ getPerasWeightSnapshot weightSnap =
+      mempty
+  | otherwise =
+      -- TODO: think about whether this could be done in sublinear complexity
+      -- see https://github.com/IntersectMBO/ouroboros-consensus/pull/1613
+      foldMap
+        (weightBoostOfPoint weightSnap . castPoint . blockPoint)
+        (AF.toOldestFirst frag)
+
+-- | Get the total weight for a fragment, ie the length plus the weight boost
+-- ('weightBoostOfFragment') of the fragment.
+--
+-- Note that this quantity is relative to the anchor of the fragment, so it
+-- should only be compared against other fragments with the same anchor.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- :}
+--
+-- >>> :{
+-- snap = mkPerasWeightSnapshot weights
+-- foo = HeaderFields (SlotNo 2) (BlockNo 1) "foo"
+-- bar = HeaderFields (SlotNo 3) (BlockNo 2) "bar"
+-- frag0 :: AnchoredFragment (HeaderFields Blk)
+-- frag0 = Empty AnchorGenesis :> foo :> bar
+-- :}
+--
+-- >>> totalWeightOfFragment snap frag0
+-- PerasWeight 8
+--
+-- Only keeping the last block from @frag0@:
+--
+-- >>> frag1 = AF.anchorNewest 1 frag0
+-- >>> totalWeightOfFragment snap frag1
+-- PerasWeight 3
+--
+-- Dropping the head from @frag0@, and instead adding an unboosted point:
+--
+-- >>> frag2 = AF.dropNewest 1 frag0 :> HeaderFields (SlotNo 4) (BlockNo 2) "baz"
+-- >>> totalWeightOfFragment snap frag2
+-- PerasWeight 6
+totalWeightOfFragment ::
+  forall blk h.
+  (StandardHash blk, HasHeader h, HeaderHash blk ~ HeaderHash h) =>
+  PerasWeightSnapshot blk ->
+  AnchoredFragment h ->
+  PerasWeight
+totalWeightOfFragment weightSnap frag =
+  weightLength <> weightBoost
+ where
+  weightLength = PerasWeight $ fromIntegral $ AF.length frag
+  weightBoost = weightBoostOfFragment weightSnap frag
+
+-- | Take the longest suffix of the given fragment with total weight
+-- ('totalWeightOfFragment') at most @k@. This is the volatile suffix of blocks
+-- which are subject to rollback.
+--
+-- If the total weight of the input fragment is at least @k@, then the anchor of
+-- the output fragment is the most recent point on the input fragment that is
+-- buried under at least weight @k@ (also counting the weight boost of that
+-- point).
+--
+-- See 'mkPerasWeightSnapshot' for context.
+--
+-- >>> :{
+-- weights :: [(Point Blk, PerasWeight)]
+-- weights =
+--   [ (BlockPoint 2 "foo", PerasWeight 2)
+--   , (GenesisPoint,       PerasWeight 3)
+--   , (BlockPoint 3 "bar", PerasWeight 2)
+--   , (BlockPoint 2 "foo", PerasWeight 2)
+--   ]
+-- snap = mkPerasWeightSnapshot weights
+-- foo = HeaderFields (SlotNo 2) (BlockNo 1) "foo"
+-- bar = HeaderFields (SlotNo 3) (BlockNo 2) "bar"
+-- frag :: AnchoredFragment (HeaderFields Blk)
+-- frag = Empty AnchorGenesis :> foo :> bar
+-- :}
+--
+-- >>> k1 = SecurityParam $ knownNonZeroBounded @1
+-- >>> k3 = SecurityParam $ knownNonZeroBounded @3
+-- >>> k6 = SecurityParam $ knownNonZeroBounded @6
+-- >>> k9 = SecurityParam $ knownNonZeroBounded @9
+--
+-- >>> AF.toOldestFirst $ takeVolatileSuffix snap k1 frag
+-- []
+--
+-- >>> AF.toOldestFirst $ takeVolatileSuffix snap k3 frag
+-- [HeaderFields {headerFieldSlot = SlotNo 3, headerFieldBlockNo = BlockNo 2, headerFieldHash = "bar"}]
+--
+-- >>> AF.toOldestFirst $ takeVolatileSuffix snap k6 frag
+-- [HeaderFields {headerFieldSlot = SlotNo 3, headerFieldBlockNo = BlockNo 2, headerFieldHash = "bar"}]
+--
+-- >>> AF.toOldestFirst $ takeVolatileSuffix snap k9 frag
+-- [HeaderFields {headerFieldSlot = SlotNo 2, headerFieldBlockNo = BlockNo 1, headerFieldHash = "foo"},HeaderFields {headerFieldSlot = SlotNo 3, headerFieldBlockNo = BlockNo 2, headerFieldHash = "bar"}]
+takeVolatileSuffix ::
+  forall blk h.
+  (StandardHash blk, HasHeader h, HeaderHash blk ~ HeaderHash h) =>
+  PerasWeightSnapshot blk ->
+  -- | The security parameter @k@ is interpreted as a weight.
+  SecurityParam ->
+  AnchoredFragment h ->
+  AnchoredFragment h
+takeVolatileSuffix snap secParam
+  | Map.null $ getPerasWeightSnapshot snap =
+      -- Optimize the case where Peras is disabled.
+      AF.anchorNewest (unPerasWeight k)
+  | otherwise =
+      takeLongestSuffix (totalWeightOfFragment snap) (<= k)
+ where
+  k :: PerasWeight
+  k = maxRollbackWeight secParam
+
+-- $setup
+-- >>> import Cardano.Ledger.BaseTypes
+-- >>> import Ouroboros.Consensus.Block
+-- >>> import Ouroboros.Consensus.Config.SecurityParam
+-- >>> import Ouroboros.Network.AnchoredFragment (AnchoredFragment, AnchoredSeq(..), Anchor(..))
+-- >>> import qualified Ouroboros.Network.AnchoredFragment as AF
+-- >>> :set -XDataKinds -XTypeApplications -XTypeFamilies
+-- >>> data Blk = Blk
+-- >>> type instance HeaderHash Blk = String
+-- >>> instance StandardHash Blk
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Protocol/MockChainSel.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Protocol/MockChainSel.hs
index 341a91649..676f01f02 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Protocol/MockChainSel.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Protocol/MockChainSel.hs
@@ -9,9 +9,9 @@ module Ouroboros.Consensus.Protocol.MockChainSel
 import Data.List (sortOn)
 import Data.Maybe (listToMaybe, mapMaybe)
 import Data.Ord (Down (..))
+import Ouroboros.Consensus.Peras.SelectView (WeightedSelectView (..), WithEmptyFragment (..))
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Network.Mock.Chain (Chain)
-import qualified Ouroboros.Network.Mock.Chain as Chain
 
 {-------------------------------------------------------------------------------
   Chain selection
@@ -33,8 +33,9 @@ selectChain ::
   forall proxy p hdr l.
   ConsensusProtocol p =>
   proxy p ->
-  ChainOrderConfig (SelectView p) ->
-  (hdr -> SelectView p) ->
+  ChainOrderConfig (WeightedSelectView p) ->
+  -- | Compute the 'WeightedSelectView' of a chain.
+  (Chain hdr -> WithEmptyFragment (WeightedSelectView p)) ->
   -- | Our chain
   Chain hdr ->
   -- | Upstream chains
@@ -51,24 +52,19 @@ selectChain _ cfg view ours =
   -- extract the 'SelectView' of the tip of the candidate.
   selectPreferredCandidate ::
     (Chain hdr, l) ->
-    Maybe (SelectView p, (Chain hdr, l))
-  selectPreferredCandidate x@(cand, _) =
-    case (Chain.head ours, Chain.head cand) of
-      (Nothing, Just candTip) ->
-        Just (view candTip, x)
-      (Just ourTip, Just candTip)
-        | let candView = view candTip
-        , preferCandidate cfg (view ourTip) candView ->
-            Just (candView, x)
-      _otherwise ->
-        Nothing
+    Maybe (WithEmptyFragment (WeightedSelectView p), (Chain hdr, l))
+  selectPreferredCandidate x@(cand, _)
+    | let candView = view cand
+    , preferCandidate cfg (view ours) candView =
+        Just (candView, x)
+    | otherwise = Nothing
 
 -- | Chain selection on unvalidated chains
 selectUnvalidatedChain ::
   ConsensusProtocol p =>
   proxy p ->
-  ChainOrderConfig (SelectView p) ->
-  (hdr -> SelectView p) ->
+  ChainOrderConfig (WeightedSelectView p) ->
+  (Chain hdr -> WithEmptyFragment (WeightedSelectView p)) ->
   Chain hdr ->
   [Chain hdr] ->
   Maybe (Chain hdr)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/API.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/API.hs
index 303fbcf78..8b89764c2 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/API.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/API.hs
@@ -25,6 +25,10 @@ module Ouroboros.Consensus.Storage.ChainDB.API
   , addBlockWaitWrittenToDisk
   , addBlock_
 
+    -- * Adding a Peras certificate
+  , AddPerasCertPromise (..)
+  , addPerasCertSync
+
     -- * Trigger chain selection
   , ChainSelectionPromise (..)
   , triggerChainSelection
@@ -83,6 +87,7 @@ import Ouroboros.Consensus.HeaderStateHistory
 import Ouroboros.Consensus.HeaderValidation (HeaderWithTime (..))
 import Ouroboros.Consensus.Ledger.Abstract
 import Ouroboros.Consensus.Ledger.Extended
+import Ouroboros.Consensus.Peras.Weight (PerasWeightSnapshot)
 import Ouroboros.Consensus.Storage.ChainDB.API.Types.InvalidBlockPunishment
 import Ouroboros.Consensus.Storage.Common
 import Ouroboros.Consensus.Storage.LedgerDB
@@ -90,6 +95,7 @@ import Ouroboros.Consensus.Storage.LedgerDB
   , ReadOnlyForker'
   , Statistics
   )
+import Ouroboros.Consensus.Storage.PerasCertDB.API (PerasCertSnapshot)
 import Ouroboros.Consensus.Storage.Serialisation
 import Ouroboros.Consensus.Util.CallStack
 import Ouroboros.Consensus.Util.IOLike
@@ -188,6 +194,10 @@ data ChainDB m blk = ChainDB
   --
   -- NOTE: A direct consequence of this guarantee is that the anchor of the
   -- fragment will move as the chain grows.
+  --
+  -- Note that with Ouroboros Peras, the size of this fragment is defined in
+  -- terms /weight/ instead of /length/, see
+  -- 'Ouroboros.Consensus.Peras.Weight.takeVolatileSuffix'.
   , getCurrentChainWithTime ::
       STM m (AnchoredFragment (HeaderWithTime blk))
   -- ^ Exact same as 'getCurrentChain', except each header is annotated
@@ -386,6 +396,15 @@ data ChainDB m blk = ChainDB
   , getStatistics :: m (Maybe Statistics)
   -- ^ Get statistics from the LedgerDB, in particular the number of entries
   -- in the tables.
+  , addPerasCertAsync :: ValidatedPerasCert blk -> m (AddPerasCertPromise m)
+  -- ^ Asynchronously insert a certificate to the DB. If this leads to a fork to
+  -- be weightier than our current selection, this will trigger a fork switch.
+  , getPerasWeightSnapshot :: STM m (WithFingerprint (PerasWeightSnapshot blk))
+  -- ^ Get the 'PerasWeightSnapshot', representing the Peras weight boosts for
+  -- all blocks newer than the current immutable tip.
+  , getPerasCertSnapshot :: STM m (PerasCertSnapshot blk)
+  -- ^ Get the Peras certificate snapshot, containing the currently-known
+  -- certificates boosting blocks newer than the immutable tip.
   , closeDB :: m ()
   -- ^ Close the ChainDB
   --
@@ -505,6 +524,23 @@ triggerChainSelection :: IOLike m => ChainDB m blk -> m ()
 triggerChainSelection chainDB =
   waitChainSelectionPromise =<< chainSelAsync chainDB
 
+{-------------------------------------------------------------------------------
+  Adding a Peras certificate
+-------------------------------------------------------------------------------}
+
+newtype AddPerasCertPromise m = AddPerasCertPromise
+  { waitPerasCertProcessed :: m ()
+  -- ^ Wait until the Peras certificate has been processed (which potentially
+  -- includes switching to a different chain). If the PerasCertDB did already
+  -- contain a certificate for this round, the certificate is ignored (as the
+  -- two certificates must be identical because certificate equivocation is
+  -- impossible).
+  }
+
+addPerasCertSync :: IOLike m => ChainDB m blk -> ValidatedPerasCert blk -> m ()
+addPerasCertSync chainDB cert =
+  waitPerasCertProcessed =<< addPerasCertAsync chainDB cert
+
 {-------------------------------------------------------------------------------
   Serialised block/header with its point
 -------------------------------------------------------------------------------}
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl.hs
index e5f7b2101..a49173a15 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl.hs
@@ -16,6 +16,7 @@ module Ouroboros.Consensus.Storage.ChainDB.Impl
     -- * Trace types
   , SelectionChangedInfo (..)
   , TraceAddBlockEvent (..)
+  , TraceAddPerasCertEvent (..)
   , TraceChainSelStarvationEvent (..)
   , TraceCopyToImmutableDBEvent (..)
   , TraceEvent (..)
@@ -79,6 +80,7 @@ import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
 import qualified Ouroboros.Consensus.Storage.ImmutableDB.Stream as ImmutableDB
 import Ouroboros.Consensus.Storage.LedgerDB (LedgerSupportsLedgerDB)
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util (newFuse, whenJust, withFuse)
 import Ouroboros.Consensus.Util.Args
@@ -173,12 +175,15 @@ openDBInternal args launchBgTasks = runWithTempRegistry $ do
         ledgerDbGetVolatileSuffix
     traceWith tracer $ TraceOpenEvent OpenedLgrDB
 
+    perasCertDB <- PerasCertDB.openDB argsPerasCertDB
+
     varInvalid <- newTVarIO (WithFingerprint Map.empty (Fingerprint 0))
 
     let initChainSelTracer = TraceInitChainSelEvent >$< tracer
 
     traceWith initChainSelTracer StartedInitChainSelection
     initialLoE <- Args.cdbsLoE cdbSpecificArgs
+    initialWeights <- atomically $ PerasCertDB.getWeightSnapshot perasCertDB
     chain <- withRegistry $ \rr -> do
       chainAndLedger <-
         ChainSel.initialChainSelection
@@ -190,6 +195,7 @@ openDBInternal args launchBgTasks = runWithTempRegistry $ do
           (Args.cdbsTopLevelConfig cdbSpecificArgs)
           varInvalid
           (void initialLoE)
+          (forgetFingerprint initialWeights)
       traceWith initChainSelTracer InitialChainSelected
 
       let chain = VF.validatedFragment chainAndLedger
@@ -250,6 +256,7 @@ openDBInternal args launchBgTasks = runWithTempRegistry $ do
             , cdbChainSelQueue = chainSelQueue
             , cdbLoE = Args.cdbsLoE cdbSpecificArgs
             , cdbChainSelStarvation = varChainSelStarvation
+            , cdbPerasCertDB = perasCertDB
             }
 
     setGetCurrentChainForLedgerDB $ Query.getCurrentChain env
@@ -280,6 +287,9 @@ openDBInternal args launchBgTasks = runWithTempRegistry $ do
             , getHeaderStateHistory = getEnvSTM h Query.getHeaderStateHistory
             , getReadOnlyForkerAtPoint = getEnv2 h Query.getReadOnlyForkerAtPoint
             , getStatistics = getEnv h Query.getStatistics
+            , addPerasCertAsync = getEnv1 h ChainSel.addPerasCertAsync
+            , getPerasWeightSnapshot = getEnvSTM h Query.getPerasWeightSnapshot
+            , getPerasCertSnapshot = getEnvSTM h Query.getPerasCertSnapshot
             }
     addBlockTestFuse <- newFuse "test chain selection"
     copyTestFuse <- newFuse "test copy to immutable db"
@@ -310,7 +320,12 @@ openDBInternal args launchBgTasks = runWithTempRegistry $ do
   return ((chainDB, testing), env)
  where
   tracer = Args.cdbsTracer cdbSpecificArgs
-  Args.ChainDbArgs argsImmutableDb argsVolatileDb argsLgrDb cdbSpecificArgs = args
+  Args.ChainDbArgs
+    argsImmutableDb
+    argsVolatileDb
+    argsLgrDb
+    argsPerasCertDB
+    cdbSpecificArgs = args
 
   -- The LedgerDB requires a criterion ('LedgerDB.GetVolatileSuffix')
   -- determining which of its states are volatile/immutable. Once we have
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Args.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Args.hs
index db793c8f0..0308b66dc 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Args.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Args.hs
@@ -29,6 +29,7 @@ import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.Ledger.Abstract
 import Ouroboros.Consensus.Ledger.Extended
+import Ouroboros.Consensus.Ledger.SupportsProtocol
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( GetLoEFragment
@@ -38,9 +39,12 @@ import Ouroboros.Consensus.Storage.ChainDB.Impl.Types
   ( TraceEvent (..)
   )
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
-import Ouroboros.Consensus.Storage.LedgerDB (LedgerDbFlavorArgs)
+import Ouroboros.Consensus.Storage.LedgerDB (LedgerDbBackendArgs)
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as LedgerDB
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as InMemory
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.IOLike
@@ -54,6 +58,7 @@ data ChainDbArgs f m blk = ChainDbArgs
   { cdbImmDbArgs :: ImmutableDB.ImmutableDbArgs f m blk
   , cdbVolDbArgs :: VolatileDB.VolatileDbArgs f m blk
   , cdbLgrDbArgs :: LedgerDB.LedgerDbArgs f m blk
+  , cdbPerasCertDbArgs :: PerasCertDB.PerasCertDbArgs f m blk
   , cdbsArgs :: ChainDbSpecificArgs f m blk
   }
 
@@ -131,13 +136,18 @@ defaultSpecificArgs =
 -- and must therefore be set explicitly.
 defaultArgs ::
   forall m blk.
-  Monad m =>
+  ( IOLike m
+  , LedgerDB.LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  , LedgerDB.LedgerSupportsInMemoryLedgerDB (LedgerState blk)
+  ) =>
   Incomplete ChainDbArgs m blk
 defaultArgs =
   ChainDbArgs
     ImmutableDB.defaultArgs
     VolatileDB.defaultArgs
-    LedgerDB.defaultArgs
+    (LedgerDB.defaultArgs $ LedgerDB.SomeBackendArgs InMemory.InMemArgs)
+    PerasCertDB.defaultArgs
     defaultSpecificArgs
 
 ensureValidateAll ::
@@ -169,7 +179,7 @@ completeChainDbArgs ::
   (RelativeMountPoint -> SomeHasFS m) ->
   -- | Volatile  FS, see 'NodeDatabasePaths'
   (RelativeMountPoint -> SomeHasFS m) ->
-  Complete LedgerDbFlavorArgs m ->
+  LedgerDbBackendArgs m blk ->
   -- | A set of incomplete arguments, possibly modified wrt @defaultArgs@
   Incomplete ChainDbArgs m blk ->
   Complete ChainDbArgs m blk
@@ -206,9 +216,13 @@ completeChainDbArgs
                 LedgerDB.configLedgerDb
                   cdbsTopLevelConfig
                   (LedgerDB.ledgerDbCfgComputeLedgerEvents $ LedgerDB.lgrConfig (cdbLgrDbArgs defArgs))
-            , LedgerDB.lgrFlavorArgs = flavorArgs
+            , LedgerDB.lgrBackendArgs = flavorArgs
             , LedgerDB.lgrRegistry = registry
             }
+      , cdbPerasCertDbArgs =
+          PerasCertDB.PerasCertDbArgs
+            { PerasCertDB.pcdbaTracer = PerasCertDB.pcdbaTracer (cdbPerasCertDbArgs defArgs)
+            }
       , cdbsArgs =
           (cdbsArgs defArgs)
             { cdbsRegistry = registry
@@ -226,6 +240,8 @@ updateTracer trcr args =
     { cdbImmDbArgs = (cdbImmDbArgs args){ImmutableDB.immTracer = TraceImmutableDBEvent >$< trcr}
     , cdbVolDbArgs = (cdbVolDbArgs args){VolatileDB.volTracer = TraceVolatileDBEvent >$< trcr}
     , cdbLgrDbArgs = (cdbLgrDbArgs args){LedgerDB.lgrTracer = TraceLedgerDBEvent >$< trcr}
+    , cdbPerasCertDbArgs =
+        (cdbPerasCertDbArgs args){PerasCertDB.pcdbaTracer = TracePerasCertDbEvent >$< trcr}
     , cdbsArgs = (cdbsArgs args){cdbsTracer = trcr}
     }
 
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Background.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Background.hs
index 37cfd65e2..370e66114 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Background.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Background.hs
@@ -71,6 +71,7 @@ import qualified Ouroboros.Consensus.Storage.ChainDB.Impl.Query as Query
 import Ouroboros.Consensus.Storage.ChainDB.Impl.Types
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
+import qualified Ouroboros.Consensus.Storage.PerasCertDB.API as PerasCertDB
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util
 import Ouroboros.Consensus.Util.Condense
@@ -399,6 +400,7 @@ garbageCollectBlocks CDB{..} slotNo = do
   VolatileDB.garbageCollect cdbVolatileDB slotNo
   atomically $ do
     modifyTVar cdbInvalid $ fmap $ Map.filter ((>= slotNo) . invalidBlockSlotNo)
+  PerasCertDB.garbageCollect cdbPerasCertDB slotNo
   traceWith cdbTracer $ TraceGCEvent $ PerformedGC slotNo
 
 {-------------------------------------------------------------------------------
@@ -632,6 +634,8 @@ addBlockRunner fuse cdb@CDB{..} = forever $ do
                   varBlockProcessed
                   (FailedToAddBlock "Failed to add block synchronously")
               pure ()
+            ChainSelAddPerasCert _cert varProcessed ->
+              void $ tryPutTMVar varProcessed ()
           closeChainSelQueue cdbChainSelQueue
       )
       ( \message -> do
@@ -640,6 +644,10 @@ addBlockRunner fuse cdb@CDB{..} = forever $ do
               trace PoppedReprocessLoEBlocksFromQueue
             ChainSelAddBlock BlockToAdd{blockToAdd} ->
               trace $ PoppedBlockFromQueue $ blockRealPoint blockToAdd
+            ChainSelAddPerasCert cert _varProcessed ->
+              traceWith cdbTracer $
+                TraceAddPerasCertEvent $
+                  PoppedPerasCertFromQueue (getPerasCertRound cert) (getPerasCertBoostedBlock cert)
           chainSelSync cdb message
           lift $ atomically $ processedChainSelMessage cdbChainSelQueue message
       )
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/ChainSel.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/ChainSel.hs
index a16e674b3..527813358 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/ChainSel.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/ChainSel.hs
@@ -13,6 +13,7 @@
 -- adding a block.
 module Ouroboros.Consensus.Storage.ChainDB.Impl.ChainSel
   ( addBlockAsync
+  , addPerasCertAsync
   , chainSelSync
   , chainSelectionForBlock
   , initialChainSelection
@@ -37,7 +38,7 @@ import Data.List.NonEmpty (NonEmpty)
 import qualified Data.List.NonEmpty as NE
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
-import Data.Maybe (fromJust, isJust)
+import Data.Maybe (fromJust, fromMaybe, isJust)
 import Data.Maybe.Strict (StrictMaybe (..), strictMaybeToMaybe)
 import Data.Set (Set)
 import qualified Data.Set as Set
@@ -63,15 +64,19 @@ import Ouroboros.Consensus.Ledger.Abstract
 import Ouroboros.Consensus.Ledger.Extended
 import Ouroboros.Consensus.Ledger.Inspect
 import Ouroboros.Consensus.Ledger.SupportsProtocol
+import Ouroboros.Consensus.Peras.SelectView
+import Ouroboros.Consensus.Peras.Weight
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( AddBlockPromise (..)
   , AddBlockResult (..)
+  , AddPerasCertPromise
   , BlockComponent (..)
   , ChainType (..)
   , LoE (..)
   )
 import Ouroboros.Consensus.Storage.ChainDB.API.Types.InvalidBlockPunishment
   ( InvalidBlockPunishment
+  , noPunishment
   )
 import qualified Ouroboros.Consensus.Storage.ChainDB.API.Types.InvalidBlockPunishment as InvalidBlockPunishment
 import Ouroboros.Consensus.Storage.ChainDB.Impl.BlockCache
@@ -83,12 +88,14 @@ import qualified Ouroboros.Consensus.Storage.ChainDB.Impl.Query as Query
 import Ouroboros.Consensus.Storage.ChainDB.Impl.Types
 import Ouroboros.Consensus.Storage.ImmutableDB (ImmutableDB)
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
-import Ouroboros.Consensus.Storage.LedgerDB
+import Ouroboros.Consensus.Storage.LedgerDB hiding (yield)
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
+import qualified Ouroboros.Consensus.Storage.PerasCertDB.API as PerasCertDB
 import Ouroboros.Consensus.Storage.VolatileDB (VolatileDB)
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util
 import Ouroboros.Consensus.Util.AnchoredFragment
+import Ouroboros.Consensus.Util.EarlyExit (exitEarly, withEarlyExit_)
 import Ouroboros.Consensus.Util.Enclose (encloseWith)
 import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.STM (WithFingerprint (..))
@@ -118,6 +125,7 @@ initialChainSelection ::
   TopLevelConfig blk ->
   StrictTVar m (WithFingerprint (InvalidBlocks blk)) ->
   LoE () ->
+  PerasWeightSnapshot blk ->
   m (ChainAndLedger m blk)
 initialChainSelection
   immutableDB
@@ -127,7 +135,8 @@ initialChainSelection
   tracer
   cfg
   varInvalid
-  loE = do
+  loE
+  weights = do
     -- TODO: Improve the user experience by trimming any potential
     -- blocks from the future from the VolatileDB.
     --
@@ -172,7 +181,7 @@ initialChainSelection
     let curChain = Empty (AF.castAnchor i)
     curChainAndLedger <- VF.newM curChain curForker
 
-    case NE.nonEmpty (filter (preferAnchoredCandidate bcfg curChain) chains) of
+    case NE.nonEmpty (filter (preferAnchoredCandidate bcfg weights curChain) chains) of
       -- If there are no candidates, no chain selection is needed
       Nothing -> return curChainAndLedger
       Just chains' ->
@@ -254,7 +263,7 @@ initialChainSelection
     chainSelection' curChainAndLedger candidates =
       atomically (forkerCurrentPoint ledger) >>= \curpt ->
         assert (all ((curpt ==) . castPoint . AF.anchorPoint) candidates) $
-          assert (all (preferAnchoredCandidate bcfg curChain) candidates) $ do
+          assert (all (preferAnchoredCandidate bcfg weights curChain) candidates) $ do
             cse <- chainSelEnv
             chainSelection cse rr (Diff.extend <$> candidates)
      where
@@ -269,6 +278,7 @@ initialChainSelection
             , bcfg
             , varInvalid
             , blockCache = BlockCache.empty
+            , weights
             , curChain
             , validationTracer = InitChainSelValidation >$< tracer
             , -- initial chain selection is not concerned about pipelining
@@ -314,6 +324,15 @@ addBlockAsync ::
 addBlockAsync CDB{cdbTracer, cdbChainSelQueue} =
   addBlockToAdd (TraceAddBlockEvent >$< cdbTracer) cdbChainSelQueue
 
+addPerasCertAsync ::
+  forall m blk.
+  (IOLike m, HasHeader blk) =>
+  ChainDbEnv m blk ->
+  ValidatedPerasCert blk ->
+  m (AddPerasCertPromise m)
+addPerasCertAsync CDB{cdbTracer, cdbChainSelQueue} =
+  addPerasCertToQueue (TraceAddPerasCertEvent >$< cdbTracer) cdbChainSelQueue
+
 -- | Schedule reprocessing of blocks postponed by the LoE.
 triggerChainSelectionAsync ::
   forall m blk.
@@ -358,14 +377,15 @@ chainSelSync ::
 -- blocks that were originally postponed by the LoE, but can be adopted once we
 -- conclude that we are caught-up (and hence are longer bound by the LoE).
 chainSelSync cdb@CDB{..} (ChainSelReprocessLoEBlocks varProcessed) = lift $ do
-  (succsOf, lookupBlockInfo, curChain) <- atomically $ do
+  (succsOf, lookupBlockInfo, curChain, weights) <- atomically $ do
     invalid <- forgetFingerprint <$> readTVar cdbInvalid
-    (,,)
+    (,,,)
       <$> ( ignoreInvalidSuc cdbVolatileDB invalid
               <$> VolatileDB.filterByPredecessor cdbVolatileDB
           )
       <*> VolatileDB.getBlockInfo cdbVolatileDB
       <*> Query.getCurrentChain cdb
+      <*> (forgetFingerprint <$> Query.getPerasWeightSnapshot cdb)
   let
     -- All immediate successor blocks of blocks on the current chain (including
     -- the anchor), excluding those on the current chain.
@@ -380,10 +400,10 @@ chainSelSync cdb@CDB{..} (ChainSelReprocessLoEBlocks varProcessed) = lift $ do
       , not $ AF.pointOnFragment (realPointToPoint loePt) curChain
       ]
 
-    chainSelEnv = mkChainSelEnv cdb BlockCache.empty curChain Nothing
+    chainSelEnv = mkChainSelEnv cdb BlockCache.empty weights curChain Nothing
 
   chainDiffs :: [[ChainDiff (Header blk)]] <-
-    for loePoints $ constructPreferableCandidates cdb curChain Map.empty
+    for loePoints $ constructPreferableCandidates cdb weights curChain Map.empty
 
   -- Consider all candidates at once, to avoid transient chain switches.
   case NE.nonEmpty $ concat chainDiffs of
@@ -392,7 +412,7 @@ chainSelSync cdb@CDB{..} (ChainSelReprocessLoEBlocks varProcessed) = lift $ do
       chainSelection chainSelEnv rr chainDiffs' >>= \case
         Just validatedChainDiff ->
           -- Switch to the new better chain.
-          switchTo cdb Nothing validatedChainDiff
+          switchTo cdb weights Nothing validatedChainDiff
         Nothing -> pure ()
     Nothing -> pure ()
 
@@ -463,6 +483,65 @@ chainSelSync cdb@CDB{..} (ChainSelAddBlock BlockToAdd{blockToAdd = b, ..}) = do
   deliverProcessed tip =
     atomically $
       putTMVar varBlockProcessed (SuccesfullyAddedBlock tip)
+-- Process a Peras certificate by adding it to the PerasCertDB and potentially
+-- performing chain selection if a candidate is now better than our selection.
+chainSelSync cdb@CDB{..} (ChainSelAddPerasCert cert varProcessed) = do
+  curChain <- lift $ atomically $ Query.getCurrentChain cdb
+  let immTip = AF.castAnchor $ AF.anchor curChain
+
+  withEarlyExit_ $ do
+    -- Ignore the certificate if it boosts a block that is so old that it can't
+    -- influence our selection.
+    when (pointSlot boostedBlock < AF.anchorToSlotNo immTip) $ do
+      lift $ lift $ traceWith tracer $ IgnorePerasCertTooOld certRound boostedBlock immTip
+      exitEarly
+
+    -- Add the certificate to the PerasCertDB.
+    lift (lift $ PerasCertDB.addCert cdbPerasCertDB cert) >>= \case
+      PerasCertDB.AddedPerasCertToDB -> pure ()
+      -- If it already is in the PerasCertDB, we are done.
+      PerasCertDB.PerasCertAlreadyInDB -> exitEarly
+
+    -- If the certificate boosts a block on our current chain (including the
+    -- anchor), then it just makes our selection even stronger.
+    when (AF.withinFragmentBounds (castPoint boostedBlock) curChain) $ do
+      lift $ lift $ traceWith tracer $ PerasCertBoostsCurrentChain certRound boostedBlock
+      exitEarly
+
+    boostedHash <- case pointHash boostedBlock of
+      -- If the certificate boosts the Genesis point, then it can not influence
+      -- chain selection as all chains contain it.
+      GenesisHash -> do
+        lift $ lift $ traceWith tracer $ PerasCertBoostsGenesis certRound
+        exitEarly
+      -- Otherwise, the certificate boosts a block potentially on a (future)
+      -- candidate.
+      BlockHash boostedHash -> pure boostedHash
+    boostedHdr <-
+      lift (lift $ VolatileDB.getBlockComponent cdbVolatileDB GetHeader boostedHash) >>= \case
+        -- If we have not (yet) received the boosted block, we don't need to do
+        -- anything further for now regarding chain selection. Once we receive
+        -- it, the additional weight of the certificate is taken into account.
+        Nothing -> do
+          lift $ lift $ traceWith tracer $ PerasCertBoostsBlockNotYetReceived certRound boostedBlock
+          exitEarly
+        Just boostedHdr -> pure boostedHdr
+
+    -- Trigger chain selection for the boosted block.
+    lift $ lift $ traceWith tracer $ ChainSelectionForBoostedBlock certRound boostedBlock
+    lift $ chainSelectionForBlock cdb BlockCache.empty boostedHdr noPunishment
+
+  -- Deliver promise indicating that we processed the cert.
+  lift $ atomically $ putTMVar varProcessed ()
+ where
+  tracer :: Tracer m (TraceAddPerasCertEvent blk)
+  tracer = TraceAddPerasCertEvent >$< cdbTracer
+
+  certRound :: PerasRoundNo
+  certRound = getPerasCertRound cert
+
+  boostedBlock :: Point blk
+  boostedBlock = getPerasCertBoostedBlock cert
 
 -- | Return 'True' when the given header should be ignored when adding it
 -- because it is too old, i.e., we wouldn't be able to switch to a chain
@@ -539,11 +618,12 @@ chainSelectionForBlock ::
   InvalidBlockPunishment m ->
   Electric m ()
 chainSelectionForBlock cdb@CDB{..} blockCache hdr punish = electric $ withRegistry $ \rr -> do
-  (invalid, curChain) <-
+  (invalid, curChain, weights) <-
     atomically $
-      (,)
+      (,,)
         <$> (forgetFingerprint <$> readTVar cdbInvalid)
         <*> Query.getCurrentChain cdb
+        <*> (forgetFingerprint <$> Query.getPerasWeightSnapshot cdb)
 
   -- The current chain we're working with here is not longer than @k@ blocks
   -- (see 'getCurrentChain' and 'cdbChain'), which is easier to reason about
@@ -576,13 +656,14 @@ chainSelectionForBlock cdb@CDB{..} blockCache hdr punish = electric $ withRegist
         chainDiffs <-
           constructPreferableCandidates
             cdb
+            weights
             curChain
             (Map.singleton (headerHash hdr) hdr)
             (headerRealPoint hdr)
 
         let noChange = traceWith addBlockTracer $ StoreButDontChange p
 
-            chainSelEnv = mkChainSelEnv cdb blockCache curChain (Just (p, punish))
+            chainSelEnv = mkChainSelEnv cdb blockCache weights curChain (Just (p, punish))
 
         case NE.nonEmpty chainDiffs of
           Just chainDiffs' -> do
@@ -590,7 +671,7 @@ chainSelectionForBlock cdb@CDB{..} blockCache hdr punish = electric $ withRegist
             chainSelection chainSelEnv rr chainDiffs' >>= \case
               Just validatedChainDiff ->
                 -- Switch to the new better chain.
-                switchTo cdb (Just p) validatedChainDiff
+                switchTo cdb weights (Just p) validatedChainDiff
               -- No valid candidate better than our chain.
               Nothing -> noChange
           -- No candidate better than our chain.
@@ -617,6 +698,7 @@ constructPreferableCandidates ::
   , BlockSupportsProtocol blk
   ) =>
   ChainDbEnv m blk ->
+  PerasWeightSnapshot blk ->
   -- | The current chain.
   AnchoredFragment (Header blk) ->
   -- | Headers already in memory (to avoid loading them from disk).
@@ -626,7 +708,7 @@ constructPreferableCandidates ::
   -- | All candidates involving @p@ (ie containing @p@ in 'getSuffix') which are
   -- preferable to the current chain.
   m [ChainDiff (Header blk)]
-constructPreferableCandidates CDB{..} curChain hdrCache p = do
+constructPreferableCandidates CDB{..} weights curChain hdrCache p = do
   (succsOf, lookupBlockInfo) <- atomically $ do
     invalid <- forgetFingerprint <$> readTVar cdbInvalid
     (,)
@@ -666,10 +748,10 @@ constructPreferableCandidates CDB{..} curChain hdrCache p = do
             -- Translate the 'HeaderFields' to 'Header' by reading the headers
             -- from disk.
             mapM translateToHeaders
-              -- Filter out candidates that are shorter than the current chain.
-              -- We don't want to needlessly read the headers from disk for
-              -- those candidates.
-              . NE.filter (not . Diff.rollbackExceedsSuffix)
+              -- Filter out candidates that have less weight than the current
+              -- chain. We don't want to needlessly read the headers from disk
+              -- for those candidates.
+              . NE.filter (not . Diff.rollbackExceedsSuffix weights curChain)
               -- Extend the diff with candidates fitting on @p@
               . Paths.extendWithSuccessors succsOf lookupBlockInfo
               $ diff
@@ -677,7 +759,7 @@ constructPreferableCandidates CDB{..} curChain hdrCache p = do
         | otherwise -> pure []
   pure
     -- Only keep candidates preferable to the current chain.
-    . filter (preferAnchoredCandidate bcfg curChain . Diff.getSuffix)
+    . filter (preferAnchoredCandidate bcfg weights curChain . Diff.getSuffix)
     -- Trim fragments so that they follow the LoE, that is, they extend the LoE
     -- by at most @k@ blocks or are extended by the LoE.
     . fmap (trimToLoE loeFrag)
@@ -792,6 +874,7 @@ switchTo ::
   , HasCallStack
   ) =>
   ChainDbEnv m blk ->
+  PerasWeightSnapshot blk ->
   -- | Which block we performed chain selection for (if any). This is 'Nothing'
   -- when reprocessing blocks that were postponed due to the Limit on Eagerness
   -- (cf 'ChainSelReprocessLoEBlocks').
@@ -799,7 +882,7 @@ switchTo ::
   -- | Chain and ledger to switch to
   ValidatedChainDiff (Header blk) (Forker' m blk) ->
   m ()
-switchTo CDB{..} triggerPt vChainDiff = do
+switchTo CDB{..} weights triggerPt vChainDiff = do
   traceWith addBlockTracer $
     ChangingSelection $
       castPoint $
@@ -860,7 +943,11 @@ switchTo CDB{..} triggerPt vChainDiff = do
   let mkTraceEvent
         | getRollback (getChainDiff vChainDiff) == 0 = AddedToCurrentChain
         | otherwise = SwitchedToAFork
-      selChangedInfo = mkSelectionChangedInfo curChain newChain newLedger
+      selChangedInfo =
+        mkSelectionChangedInfo
+          curChain
+          (getChainDiff vChainDiff)
+          newLedger
   traceWith addBlockTracer $
     mkTraceEvent events selChangedInfo curChain newChain
   whenJust (strictMaybeToMaybe prevTentativeHeader) $
@@ -875,28 +962,29 @@ switchTo CDB{..} triggerPt vChainDiff = do
   addBlockTracer = TraceAddBlockEvent >$< cdbTracer
 
   mkSelectionChangedInfo ::
-    AnchoredFragment (Header blk) ->
-    -- \^ old chain
-    AnchoredFragment (Header blk) ->
-    -- \^ new chain
-    ExtLedgerState blk EmptyMK ->
-    -- \^ new tip
+    AnchoredFragment (Header blk) -> -- old selection
+    ChainDiff (Header blk) -> -- diff we are adopting
+    ExtLedgerState blk EmptyMK -> -- new tip
     SelectionChangedInfo blk
-  mkSelectionChangedInfo oldChain newChain newTip =
+  mkSelectionChangedInfo oldChain diff newTip =
     SelectionChangedInfo
       { newTipPoint = castRealPoint tipPoint
       , newTipEpoch = tipEpoch
       , newTipSlotInEpoch = tipSlotInEpoch
       , newTipTrigger = triggerPt
-      , newTipSelectView
-      , oldTipSelectView =
-          selectView (configBlock cfg)
-            <$> eitherToMaybe (AF.head oldChain)
+      , newSuffixSelectView
+      , oldSuffixSelectView =
+          withEmptyFragmentToMaybe $
+            weightedSelectView (configBlock cfg) weights oldSuffix
       }
    where
     cfg :: TopLevelConfig blk
     cfg = cdbTopLevelConfig
 
+    oldSuffix, newSuffix :: AnchoredFragment (Header blk)
+    oldSuffix = AF.anchorNewest (getRollback diff) oldChain
+    newSuffix = getSuffix diff
+
     ledger :: LedgerState blk EmptyMK
     ledger = ledgerState newTip
 
@@ -906,14 +994,13 @@ switchTo CDB{..} triggerPt vChainDiff = do
         (configLedger cfg)
         ledger
 
-    (tipPoint, (tipEpoch, tipSlotInEpoch), newTipSelectView) =
-      case AF.head newChain of
-        Left _anchor -> error "cannot have switched to an empty chain"
-        Right tipHdr ->
+    (tipPoint, (tipEpoch, tipSlotInEpoch), newSuffixSelectView) =
+      case (AF.head newSuffix, weightedSelectView (configBlock cfg) weights newSuffix) of
+        (Right tipHdr, NonEmptyFragment wsv) ->
           let query = History.slotToEpoch' (blockSlot tipHdr)
               tipEpochData = History.runQueryPure query summary
-              sv = selectView (configBlock cfg) tipHdr
-           in (blockRealPoint tipHdr, tipEpochData, sv)
+           in (blockRealPoint tipHdr, tipEpochData, wsv)
+        _ -> error "cannot have switched via a diff with an empty suffix"
 
 -- | Check whether the header for the hash is in the cache, if not, get
 -- the corresponding header from the VolatileDB and store it in the cache.
@@ -943,6 +1030,7 @@ data ChainSelEnv m blk = ChainSelEnv
   , varTentativeHeader :: StrictTVar m (StrictMaybe (Header blk))
   , getTentativeFollowers :: STM m [FollowerHandle m blk]
   , blockCache :: BlockCache blk
+  , weights :: PerasWeightSnapshot blk
   , curChain :: AnchoredFragment (Header blk)
   , punish :: Maybe (RealPoint blk, InvalidBlockPunishment m)
   -- ^ The block that this chain selection invocation is processing, and the
@@ -968,12 +1056,14 @@ mkChainSelEnv ::
   ChainDbEnv m blk ->
   -- | See 'blockCache'
   BlockCache blk ->
+  -- | See 'weights'
+  PerasWeightSnapshot blk ->
   -- | See 'curChain'
   AnchoredFragment (Header blk) ->
   -- | See 'punish'.
   Maybe (RealPoint blk, InvalidBlockPunishment m) ->
   ChainSelEnv m blk
-mkChainSelEnv CDB{..} blockCache curChain punish =
+mkChainSelEnv CDB{..} blockCache weights curChain punish =
   ChainSelEnv
     { lgrDB = cdbLedgerDB
     , bcfg = configBlock cdbTopLevelConfig
@@ -984,6 +1074,7 @@ mkChainSelEnv CDB{..} blockCache curChain punish =
         filter ((TentativeChain ==) . fhChainType) . Map.elems
           <$> readTVar cdbFollowers
     , blockCache
+    , weights
     , curChain
     , validationTracer =
         TraceAddBlockEvent . AddBlockValidation >$< cdbTracer
@@ -1017,7 +1108,7 @@ chainSelection ::
 chainSelection chainSelEnv rr chainDiffs =
   assert
     ( all
-        (preferAnchoredCandidate bcfg curChain . Diff.getSuffix)
+        (preferAnchoredCandidate bcfg weights curChain . Diff.getSuffix)
         chainDiffs
     )
     $ assert
@@ -1030,8 +1121,7 @@ chainSelection chainSelEnv rr chainDiffs =
   ChainSelEnv{..} = chainSelEnv
 
   sortCandidates :: [ChainDiff (Header blk)] -> [ChainDiff (Header blk)]
-  sortCandidates =
-    sortBy (flip (compareAnchoredFragments bcfg) `on` Diff.getSuffix)
+  sortCandidates = sortBy (flip $ compareChainDiffs bcfg weights curChain)
 
   -- 1. Take the first candidate from the list of sorted candidates
   -- 2. Validate it
@@ -1067,7 +1157,7 @@ chainSelection chainSelEnv rr chainDiffs =
         -- it will be dropped here, as it will not be preferred over the
         -- current chain.
         let candidates2
-              | preferAnchoredCandidate bcfg curChain (Diff.getSuffix candidate') =
+              | preferAnchoredCandidate bcfg weights curChain (Diff.getSuffix candidate') =
                   candidate' : candidates1
               | otherwise =
                   candidates1
@@ -1125,7 +1215,7 @@ chainSelection chainSelEnv rr chainDiffs =
     let isRejected hdr =
           Map.member (headerHash hdr) (forgetFingerprint invalid)
     return $
-      filter (preferAnchoredCandidate bcfg curChain . Diff.getSuffix) $
+      filter (preferAnchoredCandidate bcfg weights curChain . Diff.getSuffix) $
         map (Diff.takeWhileOldest (not . isRejected)) cands
 
 -- [Ouroboros]
@@ -1333,3 +1423,26 @@ ignoreInvalidSuc ::
   (ChainHash blk -> Set (HeaderHash blk))
 ignoreInvalidSuc _ invalid succsOf =
   Set.filter (`Map.notMember` invalid) . succsOf
+
+-- | Compare two 'ChainDiff's w.r.t. the chain order.
+--
+-- PRECONDITION: Both 'ChainDiff's fit onto the given current chain.
+compareChainDiffs ::
+  forall blk.
+  BlockSupportsProtocol blk =>
+  BlockConfig blk ->
+  PerasWeightSnapshot blk ->
+  -- | Current chain.
+  AnchoredFragment (Header blk) ->
+  ChainDiff (Header blk) ->
+  ChainDiff (Header blk) ->
+  Ordering
+compareChainDiffs bcfg weights curChain =
+  -- The precondition of 'compareAnchoredFragment's is satisfied as the result
+  -- of @mkCand@ has the same anchor as @curChain@, and so any two fragments
+  -- returned by @mkCand@ do intersect.
+  compareAnchoredFragments bcfg weights `on` mkCand
+ where
+  mkCand =
+    fromMaybe (error "compareChainDiffs: precondition violated")
+      . Diff.apply curChain
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Query.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Query.hs
index 821586f74..1dbd00c53 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Query.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Query.hs
@@ -3,6 +3,7 @@
 {-# LANGUAGE MultiWayIf #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeOperators #-}
 
 -- | Queries
 module Ouroboros.Consensus.Storage.ChainDB.Impl.Query
@@ -18,6 +19,8 @@ module Ouroboros.Consensus.Storage.ChainDB.Impl.Query
   , getIsValid
   , getMaxSlotNo
   , getPastLedger
+  , getPerasWeightSnapshot
+  , getPerasCertSnapshot
   , getReadOnlyForkerAtPoint
   , getStatistics
   , getTipBlock
@@ -31,7 +34,6 @@ module Ouroboros.Consensus.Storage.ChainDB.Impl.Query
   , getChainSelStarvation
   ) where
 
-import Cardano.Ledger.BaseTypes (unNonZero)
 import Control.ResourceRegistry (ResourceRegistry)
 import qualified Data.Map.Strict as Map
 import qualified Data.Set as Set
@@ -43,6 +45,10 @@ import Ouroboros.Consensus.HeaderStateHistory
 import Ouroboros.Consensus.HeaderValidation (HeaderWithTime)
 import Ouroboros.Consensus.Ledger.Abstract (EmptyMK)
 import Ouroboros.Consensus.Ledger.Extended
+import Ouroboros.Consensus.Peras.Weight
+  ( PerasWeightSnapshot
+  , takeVolatileSuffix
+  )
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( BlockComponent (..)
@@ -52,6 +58,8 @@ import Ouroboros.Consensus.Storage.ChainDB.Impl.Types
 import Ouroboros.Consensus.Storage.ImmutableDB (ImmutableDB)
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
+import Ouroboros.Consensus.Storage.PerasCertDB.API (PerasCertSnapshot)
 import Ouroboros.Consensus.Storage.VolatileDB (VolatileDB)
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util (eitherToMaybe)
@@ -67,45 +75,63 @@ import Ouroboros.Network.Protocol.LocalStateQuery.Type
 
 -- | Return the last @k@ headers.
 --
--- While the in-memory fragment ('cdbChain') might temporarily be longer than
--- @k@ (until the background thread has copied those blocks to the
--- ImmutableDB), this function will never return a fragment longer than @k@.
+-- While the in-memory fragment ('cdbChain') might temporarily have more weight
+-- than @k@ (until the background thread has copied those blocks to the
+-- ImmutableDB), this function will never return a fragment heavier than @k@.
 --
 -- The anchor point of the returned fragment will be the most recent
 -- \"immutable\" block, i.e. a block that cannot be rolled back. In
 -- ChainDB.md, we call this block @i@.
 --
--- Note that the returned fragment may be shorter than @k@ in case the whole
--- chain itself is shorter than @k@ or in case the VolatileDB was corrupted.
--- In the latter case, we don't take blocks already in the ImmutableDB into
--- account, as we know they /must/ have been \"immutable\" at some point, and,
--- therefore, /must/ still be \"immutable\".
+-- Note that the returned fragment may have weight less than @k@ in case the
+-- whole chain itself weights less than @k@, or in case the VolatileDB was
+-- corrupted. In the latter case, we don't take blocks already in the
+-- ImmutableDB into account, as we know they /must/ have been \"immutable\" at
+-- some point, and, therefore, /must/ still be \"immutable\".
 getCurrentChain ::
   forall m blk.
   ( IOLike m
+  , StandardHash blk
   , HasHeader (Header blk)
   , ConsensusProtocol (BlockProtocol blk)
   ) =>
   ChainDbEnv m blk ->
   STM m (AnchoredFragment (Header blk))
-getCurrentChain CDB{..} =
-  AF.anchorNewest (unNonZero k) . icWithoutTime <$> readTVar cdbChain
- where
-  SecurityParam k = configSecurityParam cdbTopLevelConfig
+getCurrentChain cdb@CDB{..} =
+  getCurrentChainLike cdb $ icWithoutTime <$> readTVar cdbChain
 
 -- | Same as 'getCurrentChain', /mutatis mutandi/.
 getCurrentChainWithTime ::
   forall m blk.
   ( IOLike m
+  , StandardHash blk
   , HasHeader (HeaderWithTime blk)
   , ConsensusProtocol (BlockProtocol blk)
   ) =>
   ChainDbEnv m blk ->
   STM m (AnchoredFragment (HeaderWithTime blk))
-getCurrentChainWithTime CDB{..} =
-  AF.anchorNewest (unNonZero k) . icWithTime <$> readTVar cdbChain
+getCurrentChainWithTime cdb@CDB{..} =
+  getCurrentChainLike cdb $ icWithTime <$> readTVar cdbChain
+
+-- | This function is the generalised helper for 'getCurrentChain' and
+-- 'getCurrentChainWithTime'. See 'getCurrentChain' for the explanation of it's
+-- behaviour.
+getCurrentChainLike ::
+  forall m blk h.
+  ( IOLike m
+  , StandardHash blk
+  , HasHeader h
+  , HeaderHash blk ~ HeaderHash h
+  , ConsensusProtocol (BlockProtocol blk)
+  ) =>
+  ChainDbEnv m blk ->
+  STM m (AnchoredFragment h) ->
+  STM m (AnchoredFragment h)
+getCurrentChainLike cdb@CDB{..} getCurChain = do
+  weights <- forgetFingerprint <$> getPerasWeightSnapshot cdb
+  takeVolatileSuffix weights k <$> getCurChain
  where
-  SecurityParam k = configSecurityParam cdbTopLevelConfig
+  k = configSecurityParam cdbTopLevelConfig
 
 -- | Get a 'HeaderStateHistory' populated with the 'HeaderState's of the
 -- last @k@ blocks of the current chain.
@@ -262,6 +288,14 @@ getReadOnlyForkerAtPoint CDB{..} = LedgerDB.getReadOnlyForker cdbLedgerDB
 getStatistics :: IOLike m => ChainDbEnv m blk -> m (Maybe LedgerDB.Statistics)
 getStatistics CDB{..} = LedgerDB.getTipStatistics cdbLedgerDB
 
+getPerasWeightSnapshot ::
+  ChainDbEnv m blk -> STM m (WithFingerprint (PerasWeightSnapshot blk))
+getPerasWeightSnapshot CDB{..} = PerasCertDB.getWeightSnapshot cdbPerasCertDB
+
+getPerasCertSnapshot ::
+  ChainDbEnv m blk -> STM m (PerasCertSnapshot blk)
+getPerasCertSnapshot CDB{..} = PerasCertDB.getCertSnapshot cdbPerasCertDB
+
 {-------------------------------------------------------------------------------
   Unifying interface over the immutable DB and volatile DB, but independent
   of the ledger DB. These functions therefore do not require the entire
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Types.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Types.hs
index 30193ba31..3336ba527 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Types.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/ChainDB/Impl/Types.hs
@@ -55,6 +55,7 @@ module Ouroboros.Consensus.Storage.ChainDB.Impl.Types
   , ChainSelMessage (..)
   , ChainSelQueue -- opaque
   , addBlockToAdd
+  , addPerasCertToQueue
   , addReprocessLoEBlocks
   , closeChainSelQueue
   , getChainSelMessage
@@ -66,6 +67,7 @@ module Ouroboros.Consensus.Storage.ChainDB.Impl.Types
     -- * Trace types
   , SelectionChangedInfo (..)
   , TraceAddBlockEvent (..)
+  , TraceAddPerasCertEvent (..)
   , TraceChainSelStarvationEvent (..)
   , TraceCopyToImmutableDBEvent (..)
   , TraceEvent (..)
@@ -83,7 +85,6 @@ import Control.ResourceRegistry
 import Control.Tracer
 import Data.Foldable (traverse_)
 import Data.Map.Strict (Map)
-import Data.Maybe (mapMaybe)
 import Data.Maybe.Strict (StrictMaybe (..))
 import Data.MultiSet (MultiSet)
 import qualified Data.MultiSet as MultiSet
@@ -99,10 +100,12 @@ import Ouroboros.Consensus.HeaderValidation (HeaderWithTime (..))
 import Ouroboros.Consensus.Ledger.Extended (ExtValidationError)
 import Ouroboros.Consensus.Ledger.Inspect
 import Ouroboros.Consensus.Ledger.SupportsProtocol
+import Ouroboros.Consensus.Peras.SelectView (WeightedSelectView)
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( AddBlockPromise (..)
   , AddBlockResult (..)
+  , AddPerasCertPromise (..)
   , ChainDbError (..)
   , ChainSelectionPromise (..)
   , ChainType
@@ -124,6 +127,8 @@ import Ouroboros.Consensus.Storage.LedgerDB
   , LedgerDbSerialiseConstraints
   )
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
+import Ouroboros.Consensus.Storage.PerasCertDB (PerasCertDB)
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
 import Ouroboros.Consensus.Storage.Serialisation
 import Ouroboros.Consensus.Storage.VolatileDB
   ( VolatileDB
@@ -136,7 +141,7 @@ import Ouroboros.Consensus.Util.Enclose (Enclosing, Enclosing' (..))
 import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.Orphans ()
 import Ouroboros.Consensus.Util.STM (WithFingerprint)
-import Ouroboros.Network.AnchoredFragment (AnchoredFragment)
+import Ouroboros.Network.AnchoredFragment (Anchor, AnchoredFragment)
 import qualified Ouroboros.Network.AnchoredFragment as AF
 import Ouroboros.Network.Block (MaxSlotNo (..))
 import Ouroboros.Network.BlockFetch.ConsensusInterface
@@ -349,6 +354,7 @@ data ChainDbEnv m blk = CDB
   , cdbChainSelStarvation :: !(StrictTVar m ChainSelStarvation)
   -- ^ Information on the last starvation of ChainSel, whether ongoing or
   -- ended recently.
+  , cdbPerasCertDB :: !(PerasCertDB m blk)
   }
   deriving Generic
 
@@ -545,6 +551,11 @@ data BlockToAdd m blk = BlockToAdd
 data ChainSelMessage m blk
   = -- | Add a new block
     ChainSelAddBlock !(BlockToAdd m blk)
+  | -- | Add a Peras certificate
+    ChainSelAddPerasCert
+      !(ValidatedPerasCert blk)
+      -- | Used for 'AddPerasCertPromise'.
+      !(StrictTMVar m ())
   | -- | Reprocess blocks that have been postponed by the LoE.
     ChainSelReprocessLoEBlocks
       -- | Used for 'ChainSelectionPromise'.
@@ -593,6 +604,27 @@ addBlockToAdd tracer (ChainSelQueue{varChainSelQueue, varChainSelPoints}) punish
       , blockProcessed = readTMVar varBlockProcessed
       }
 
+-- | Add a Peras certificate to the background queue.
+addPerasCertToQueue ::
+  (IOLike m, StandardHash blk) =>
+  Tracer m (TraceAddPerasCertEvent blk) ->
+  ChainSelQueue m blk ->
+  ValidatedPerasCert blk ->
+  m (AddPerasCertPromise m)
+addPerasCertToQueue tracer ChainSelQueue{varChainSelQueue} cert = do
+  varProcessed <- newEmptyTMVarIO
+  traceWith tracer $ addedToQueue RisingEdge
+  queueSize <- atomically $ do
+    writeTBQueue varChainSelQueue $ ChainSelAddPerasCert cert varProcessed
+    lengthTBQueue varChainSelQueue
+  traceWith tracer $ addedToQueue $ FallingEdgeWith $ fromIntegral queueSize
+  pure
+    AddPerasCertPromise
+      { waitPerasCertProcessed = atomically $ readTMVar varProcessed
+      }
+ where
+  addedToQueue = AddedPerasCertToQueue (getPerasCertRound cert) (getPerasCertBoostedBlock cert)
+
 -- | Try to add blocks again that were postponed due to the LoE.
 addReprocessLoEBlocks ::
   IOLike m =>
@@ -647,23 +679,21 @@ getChainSelMessage starvationTracer starvationVar chainSelQueue =
       let pt = blockRealPoint block
       traceWith starvationTracer $ ChainSelStarvation (FallingEdgeWith pt)
       atomically . writeTVar starvationVar . ChainSelStarvationEndedAt =<< getMonotonicTime
+    ChainSelAddPerasCert{} -> pure ()
     ChainSelReprocessLoEBlocks{} -> pure ()
 
 -- | Flush the 'ChainSelQueue' queue and notify the waiting threads.
 closeChainSelQueue :: IOLike m => ChainSelQueue m blk -> STM m ()
 closeChainSelQueue ChainSelQueue{varChainSelQueue = queue} = do
-  as <- mapMaybe blockAdd <$> flushTBQueue queue
-  traverse_
-    ( \a ->
-        tryPutTMVar
-          (varBlockProcessed a)
-          (FailedToAddBlock "Queue flushed")
-    )
-    as
+  traverse_ deliverPromise =<< flushTBQueue queue
  where
-  blockAdd = \case
-    ChainSelAddBlock ab -> Just ab
-    ChainSelReprocessLoEBlocks _ -> Nothing
+  deliverPromise = \case
+    ChainSelAddBlock ab ->
+      tryPutTMVar (varBlockProcessed ab) (FailedToAddBlock "Queue flushed")
+    ChainSelAddPerasCert _cert varProcessed ->
+      tryPutTMVar varProcessed ()
+    ChainSelReprocessLoEBlocks varProcessed ->
+      tryPutTMVar varProcessed ()
 
 -- | To invoke when the given 'ChainSelMessage' has been processed by ChainSel.
 -- This is used to remove the respective point from the multiset of points in
@@ -676,6 +706,8 @@ processedChainSelMessage ::
 processedChainSelMessage ChainSelQueue{varChainSelPoints} = \case
   ChainSelAddBlock BlockToAdd{blockToAdd = blk} ->
     modifyTVar varChainSelPoints $ MultiSet.delete (blockRealPoint blk)
+  ChainSelAddPerasCert{} ->
+    pure ()
   ChainSelReprocessLoEBlocks{} ->
     pure ()
 
@@ -717,16 +749,12 @@ data TraceEvent blk
   | TraceLedgerDBEvent (LedgerDB.TraceEvent blk)
   | TraceImmutableDBEvent (ImmutableDB.TraceEvent blk)
   | TraceVolatileDBEvent (VolatileDB.TraceEvent blk)
+  | TracePerasCertDbEvent (PerasCertDB.TraceEvent blk)
   | TraceLastShutdownUnclean
   | TraceChainSelStarvationEvent (TraceChainSelStarvationEvent blk)
+  | TraceAddPerasCertEvent (TraceAddPerasCertEvent blk)
   deriving Generic
 
-deriving instance
-  ( Eq (Header blk)
-  , LedgerSupportsProtocol blk
-  , InspectLedger blk
-  ) =>
-  Eq (TraceEvent blk)
 deriving instance
   ( Show (Header blk)
   , LedgerSupportsProtocol blk
@@ -797,21 +825,23 @@ data SelectionChangedInfo blk = SelectionChangedInfo
   -- Due to the Ouroboros Genesis (Limit on Eagerness), chain selection can also
   -- be triggered without any particular trigger block, in which case this is
   -- 'Nothing'.
-  , newTipSelectView :: SelectView (BlockProtocol blk)
-  -- ^ The 'SelectView' of the new tip. It is guaranteed that
+  , newSuffixSelectView :: WeightedSelectView (BlockProtocol blk)
+  -- ^ The 'WeightedSelectView' of the suffix of our new selection that was not
+  -- already present in the old selection. It is guaranteed that
   --
-  -- > Just newTipSelectView > oldTipSelectView
-  -- True
-  , oldTipSelectView :: Maybe (SelectView (BlockProtocol blk))
-  -- ^ The 'SelectView' of the old, previous tip. This can be 'Nothing' when
-  -- the previous chain/tip was Genesis.
+  -- > preferCandidate cfg
+  -- >   (withEmptyFragmentFromMaybe oldSuffixSelectView)
+  -- >   newSuffixSelectView
+  , oldSuffixSelectView :: Maybe (WeightedSelectView (BlockProtocol blk))
+  -- ^ The 'WeightedSelectView' of the orphaned suffix of our old selection.
+  -- This is 'Nothing' when we extended our selection.
   }
   deriving Generic
 
 deriving stock instance
-  (Show (SelectView (BlockProtocol blk)), StandardHash blk) => Show (SelectionChangedInfo blk)
+  (Show (TiebreakerView (BlockProtocol blk)), StandardHash blk) => Show (SelectionChangedInfo blk)
 deriving stock instance
-  (Eq (SelectView (BlockProtocol blk)), StandardHash blk) => Eq (SelectionChangedInfo blk)
+  (Eq (TiebreakerView (BlockProtocol blk)), StandardHash blk) => Eq (SelectionChangedInfo blk)
 
 -- | Trace type for the various events that occur when adding a block.
 data TraceAddBlockEvent blk
@@ -1027,3 +1057,26 @@ data TraceIteratorEvent blk
 newtype TraceChainSelStarvationEvent blk
   = ChainSelStarvation (Enclosing' (RealPoint blk))
   deriving (Generic, Eq, Show)
+
+data TraceAddPerasCertEvent blk
+  = -- | The Peras certificate from the given round boosting the given block was
+    -- added to the queue. The size of the queue is included.
+    AddedPerasCertToQueue PerasRoundNo (Point blk) (Enclosing' Word)
+  | -- | The Peras certificate from the given round boosting the given block was
+    -- popped from the queue.
+    PoppedPerasCertFromQueue PerasRoundNo (Point blk)
+  | -- | The Peras certificate from the given round boosting the given block was
+    -- too old, ie its slot was older than the current immutable slot (the third
+    -- argument).
+    IgnorePerasCertTooOld PerasRoundNo (Point blk) (Anchor blk)
+  | -- | The Peras certificate from the given round boosts a block on the
+    -- current selection.
+    PerasCertBoostsCurrentChain PerasRoundNo (Point blk)
+  | -- | The Peras certificate from the given round boosts the Genesis point.
+    PerasCertBoostsGenesis PerasRoundNo
+  | -- | The Peras certificate from the given round boosts a block that we have
+    -- not (yet) received.
+    PerasCertBoostsBlockNotYetReceived PerasRoundNo (Point blk)
+  | -- | Perform chain selection for a block boosted by a Peras certificate.
+    ChainSelectionForBoostedBlock PerasRoundNo (Point blk)
+  deriving (Generic, Eq, Show)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB.hs
index 0d1380d50..cb01fe8a8 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB.hs
@@ -1,9 +1,7 @@
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE KindSignatures #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeApplications #-}
 
 module Ouroboros.Consensus.Storage.LedgerDB
   ( -- * API
@@ -18,10 +16,11 @@ module Ouroboros.Consensus.Storage.LedgerDB
   ) where
 
 import Data.Functor.Contravariant ((>$<))
-import Data.Void
 import Data.Word
 import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.HardFork.Abstract
+import Ouroboros.Consensus.Ledger.Extended
 import Ouroboros.Consensus.Ledger.Inspect
 import Ouroboros.Consensus.Ledger.SupportsProtocol
 import Ouroboros.Consensus.Storage.ImmutableDB.Stream
@@ -33,8 +32,7 @@ import Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1 as V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots as V1
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V2 as V2
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as InMemory
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
 import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.CallStack
 import Ouroboros.Consensus.Util.IOLike
@@ -69,29 +67,35 @@ openDB
   stream
   replayGoal
   getBlock
-  getVolatileSuffix = case lgrFlavorArgs args of
-    LedgerDbFlavorArgsV1 bss ->
-      let snapManager = V1.snapshotManager args
-          initDb =
-            V1.mkInitDb
-              args
-              bss
-              getBlock
-              snapManager
-              getVolatileSuffix
-       in doOpenDB args initDb snapManager stream replayGoal
-    LedgerDbFlavorArgsV2 bss -> do
-      (snapManager, bss') <- case bss of
-        V2.V2Args V2.InMemoryHandleArgs -> pure (InMemory.snapshotManager args, V2.InMemoryHandleEnv)
-        V2.V2Args (V2.LSMHandleArgs (V2.LSMArgs x)) -> absurd x
-      let initDb =
-            V2.mkInitDb
-              args
-              bss'
-              getBlock
-              snapManager
-              getVolatileSuffix
-      doOpenDB args initDb snapManager stream replayGoal
+  getVolatileSuffix =
+    case lgrBackendArgs args of
+      LedgerDbBackendArgsV1 bss ->
+        let snapManager = V1.snapshotManager args
+            initDb =
+              V1.mkInitDb
+                args
+                bss
+                getBlock
+                snapManager
+                getVolatileSuffix
+         in doOpenDB args initDb snapManager stream replayGoal
+      LedgerDbBackendArgsV2 (SomeBackendArgs bArgs) -> do
+        res <-
+          mkResources
+            (Proxy @blk)
+            (LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV2 >$< lgrTracer args)
+            bArgs
+            (lgrRegistry args)
+            (lgrHasFS args)
+        let snapManager =
+              snapshotManager
+                (Proxy @blk)
+                res
+                (configCodec . getExtLedgerCfg . ledgerDbCfg $ lgrConfig args)
+                (LedgerDBSnapshotEvent >$< lgrTracer args)
+                (lgrHasFS args)
+        let initDb = V2.mkInitDb args getBlock snapManager getVolatileSuffix res
+        doOpenDB args initDb snapManager stream replayGoal
 
 {-------------------------------------------------------------------------------
   Opening a LedgerDB
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/API.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/API.hs
index 96d3930c7..cc26e2f18 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/API.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/API.hs
@@ -6,12 +6,8 @@
 {-# LANGUAGE DerivingVia #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
 {-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE PolyKinds #-}
-{-# LANGUAGE QuantifiedConstraints #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
@@ -154,22 +150,32 @@ module Ouroboros.Consensus.Storage.LedgerDB.API
     -- * Snapshots
   , SnapCounters (..)
 
+    -- * Streaming
+  , StreamingBackend (..)
+  , Yield
+  , Sink
+  , Decoders (..)
+
     -- * Testing
   , TestInternals (..)
   , TestInternals'
   , WhereToTakeSnapshot (..)
   ) where
 
+import Codec.CBOR.Decoding
+import Codec.CBOR.Read
 import Codec.Serialise
 import qualified Control.Monad as Monad
 import Control.Monad.Class.MonadTime.SI
 import Control.Monad.Except
 import Control.ResourceRegistry
 import Control.Tracer
+import Data.ByteString (ByteString)
 import Data.Functor.Contravariant ((>$<))
 import Data.Kind
 import qualified Data.Map.Strict as Map
 import Data.MemPack
+import Data.Proxy
 import Data.Set (Set)
 import Data.Void (absurd)
 import Data.Word
@@ -195,6 +201,8 @@ import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Consensus.Util.IndexedMemPack
 import Ouroboros.Network.Block
 import Ouroboros.Network.Protocol.LocalStateQuery.Type
+import Streaming
+import System.FS.CRC
 
 {-------------------------------------------------------------------------------
   Main API
@@ -304,7 +312,7 @@ data WhereToTakeSnapshot = TakeAtImmutableTip | TakeAtVolatileTip deriving Eq
 data TestInternals m l blk = TestInternals
   { wipeLedgerDB :: m ()
   , takeSnapshotNOW :: WhereToTakeSnapshot -> Maybe String -> m ()
-  , push :: ExtLedgerState blk DiffMK -> m ()
+  , push :: l DiffMK -> m ()
   -- ^ Push a ledger state, and prune the 'LedgerDB' to its immutable tip.
   --
   -- This does not modify the set of previously applied points.
@@ -728,12 +736,6 @@ data TraceReplayProgressEvent blk
   Updating ledger tables
 -------------------------------------------------------------------------------}
 
-type LedgerSupportsInMemoryLedgerDB l =
-  (CanUpgradeLedgerTables l, SerializeTablesWithHint l)
-
-type LedgerSupportsV1LedgerDB l =
-  (LedgerSupportsInMemoryLedgerDB l, LedgerSupportsLMDBLedgerDB l)
-
 -- | When pushing differences on InMemory Ledger DBs, we will sometimes need to
 -- update ledger tables to the latest era. For unary blocks this is a no-op, but
 -- for the Cardano block, we will need to upgrade all TxOuts in memory.
@@ -768,20 +770,26 @@ instance
     LedgerTables (ValuesMK (Map.map absurd mk))
 
 {-------------------------------------------------------------------------------
-  Supporting On-Disk backing stores
+  LedgerDB constraints
 -------------------------------------------------------------------------------}
 
+type LedgerSupportsInMemoryLedgerDB l =
+  (CanUpgradeLedgerTables l, SerializeTablesWithHint l)
+
 type LedgerSupportsLMDBLedgerDB l =
   (IndexedMemPack (l EmptyMK) (TxOut l), MemPackIdx l EmptyMK ~ l EmptyMK)
 
+type LedgerSupportsV1LedgerDB l =
+  (LedgerSupportsInMemoryLedgerDB l, LedgerSupportsLMDBLedgerDB l)
+
 type LedgerSupportsV2LedgerDB l =
-  (LedgerSupportsInMemoryLedgerDB l)
+  (LedgerSupportsInMemoryLedgerDB l, MemPack (TxIn l))
 
 type LedgerSupportsLedgerDB blk = LedgerSupportsLedgerDB' (LedgerState blk) blk
 
 type LedgerSupportsLedgerDB' l blk =
-  ( LedgerSupportsLMDBLedgerDB l
-  , LedgerSupportsInMemoryLedgerDB l
+  ( LedgerSupportsV1LedgerDB l
+  , LedgerSupportsV2LedgerDB l
   , LedgerDbSerialiseConstraints blk
   )
 
@@ -797,3 +805,41 @@ data LedgerDbPrune
     -- slot.
     LedgerDbPruneBeforeSlot SlotNo
   deriving Show
+
+{-------------------------------------------------------------------------------
+  Streaming
+-------------------------------------------------------------------------------}
+
+-- | A backend that supports streaming the ledger tables
+class StreamingBackend m backend l where
+  data YieldArgs m backend l
+
+  data SinkArgs m backend l
+
+  yield :: Proxy backend -> YieldArgs m backend l -> Yield m l
+
+  sink :: Proxy backend -> SinkArgs m backend l -> Sink m l
+
+type Yield m l =
+  l EmptyMK ->
+  ( ( Stream
+        (Of (TxIn l, TxOut l))
+        (ExceptT DeserialiseFailure m)
+        (Stream (Of ByteString) m (Maybe CRC)) ->
+      ExceptT DeserialiseFailure m (Stream (Of ByteString) m (Maybe CRC, Maybe CRC))
+    )
+  ) ->
+  ExceptT DeserialiseFailure m (Maybe CRC, Maybe CRC)
+
+type Sink m l =
+  l EmptyMK ->
+  Stream
+    (Of (TxIn l, TxOut l))
+    (ExceptT DeserialiseFailure m)
+    (Stream (Of ByteString) m (Maybe CRC)) ->
+  ExceptT DeserialiseFailure m (Stream (Of ByteString) m (Maybe CRC, Maybe CRC))
+
+data Decoders l
+  = Decoders
+      (forall s. Decoder s (TxIn l))
+      (forall s. Decoder s (TxOut l))
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Args.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Args.hs
index fa3835306..582d3d8de 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Args.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Args.hs
@@ -1,24 +1,16 @@
-{-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE GADTs #-}
 {-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE PolyKinds #-}
-{-# LANGUAGE QuantifiedConstraints #-}
 {-# LANGUAGE RankNTypes #-}
-{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneKindSignatures #-}
-{-# LANGUAGE TypeFamilies #-}
-{-# LANGUAGE UndecidableInstances #-}
 
 -- | Arguments for LedgerDB initialization.
 module Ouroboros.Consensus.Storage.LedgerDB.Args
   ( LedgerDbArgs (..)
-  , LedgerDbFlavorArgs (..)
+  , LedgerDbBackendArgs (..)
   , QueryBatchSize (..)
   , defaultArgs
   , defaultQueryBatchSize
@@ -43,7 +35,7 @@ import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Args as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as V2
 import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.IOLike
 import Ouroboros.Network.AnchoredSeq (AnchoredSeq)
@@ -65,8 +57,8 @@ data LedgerDbArgs f m blk = LedgerDbArgs
   , lgrGenesis :: HKD f (m (ExtLedgerState blk ValuesMK))
   , lgrHasFS :: HKD f (SomeHasFS m)
   , lgrConfig :: LedgerDbCfgF f (ExtLedgerState blk)
-  , lgrTracer :: Tracer m (TraceEvent blk)
-  , lgrFlavorArgs :: LedgerDbFlavorArgs f m
+  , lgrTracer :: !(Tracer m (TraceEvent blk))
+  , lgrBackendArgs :: LedgerDbBackendArgs m blk
   , lgrRegistry :: HKD f (ResourceRegistry m)
   , lgrQueryBatchSize :: QueryBatchSize
   , lgrStartSnapshot :: Maybe DiskSnapshot
@@ -78,8 +70,9 @@ data LedgerDbArgs f m blk = LedgerDbArgs
 -- | Default arguments
 defaultArgs ::
   Applicative m =>
+  V2.SomeBackendArgs m blk ->
   Incomplete LedgerDbArgs m blk
-defaultArgs =
+defaultArgs backendArgs =
   LedgerDbArgs
     { lgrSnapshotPolicyArgs = defaultSnapshotPolicyArgs
     , lgrGenesis = NoDefault
@@ -89,24 +82,24 @@ defaultArgs =
     , lgrTracer = nullTracer
     , -- This value is the closest thing to a pre-UTxO-HD node, and as such it
       -- will be the default for end-users.
-      lgrFlavorArgs = LedgerDbFlavorArgsV2 (V2.V2Args V2.InMemoryHandleArgs)
+      lgrBackendArgs = LedgerDbBackendArgsV2 backendArgs
     , lgrRegistry = NoDefault
     , lgrStartSnapshot = Nothing
     }
 
-data LedgerDbFlavorArgs f m
-  = LedgerDbFlavorArgsV1 (V1.LedgerDbFlavorArgs f m)
-  | LedgerDbFlavorArgsV2 (V2.LedgerDbFlavorArgs f m)
+data LedgerDbBackendArgs m blk
+  = LedgerDbBackendArgsV1 (V1.LedgerDbBackendArgs m (ExtLedgerState blk))
+  | LedgerDbBackendArgsV2 (V2.SomeBackendArgs m blk)
 
 {-------------------------------------------------------------------------------
   QueryBatchSize
 -------------------------------------------------------------------------------}
 
--- | The /maximum/ number of keys to read in a backing store range query.
+-- | The /maximum/ number of keys to read in a forker range query.
 --
 -- When performing a ledger state query that involves on-disk parts of the
 -- ledger state, we might have to read ranges of key-value pair data (e.g.,
--- UTxO) from disk using backing store range queries. Instead of reading all
+-- UTxO) from disk using forker range queries. Instead of reading all
 -- data in one go, we read it in batches. 'QueryBatchSize' determines the size
 -- of these batches.
 --
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Snapshots.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Snapshots.hs
index 76b4a2926..1b5826e2f 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Snapshots.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/Snapshots.hs
@@ -11,12 +11,34 @@
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE TypeApplications #-}
 
--- | Common logic and types for LedgerDB Snapshots.
+-- | Snapshots
 --
--- Snapshots are saved copies of Ledger states in the chain which can be used to
--- restart the node without having to replay the whole chain. Regardless of the
--- actual LedgerDB implementation chosen, the general management of snapshots is
--- common to all implementations.
+-- Snapshotting a ledger state means saving a copy of the state to disk, so that
+-- a later start of a cardano-node can use such a snapshot as a starting point
+-- instead of having to replay from Genesis.
+--
+-- A snapshot is identified by the slot number of the ledger state it contains
+-- and possibly has a suffix in the name. The consensus logic will not delete a
+-- snapshot if it has a suffix. This can be used to store important
+-- snapshots. The suffix can be manually added to the snapshot by renaming the
+-- folder (see the caveats in 'snapshotManager' for the LSM backend). It will
+-- also be added automatically by some tools such as db-analyser.
+--
+-- In general snapshots will be stored in the @./ledger@ directory inside the
+-- ChainDB directory, but each LedgerDB backend is free to store it somewhere
+-- else. Management of snapshots is done through the 'SnapshotManager'
+-- record (see the 'snapshotManager' functions on each backend).
+--
+-- Snapshots cosists of two parts:
+--
+--  - the ledger state tables: location and format differs among backends,
+--
+--  - the rest of the ledger state: a CBOR serialization of an @ExtLedgerState
+--    blk EmptyMK@, stored in the @./state@ file in the snapshot directory.
+--
+-- V2 backends will provide means of loading a snapshot via the method
+-- 'newHandleFromSnapshot'. V1 backends load the snapshot directly in
+-- 'initFromSnapshot'.
 module Ouroboros.Consensus.Storage.LedgerDB.Snapshots
   ( -- * Snapshots
     CRCError (..)
@@ -28,6 +50,7 @@ module Ouroboros.Consensus.Storage.LedgerDB.Snapshots
   , SnapshotFailure (..)
   , SnapshotMetadata (..)
   , SnapshotPolicyArgs (..)
+  , TablesCodecVersion (..)
   , defaultSnapshotPolicyArgs
 
     -- * Codec
@@ -38,6 +61,7 @@ module Ouroboros.Consensus.Storage.LedgerDB.Snapshots
   , diskSnapshotIsTemporary
   , snapshotFromPath
   , snapshotToChecksumPath
+  , snapshotToStatePath
   , snapshotToDirName
   , snapshotToDirPath
   , snapshotToMetadataPath
@@ -82,6 +106,7 @@ import Control.Monad.Except
 import Control.Tracer
 import Data.Aeson (FromJSON (..), ToJSON (..), (.:), (.=))
 import qualified Data.Aeson as Aeson
+import Data.Aeson.Types (Parser)
 import Data.Functor.Identity
 import qualified Data.List as List
 import Data.Maybe (isJust, mapMaybe)
@@ -162,9 +187,24 @@ data ReadSnapshotErr
     ReadMetadataError FsPath MetadataErr
   deriving (Eq, Show)
 
+data TablesCodecVersion = TablesCodecVersion1
+  deriving (Eq, Show)
+
+instance ToJSON TablesCodecVersion where
+  toJSON TablesCodecVersion1 = Aeson.Number 1
+
+instance FromJSON TablesCodecVersion where
+  parseJSON v = enforceVersion =<< parseJSON v
+
+enforceVersion :: Word8 -> Parser TablesCodecVersion
+enforceVersion v = case v of
+  1 -> pure TablesCodecVersion1
+  _ -> fail "Unknown or outdated tables codec version"
+
 data SnapshotMetadata = SnapshotMetadata
   { snapshotBackend :: SnapshotBackend
   , snapshotChecksum :: CRC
+  , snapshotTablesCodecVersion :: TablesCodecVersion
   }
   deriving (Eq, Show)
 
@@ -173,6 +213,7 @@ instance ToJSON SnapshotMetadata where
     Aeson.object
       [ "backend" .= snapshotBackend sm
       , "checksum" .= getCRC (snapshotChecksum sm)
+      , "tablesCodecVersion" .= snapshotTablesCodecVersion sm
       ]
 
 instance FromJSON SnapshotMetadata where
@@ -180,21 +221,25 @@ instance FromJSON SnapshotMetadata where
     SnapshotMetadata
       <$> o .: "backend"
       <*> fmap CRC (o .: "checksum")
+      <*> o .: "tablesCodecVersion"
 
 data SnapshotBackend
   = UTxOHDMemSnapshot
   | UTxOHDLMDBSnapshot
+  | UTxOHDLSMSnapshot
   deriving (Eq, Show)
 
 instance ToJSON SnapshotBackend where
   toJSON = \case
     UTxOHDMemSnapshot -> "utxohd-mem"
     UTxOHDLMDBSnapshot -> "utxohd-lmdb"
+    UTxOHDLSMSnapshot -> "utxohd-lsm"
 
 instance FromJSON SnapshotBackend where
   parseJSON = Aeson.withText "SnapshotBackend" $ \case
     "utxohd-mem" -> pure UTxOHDMemSnapshot
     "utxohd-lmdb" -> pure UTxOHDLMDBSnapshot
+    "utxohd-lsm" -> pure UTxOHDLSMSnapshot
     _ -> fail "unknown SnapshotBackend"
 
 data MetadataErr
@@ -383,6 +428,11 @@ snapshotToMetadataPath = mkFsPath . (\x -> [x, "meta"]) . snapshotToDirName
 snapshotToDirPath :: DiskSnapshot -> FsPath
 snapshotToDirPath = mkFsPath . (: []) . snapshotToDirName
 
+-- | The path within the LedgerDB's filesystem to the file that contains the
+-- snapshot's serialized ledger state
+snapshotToStatePath :: DiskSnapshot -> FsPath
+snapshotToStatePath = mkFsPath . (\x -> [x, "state"]) . snapshotToDirName
+
 -- | Version 1: uses versioning ('Ouroboros.Consensus.Util.Versioned') and only
 -- encodes the ledger state @l@.
 snapshotEncodingVersion1 :: VersionNumber
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/TraceEvent.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/TraceEvent.hs
index 1072efa1f..77b3d040a 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/TraceEvent.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/TraceEvent.hs
@@ -1,9 +1,7 @@
-{-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE PolyKinds #-}
 {-# LANGUAGE StandaloneDeriving #-}
-{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
 
 module Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
   ( FlavorImplSpecificTrace (..)
@@ -17,16 +15,16 @@ import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Forker
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as V1
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as V2
 
 {-------------------------------------------------------------------------------
   Tracing
 -------------------------------------------------------------------------------}
 
 data FlavorImplSpecificTrace
-  = FlavorImplSpecificTraceV1 V1.FlavorImplSpecificTrace
-  | FlavorImplSpecificTraceV2 V2.FlavorImplSpecificTrace
-  deriving (Show, Eq)
+  = FlavorImplSpecificTraceV1 V1.SomeBackendTrace
+  | FlavorImplSpecificTraceV2 V2.LedgerDBV2Trace
+  deriving Show
 
 data TraceEvent blk
   = LedgerDBSnapshotEvent !(TraceSnapshotEvent blk)
@@ -36,8 +34,7 @@ data TraceEvent blk
   deriving Generic
 
 deriving instance
-  (StandardHash blk, InspectLedger blk) =>
+  ( StandardHash blk
+  , InspectLedger blk
+  ) =>
   Show (TraceEvent blk)
-deriving instance
-  (StandardHash blk, InspectLedger blk) =>
-  Eq (TraceEvent blk)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1.hs
index 13a984727..f0984000c 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1.hs
@@ -1,16 +1,13 @@
 {-# LANGUAGE BangPatterns #-}
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE StandaloneKindSignatures #-}
 {-# LANGUAGE TypeApplications #-}
-{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
 
@@ -83,7 +80,7 @@ mkInitDb ::
   , LedgerSupportsLedgerDB blk
   ) =>
   Complete LedgerDbArgs m blk ->
-  Complete V1.LedgerDbFlavorArgs m ->
+  V1.LedgerDbBackendArgs m (ExtLedgerState blk) ->
   ResolveBlock m blk ->
   SnapshotManagerV1 m blk ->
   GetVolatileSuffix m blk ->
@@ -152,7 +149,8 @@ mkInitDb args bss getBlock snapManager getVolatileSuffix =
         pure $ implMkLedgerDb h snapManager
     }
  where
-  bsTracer = LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV1 >$< lgrTracer
+  !bsTracer = LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV1 >$< tr
+  !tr = lgrTracer
 
   LedgerDbArgs
     { lgrHasFS
@@ -379,7 +377,6 @@ mkInternals ::
   ( IOLike m
   , LedgerDbSerialiseConstraints blk
   , LedgerSupportsProtocol blk
-  , ApplyBlock (ExtLedgerState blk) blk
   ) =>
   LedgerDBHandle m (ExtLedgerState blk) blk ->
   SnapshotManagerV1 m blk ->
@@ -763,13 +760,14 @@ acquireAtTarget ::
   Either Word64 (Target (Point blk)) ->
   ReadLocked m (Either GetForkerError (DbChangelog l))
 acquireAtTarget ldbEnv target = readLocked $ runExceptT $ do
-  dblog <- lift $ readTVarIO (ldbChangelog ldbEnv)
-  volSuffix <- lift $ atomically $ getVolatileSuffix $ ldbGetVolatileSuffix ldbEnv
-  -- The DbChangelog might contain more than k states if they have not yet
-  -- been garbage-collected.
-  let volStates = volSuffix $ changelogStates dblog
+  (dblog, volStates) <- lift $ atomically $ do
+    dblog <- readTVar (ldbChangelog ldbEnv)
+    -- The DbChangelog might contain more than k states if they have not yet
+    -- been garbage-collected.
+    volSuffix <- getVolatileSuffix $ ldbGetVolatileSuffix ldbEnv
+    pure (dblog, volSuffix $ changelogStates dblog)
 
-      immTip :: Point blk
+  let immTip :: Point blk
       immTip = castPoint $ getTip $ AS.anchor volStates
 
       rollbackMax :: Word64
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Args.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Args.hs
index 405f3d258..e8d1bf505 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Args.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Args.hs
@@ -1,29 +1,14 @@
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveGeneric #-}
-{-# LANGUAGE DerivingStrategies #-}
-{-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE MultiParamTypeClasses #-}
-{-# LANGUAGE PolyKinds #-}
-{-# LANGUAGE TypeFamilies #-}
-{-# LANGUAGE TypeOperators #-}
-{-# LANGUAGE UndecidableInstances #-}
 
 module Ouroboros.Consensus.Storage.LedgerDB.V1.Args
-  ( BackingStoreArgs (..)
-  , FlushFrequency (..)
-  , LedgerDbFlavorArgs (..)
-  , defaultLedgerDbFlavorArgs
+  ( FlushFrequency (..)
+  , LedgerDbBackendArgs (..)
   , shouldFlush
   ) where
 
-import Control.Monad.IO.Class
-import Control.Monad.Primitive
-import qualified Data.SOP.Dict as Dict
 import Data.Word
 import GHC.Generics
-import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB
-import Ouroboros.Consensus.Util.Args
+import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
 
 -- | The number of blocks in the immutable part of the chain that we have to see
 -- before we flush the ledger tables to disk. See 'onDiskShouldFlush'.
@@ -44,20 +29,7 @@ shouldFlush requestedFlushFrequency = case requestedFlushFrequency of
   DefaultFlushFrequency -> (>= 100)
   DisableFlushing -> const False
 
-data LedgerDbFlavorArgs f m = V1Args
+data LedgerDbBackendArgs m l = V1Args
   { v1FlushFrequency :: FlushFrequency
-  , v1BackendArgs :: BackingStoreArgs f m
+  , v1BackendArgs :: SomeBackendArgs m l
   }
-
-data BackingStoreArgs f m
-  = LMDBBackingStoreArgs FilePath (HKD f LMDBLimits) (Dict.Dict MonadIOPrim m)
-  | InMemoryBackingStoreArgs
-
-class (MonadIO m, PrimState m ~ PrimState IO) => MonadIOPrim m
-instance (MonadIO m, PrimState m ~ PrimState IO) => MonadIOPrim m
-
-defaultLedgerDbFlavorArgs :: Incomplete LedgerDbFlavorArgs m
-defaultLedgerDbFlavorArgs = V1Args DefaultFlushFrequency defaultBackingStoreArgs
-
-defaultBackingStoreArgs :: Incomplete BackingStoreArgs m
-defaultBackingStoreArgs = InMemoryBackingStoreArgs
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore.hs
index 94cf2129a..360c23e96 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore.hs
@@ -1,8 +1,6 @@
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE GADTs #-}
-{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE TypeFamilies #-}
 
 -- | See "Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API" for the
@@ -17,8 +15,6 @@
 module Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
   ( -- * API
 
-  --
-
     -- | Most of the documentation on the behaviour of the 'BackingStore' lives
     -- in this module.
     module Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API
@@ -28,29 +24,18 @@ module Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
   , restoreBackingStore
 
     -- * Tracing
-  , FlavorImplSpecificTrace (..)
-  , FlavorImplSpecificTraceInMemory (..)
-  , FlavorImplSpecificTraceOnDisk (..)
-
-    -- * Testing
-  , newBackingStoreInitialiser
+  , SomeBackendTrace (..)
+  , SomeBackendArgs (..)
+  , Backend (..)
   ) where
 
 import Cardano.Slotting.Slot
 import Control.Tracer
-import Data.Functor.Contravariant
-import Data.SOP.Dict (Dict (..))
-import GHC.Stack (HasCallStack)
+import Data.Proxy
 import Ouroboros.Consensus.Ledger.Basics
-import Ouroboros.Consensus.Storage.LedgerDB.API
-import Ouroboros.Consensus.Storage.LedgerDB.V1.Args
+import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.InMemory as InMemory
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB as LMDB
-import Ouroboros.Consensus.Util.Args
-import Ouroboros.Consensus.Util.IOLike
 import System.FS.API
-import System.FS.IO
 
 type BackingStoreInitialiser m l =
   InitFrom (LedgerTables l ValuesMK) ->
@@ -58,73 +43,48 @@ type BackingStoreInitialiser m l =
 
 -- | Overwrite the 'BackingStore' tables with the snapshot's tables
 restoreBackingStore ::
-  ( IOLike m
-  , HasLedgerTables l
-  , HasCallStack
-  , LedgerSupportsV1LedgerDB l
-  ) =>
-  Tracer m FlavorImplSpecificTrace ->
-  Complete BackingStoreArgs m ->
+  Tracer m SomeBackendTrace ->
+  SomeBackendArgs m l ->
   SnapshotsFS m ->
   l EmptyMK ->
   FsPath ->
   m (LedgerBackingStore m l)
-restoreBackingStore trcr bss fs st loadPath =
-  newBackingStoreInitialiser trcr bss fs (InitFromCopy st loadPath)
+restoreBackingStore trcr (SomeBackendArgs bArgs) fs st loadPath =
+  newBackingStoreInitialiser trcr bArgs fs (InitFromCopy st loadPath)
 
 -- | Create a 'BackingStore' from the given initial tables.
 newBackingStore ::
-  ( IOLike m
-  , HasLedgerTables l
-  , HasCallStack
-  , LedgerSupportsV1LedgerDB l
-  ) =>
-  Tracer m FlavorImplSpecificTrace ->
-  Complete BackingStoreArgs m ->
+  Tracer m SomeBackendTrace ->
+  SomeBackendArgs m l ->
   SnapshotsFS m ->
   l EmptyMK ->
   LedgerTables l ValuesMK ->
   m (LedgerBackingStore m l)
-newBackingStore trcr bss fs st tables =
-  newBackingStoreInitialiser trcr bss fs (InitFromValues Origin st tables)
+newBackingStore trcr (SomeBackendArgs bArgs) fs st tables =
+  newBackingStoreInitialiser trcr bArgs fs (InitFromValues Origin st tables)
 
-newBackingStoreInitialiser ::
-  forall m l.
-  ( IOLike m
-  , HasLedgerTables l
-  , HasCallStack
-  , LedgerSupportsV1LedgerDB l
-  ) =>
-  Tracer m FlavorImplSpecificTrace ->
-  Complete BackingStoreArgs m ->
-  SnapshotsFS m ->
-  BackingStoreInitialiser m l
-newBackingStoreInitialiser trcr bss =
-  case bss of
-    LMDBBackingStoreArgs fs limits Dict ->
-      LMDB.newLMDBBackingStore
-        (FlavorImplSpecificTraceOnDisk . OnDiskBackingStoreTrace >$< trcr)
-        limits
-        (LiveLMDBFS $ SomeHasFS $ ioHasFS $ MountPoint fs)
-    InMemoryBackingStoreArgs ->
-      InMemory.newInMemoryBackingStore
-        (FlavorImplSpecificTraceInMemory . InMemoryBackingStoreTrace >$< trcr)
+data SomeBackendArgs m l where
+  SomeBackendArgs :: Backend m backend l => Args m backend -> SomeBackendArgs m l
+
+data SomeBackendTrace where
+  SomeBackendTrace :: Show (Trace m backend) => Trace m backend -> SomeBackendTrace
+
+instance Show SomeBackendTrace where
+  show (SomeBackendTrace tr) = show tr
 
-{-------------------------------------------------------------------------------
-  Tracing
--------------------------------------------------------------------------------}
+class Backend m backend l where
+  data Args m backend
 
-data FlavorImplSpecificTrace
-  = FlavorImplSpecificTraceInMemory FlavorImplSpecificTraceInMemory
-  | FlavorImplSpecificTraceOnDisk FlavorImplSpecificTraceOnDisk
-  deriving (Eq, Show)
+  data Trace m backend
 
-data FlavorImplSpecificTraceInMemory
-  = InMemoryBackingStoreInitialise
-  | InMemoryBackingStoreTrace BackingStoreTrace
-  deriving (Eq, Show)
+  isRightBackendForSnapshot ::
+    Proxy l ->
+    Args m backend ->
+    SnapshotBackend ->
+    Bool
 
-data FlavorImplSpecificTraceOnDisk
-  = OnDiskBackingStoreInitialise LMDB.LMDBLimits
-  | OnDiskBackingStoreTrace BackingStoreTrace
-  deriving (Eq, Show)
+  newBackingStoreInitialiser ::
+    Tracer m SomeBackendTrace ->
+    Args m backend ->
+    SnapshotsFS m ->
+    BackingStoreInitialiser m l
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/API.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/API.hs
index 1109be6a3..02908a7ab 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/API.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/API.hs
@@ -2,13 +2,10 @@
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
-{-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeOperators #-}
-{-# LANGUAGE UndecidableInstances #-}
 
 -- | The 'BackingStore' is the component of the LedgerDB V1 implementation that
 -- stores a key-value map with the 'LedgerTable's at a specific slot on the
@@ -276,7 +273,7 @@ data RangeQuery keys = RangeQuery
   -- the changelog, which is extremely unlikely due to the random access
   -- pattern of the UTxO set.
   }
-  deriving stock (Show, Eq)
+  deriving (Show, Eq)
 
 {-------------------------------------------------------------------------------
   Statistics
@@ -297,7 +294,7 @@ data Statistics = Statistics
   , numEntries :: !Int
   -- ^ The total number of key-value pair entries that are stored.
   }
-  deriving stock (Show, Eq)
+  deriving (Show, Eq)
 
 {-------------------------------------------------------------------------------
   Tracing
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/InMemory.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/InMemory.hs
index 81231c024..f20100eae 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/InMemory.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/BackingStore/Impl/InMemory.hs
@@ -2,11 +2,13 @@
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingStrategies #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE RankNTypes #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeData #-}
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-}
 
 -- | An implementation of a 'BackingStore' using a TVar. This is the
@@ -14,6 +16,8 @@
 module Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.InMemory
   ( -- * Constructor
     newInMemoryBackingStore
+  , Backend (..)
+  , Args (InMemArgs)
 
     -- * Errors
   , InMemoryBackingStoreExn (..)
@@ -28,6 +32,7 @@ import Control.Monad (join, unless, void, when)
 import Control.Monad.Class.MonadThrow (catch)
 import Control.Tracer (Tracer, traceWith)
 import qualified Data.ByteString.Lazy as BSL
+import Data.Functor.Contravariant
 import qualified Data.Map.Strict as Map
 import qualified Data.Set as Set
 import Data.String (fromString)
@@ -38,7 +43,7 @@ import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
   ( SnapshotBackend (..)
   )
-import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.API
+import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
 import Ouroboros.Consensus.Util.IOLike
   ( Exception
   , IOLike
@@ -343,3 +348,26 @@ instance Show InMemoryBackingStoreInitExn where
       <> show p
       <> ".\nPre-UTxO-HD and LMDB implementations are incompatible with the In-Memory \
          \ implementation. Please delete your ledger database directory."
+
+type data Mem
+
+instance
+  ( IOLike m
+  , HasLedgerTables l
+  , CanUpgradeLedgerTables l
+  , SerializeTablesWithHint l
+  ) =>
+  Backend m Mem l
+  where
+  data Args m Mem = InMemArgs
+  data Trace m Mem
+    = InMemoryBackingStoreInitialise
+    | InMemoryBackingStoreTrace BackingStoreTrace
+    deriving (Eq, Show)
+
+  isRightBackendForSnapshot _ _ UTxOHDMemSnapshot = True
+  isRightBackendForSnapshot _ _ _ = False
+
+  newBackingStoreInitialiser trcr InMemArgs =
+    newInMemoryBackingStore
+      (SomeBackendTrace . InMemoryBackingStoreTrace >$< trcr)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Snapshots.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Snapshots.hs
index 745503fc8..0e4b658ee 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Snapshots.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V1/Snapshots.hs
@@ -1,6 +1,7 @@
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TypeApplications #-}
 
 -- | Snapshots
 --
@@ -154,7 +155,6 @@ import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Args
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
-import Ouroboros.Consensus.Storage.LedgerDB.V1.Args
 import Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as V1
 import Ouroboros.Consensus.Storage.LedgerDB.V1.DbChangelog
@@ -260,17 +260,13 @@ writeSnapshot fs@(SomeHasFS hasFS) backingStore encLedger snapshot cs = do
     SnapshotMetadata
       { snapshotBackend = bsSnapshotBackend backingStore
       , snapshotChecksum = crc
+      , snapshotTablesCodecVersion = TablesCodecVersion1
       }
   bsCopy
     backingStore
     cs
     (snapshotToTablesPath snapshot)
 
--- | The path within the LedgerDB's filesystem to the file that contains the
--- snapshot's serialized ledger state
-snapshotToStatePath :: DiskSnapshot -> FsPath
-snapshotToStatePath = mkFsPath . (\x -> [x, "state"]) . snapshotToDirName
-
 -- | The path within the LedgerDB's filesystem to the directory that contains a
 -- snapshot's backing store
 snapshotToTablesPath :: DiskSnapshot -> FsPath
@@ -287,8 +283,8 @@ loadSnapshot ::
   , LedgerSupportsV1LedgerDB (LedgerState blk)
   , LedgerDbSerialiseConstraints blk
   ) =>
-  Tracer m V1.FlavorImplSpecificTrace ->
-  Complete BackingStoreArgs m ->
+  Tracer m V1.SomeBackendTrace ->
+  SomeBackendArgs m (ExtLedgerState blk) ->
   CodecConfig blk ->
   SnapshotsFS m ->
   ResourceRegistry m ->
@@ -297,18 +293,18 @@ loadSnapshot ::
     (SnapshotFailure blk)
     m
     ((DbChangelog' blk, ResourceKey m, LedgerBackingStore m (ExtLedgerState blk)), RealPoint blk)
-loadSnapshot tracer bss ccfg fs@(SnapshotsFS fs') reg s = do
+loadSnapshot tracer bArgs@(SomeBackendArgs bss) ccfg fs@(SnapshotsFS fs') reg s = do
   (extLedgerSt, checksumAsRead) <-
     withExceptT (InitFailureRead . ReadSnapshotFailed) $
       readExtLedgerState fs' (decodeDiskExtLedgerState ccfg) decode (snapshotToStatePath s)
   snapshotMeta <-
     withExceptT (InitFailureRead . ReadMetadataError (snapshotToMetadataPath s)) $
       loadSnapshotMetadata fs' s
-  case (bss, snapshotBackend snapshotMeta) of
-    (InMemoryBackingStoreArgs, UTxOHDMemSnapshot) -> pure ()
-    (LMDBBackingStoreArgs _ _ _, UTxOHDLMDBSnapshot) -> pure ()
-    (_, _) ->
-      throwError $ InitFailureRead $ ReadMetadataError (snapshotToMetadataPath s) MetadataBackendMismatch
+  Monad.unless
+    (isRightBackendForSnapshot (Proxy @(ExtLedgerState blk)) bss (snapshotBackend snapshotMeta))
+    $ throwError
+    $ InitFailureRead
+    $ ReadMetadataError (snapshotToMetadataPath s) MetadataBackendMismatch
   Monad.when (checksumAsRead /= snapshotChecksum snapshotMeta) $
     throwError $
       InitFailureRead $
@@ -318,6 +314,10 @@ loadSnapshot tracer bss ccfg fs@(SnapshotsFS fs') reg s = do
     NotOrigin pt -> do
       (bsKey, backingStore) <-
         Trans.lift
-          (allocate reg (\_ -> restoreBackingStore tracer bss fs extLedgerSt (snapshotToTablesPath s)) bsClose)
+          ( allocate
+              reg
+              (\_ -> restoreBackingStore tracer bArgs fs extLedgerSt (snapshotToTablesPath s))
+              bsClose
+          )
       let chlog = empty extLedgerSt
       pure ((chlog, bsKey, backingStore), pt)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2.hs
index b6c6f6b08..d0e7bb1c9 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2.hs
@@ -1,11 +1,8 @@
-{-# LANGUAGE CPP #-}
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE Rank2Types #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE StandaloneKindSignatures #-}
@@ -51,9 +48,8 @@ import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Args
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
-import Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
 import Ouroboros.Consensus.Storage.LedgerDB.V2.Forker
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as InMemory
 import Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq
 import Ouroboros.Consensus.Util (whenJust)
 import Ouroboros.Consensus.Util.Args
@@ -68,28 +64,31 @@ import Prelude hiding (read)
 type SnapshotManagerV2 m blk = SnapshotManager m m blk (StateRef m (ExtLedgerState blk))
 
 mkInitDb ::
-  forall m blk.
+  forall m blk backend.
   ( LedgerSupportsProtocol blk
-  , IOLike m
   , LedgerDbSerialiseConstraints blk
   , HasHardForkHistory blk
-  , LedgerSupportsV2LedgerDB (LedgerState blk)
+  , Backend m backend blk
+  , IOLike m
   ) =>
   Complete LedgerDbArgs m blk ->
-  HandleEnv m ->
   ResolveBlock m blk ->
   SnapshotManagerV2 m blk ->
   GetVolatileSuffix m blk ->
+  Resources m backend ->
   InitDB (LedgerSeq' m blk) m blk
-mkInitDb args bss getBlock snapManager getVolatileSuffix =
+mkInitDb args getBlock snapManager getVolatileSuffix res = do
   InitDB
     { initFromGenesis = emptyF =<< lgrGenesis
     , initFromSnapshot =
-        loadSnapshot (configCodec . getExtLedgerCfg . ledgerDbCfg $ lgrConfig) lgrHasFS
-    , abortLedgerDbInit = \ls -> do
-        closeLedgerSeq ls
-        flip whenJust releaseLedgerDBResources $ case bss of
-          InMemoryHandleEnv -> Nothing
+        runExceptT
+          . newHandleFromSnapshot
+            v2Tracer
+            lgrRegistry
+            (configCodec . getExtLedgerCfg . ledgerDbCfg $ lgrConfig)
+            lgrHasFS
+            res
+    , abortLedgerDbInit = closeLedgerSeq
     , initReapplyBlock = \a b c -> do
         (x, y) <- reapplyThenPush lgrRegistry a b c
         x
@@ -114,9 +113,8 @@ mkInitDb args bss getBlock snapManager getVolatileSuffix =
                 , ldbResolveBlock = getBlock
                 , ldbQueryBatchSize = lgrQueryBatchSize
                 , ldbOpenHandlesLock = lock
-                , ldbResourceKeys = case bss of
-                    InMemoryHandleEnv -> Nothing
                 , ldbGetVolatileSuffix = getVolatileSuffix
+                , ldbResourceKeys = SomeResources res
                 }
         h <- LDBHandle <$> newTVarIO (LedgerDBOpen env)
         pure $ implMkLedgerDb h snapManager
@@ -132,23 +130,14 @@ mkInitDb args bss getBlock snapManager getVolatileSuffix =
     , lgrRegistry
     } = args
 
-  v2Tracer :: Tracer m V2.FlavorImplSpecificTrace
-  v2Tracer = LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV2 >$< lgrTracer
+  v2Tracer :: Tracer m LedgerDBV2Trace
+  v2Tracer =
+    LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV2 >$< lgrTracer
 
   emptyF ::
     ExtLedgerState blk ValuesMK ->
     m (LedgerSeq' m blk)
-  emptyF st =
-    empty' st $ case bss of
-      InMemoryHandleEnv -> InMemory.newInMemoryLedgerTablesHandle v2Tracer lgrHasFS
-
-  loadSnapshot ::
-    CodecConfig blk ->
-    SomeHasFS m ->
-    DiskSnapshot ->
-    m (Either (SnapshotFailure blk) (LedgerSeq' m blk, RealPoint blk))
-  loadSnapshot ccfg fs ds = case bss of
-    InMemoryHandleEnv -> runExceptT $ InMemory.loadSnapshot v2Tracer lgrRegistry ccfg fs ds
+  emptyF st = empty' st $ newHandleFromValues v2Tracer lgrRegistry res
 
 implMkLedgerDb ::
   forall m l blk.
@@ -229,7 +218,8 @@ mkInternals h snapManager =
     , closeLedgerDB = do
         let LDBHandle tvar = h
         getEnv h $ \env ->
-          whenJust (ldbResourceKeys env) releaseLedgerDBResources
+          case ldbResourceKeys env of
+            SomeResources res -> releaseResources (Proxy @blk) res
         atomically (writeTVar tvar LedgerDBClosed)
     , getNumLedgerTablesHandles = getEnv h $ \env -> do
         l <- readTVarIO (ldbSeq env)
@@ -247,7 +237,7 @@ mkInternals h snapManager =
 implIntTruncateSnapshots :: MonadThrow m => SnapshotManager m m blk st -> SomeHasFS m -> m ()
 implIntTruncateSnapshots snapManager (SomeHasFS fs) = do
   snapshotsMapM_ snapManager $
-    \pre -> withFile fs (InMemory.snapshotToStatePath pre) (AppendMode AllowExisting) $
+    \pre -> withFile fs (snapshotToStatePath pre) (AppendMode AllowExisting) $
       \h -> hTruncate fs h 0
 
 implGetVolatileTip ::
@@ -381,7 +371,7 @@ implTryTakeSnapshot snapManager env mTime nrBlocks =
 implTryFlush :: Applicative m => LedgerDBEnv m l blk -> m ()
 implTryFlush _ = pure ()
 
-implCloseDB :: IOLike m => LedgerDBHandle m l blk -> m ()
+implCloseDB :: forall m l blk. IOLike m => LedgerDBHandle m l blk -> m ()
 implCloseDB (LDBHandle varState) = do
   res <-
     atomically $
@@ -391,8 +381,8 @@ implCloseDB (LDBHandle varState) = do
         LedgerDBOpen env -> do
           writeTVar (ldbForkers env) Map.empty
           writeTVar varState LedgerDBClosed
-          pure (ldbResourceKeys env)
-  whenJust res releaseLedgerDBResources
+          pure (Just $ ldbResourceKeys env)
+  whenJust res (\(SomeResources res') -> releaseResources (Proxy @blk) res')
 
 {-------------------------------------------------------------------------------
   The LedgerDBEnv
@@ -452,7 +442,7 @@ data LedgerDBEnv m l blk = LedgerDBEnv
   --
   --  * Modify 'ldbSeq' while holding a write lock, and then close the removed
   --    handles without any locking. See e.g. 'implGarbageCollect'.
-  , ldbResourceKeys :: !(Maybe (LedgerDBResourceKeys m))
+  , ldbResourceKeys :: !(SomeResources m blk)
   -- ^ Resource keys used in the LSM backend so that the closing function used
   -- in tests can release such resources. These are the resource keys for the
   -- LSM session and the resource key for the BlockIO interface.
@@ -467,24 +457,10 @@ deriving instance
   , NoThunks (TxIn l)
   , NoThunks (TxOut l)
   , NoThunks (LedgerCfg l)
+  , NoThunks (SomeResources m blk)
   ) =>
   NoThunks (LedgerDBEnv m l blk)
 
-data LedgerDBResourceKeys m = LedgerDBResourceKeys
-  { sessionResourceKey :: ResourceKey m
-  , blockIOResourceKey :: ResourceKey m
-  }
-  deriving Generic
-
-deriving instance
-  IOLike m =>
-  NoThunks (LedgerDBResourceKeys m)
-
-releaseLedgerDBResources :: IOLike m => LedgerDBResourceKeys m -> m ()
-releaseLedgerDBResources l = do
-  Monad.void . release . sessionResourceKey $ l
-  Monad.void . release . blockIOResourceKey $ l
-
 {-------------------------------------------------------------------------------
   The LedgerDBHandle
 -------------------------------------------------------------------------------}
@@ -506,6 +482,7 @@ deriving instance
   , NoThunks (TxIn l)
   , NoThunks (TxOut l)
   , NoThunks (LedgerCfg l)
+  , NoThunks (SomeResources m blk)
   ) =>
   NoThunks (LedgerDBState m l blk)
 
@@ -781,6 +758,7 @@ newForker h ldbEnv rr (st, rk) = do
           , foeSwitchVar = ldbSeq ldbEnv
           , foeTracer = tr
           , foeResourcesToRelease = (ldbOpenHandlesLock ldbEnv, k, toRelease)
+          , foeInitialHandleKey = rk
           }
   atomically $ modifyTVar (ldbForkers ldbEnv) $ Map.insert forkerKey forkerEnv
   pure $
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Args.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Args.hs
deleted file mode 100644
index 068d64d52..000000000
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Args.hs
+++ /dev/null
@@ -1,37 +0,0 @@
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE PolyKinds #-}
-
-module Ouroboros.Consensus.Storage.LedgerDB.V2.Args
-  ( FlavorImplSpecificTrace (..)
-  , HandleArgs (..)
-  , HandleEnv (..)
-  , LedgerDbFlavorArgs (..)
-  , LSMHandleArgs (..)
-  ) where
-
-import Data.Void
-
-data LedgerDbFlavorArgs f m = V2Args (HandleArgs f m)
-
--- | The arguments that are needed to create a 'HandleEnv' for the different
--- backends.
-data HandleArgs f m
-  = InMemoryHandleArgs
-  | LSMHandleArgs (LSMHandleArgs f m)
-
-data LSMHandleArgs f m = LSMArgs Void
-
--- | The environment used to create new handles
-data HandleEnv m
-  = InMemoryHandleEnv
-  | -- | The environment for creating LSM handles. It carries the 'Session'
-    -- together with its resource key and the resource key of the 'HasBlockIO'.
-    LSMHandleEnv !Void
-
-data FlavorImplSpecificTrace
-  = -- | Created a new 'LedgerTablesHandle', potentially by duplicating an
-    -- existing one.
-    TraceLedgerTablesHandleCreate
-  | -- | Closed a 'LedgerTablesHandle'.
-    TraceLedgerTablesHandleClose
-  deriving (Show, Eq)
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Backend.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Backend.hs
new file mode 100644
index 000000000..7ff562ee4
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Backend.hs
@@ -0,0 +1,120 @@
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
+
+-- | Common interface for LedgerDB V2 backends
+module Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
+  ( -- * Backend API
+    Backend (..)
+
+    -- * Existentials
+  , SomeBackendTrace (..)
+  , SomeBackendArgs (..)
+  , SomeResources (..)
+
+    -- * Tracing
+  , LedgerDBV2Trace (..)
+  ) where
+
+import Control.Monad.Except
+import Control.ResourceRegistry
+import Control.Tracer
+import Data.Proxy
+import NoThunks.Class
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Ledger.Abstract
+import Ouroboros.Consensus.Ledger.Extended
+import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
+import Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq
+import System.FS.API
+
+-- | Operations needed to open and operate a LedgerDB V2
+class NoThunks (Resources m backend) => Backend m backend blk where
+  -- | The Arguments that will be used initially to create the 'Resources'.
+  data Args m backend
+
+  -- | The Resources that will be stored in the LedgerDB environment and given
+  -- to the handle operations.
+  data Resources m backend
+
+  -- | A trace dependent on the particular backend.
+  data Trace m backend
+
+  -- | Transform 'Args' into 'Resources', with some context made up of
+  -- 'LedgerDbArgs'.
+  mkResources ::
+    Proxy blk ->
+    Tracer m LedgerDBV2Trace ->
+    Args m backend ->
+    ResourceRegistry m ->
+    SomeHasFS m ->
+    m (Resources m backend)
+
+  -- | Release the acquired resources.
+  releaseResources :: Proxy blk -> Resources m backend -> m ()
+
+  -- | Create a new handle from the given values. This will only be called when
+  -- starting Consensus from Genesis.
+  newHandleFromValues ::
+    Tracer m LedgerDBV2Trace ->
+    ResourceRegistry m ->
+    Resources m backend ->
+    ExtLedgerState blk ValuesMK ->
+    m (LedgerTablesHandle m (ExtLedgerState blk))
+
+  -- | Create a new handle from a snapshot.
+  newHandleFromSnapshot ::
+    Tracer m LedgerDBV2Trace ->
+    ResourceRegistry m ->
+    CodecConfig blk ->
+    SomeHasFS m ->
+    Resources m backend ->
+    DiskSnapshot ->
+    ExceptT (SnapshotFailure blk) m (LedgerSeq' m blk, RealPoint blk)
+
+  -- | Instantiate the 'SnapshotManager' for this backend.
+  snapshotManager ::
+    Proxy blk ->
+    Resources m backend ->
+    CodecConfig blk ->
+    Tracer m (TraceSnapshotEvent blk) ->
+    SomeHasFS m ->
+    SnapshotManager m m blk (StateRef m (ExtLedgerState blk))
+
+{-------------------------------------------------------------------------------
+  Existentials
+-------------------------------------------------------------------------------}
+
+data SomeBackendTrace where
+  SomeBackendTrace :: Show (Trace m backend) => Trace m backend -> SomeBackendTrace
+
+instance Show SomeBackendTrace where
+  show (SomeBackendTrace tr) = show tr
+
+data SomeBackendArgs m blk where
+  SomeBackendArgs :: Backend m backend blk => Args m backend -> SomeBackendArgs m blk
+
+data SomeResources m blk where
+  SomeResources :: Backend m backend blk => Resources m backend -> SomeResources m blk
+
+instance NoThunks (SomeResources m blk) where
+  wNoThunks ctxt (SomeResources res) = wNoThunks ctxt res
+  noThunks ctxt (SomeResources res) = noThunks ctxt res
+  showTypeOf _ = "SomeResources"
+
+{-------------------------------------------------------------------------------
+  Tracing
+-------------------------------------------------------------------------------}
+
+data LedgerDBV2Trace
+  = -- | Created a new 'LedgerTablesHandle', potentially by duplicating an
+    -- existing one.
+    TraceLedgerTablesHandleCreate
+  | -- | Closed a 'LedgerTablesHandle'.
+    TraceLedgerTablesHandleClose
+  | BackendTrace SomeBackendTrace
+
+deriving instance Show SomeBackendTrace => Show LedgerDBV2Trace
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Forker.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Forker.hs
index 53a7fb814..b252ae5da 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Forker.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/Forker.hs
@@ -19,6 +19,7 @@ module Ouroboros.Consensus.Storage.LedgerDB.V2.Forker
   , module Ouroboros.Consensus.Storage.LedgerDB.Forker
   ) where
 
+import qualified Control.Monad as Monad
 import Control.RAWLock hiding (read)
 import Control.ResourceRegistry
 import Control.Tracer
@@ -52,6 +53,9 @@ data ForkerEnv m l blk = ForkerEnv
   -- ^ Config
   , foeResourcesToRelease :: !(RAWLock m (), ResourceKey m, StrictTVar m (m ()))
   -- ^ Release the resources
+  , foeInitialHandleKey :: !(ResourceKey m)
+  -- ^ Resource key for the initial handle to ensure it is released. See
+  -- comments in 'implForkerCommit'.
   }
   deriving Generic
 
@@ -73,7 +77,7 @@ implForkerReadTables env ks = do
   traceWith (foeTracer env) ForkerReadTablesStart
   lseq <- readTVarIO (foeLedgerSeq env)
   let stateRef = currentHandle lseq
-  tbs <- read (tables stateRef) ks
+  tbs <- read (tables stateRef) (state stateRef) ks
   traceWith (foeTracer env) ForkerReadTablesEnd
   pure tbs
 
@@ -89,10 +93,10 @@ implForkerRangeReadTables qbs env rq0 = do
   let n = fromIntegral $ defaultQueryBatchSize qbs
       stateRef = currentHandle ldb
   case rq0 of
-    NoPreviousQuery -> readRange (tables $ currentHandle ldb) (Nothing, n)
+    NoPreviousQuery -> readRange (tables stateRef) (state stateRef) (Nothing, n)
     PreviousQueryWasFinal -> pure (LedgerTables emptyMK, Nothing)
     PreviousQueryWasUpTo k -> do
-      tbs <- readRange (tables stateRef) (Just k, n)
+      tbs <- readRange (tables stateRef) (state stateRef) (Just k, n)
       traceWith (foeTracer env) ForkerRangeReadTablesEnd
       pure tbs
 
@@ -160,19 +164,12 @@ implForkerCommit env = do
                   AS.Empty _ -> pure ()
                   _ AS.:< closeOld' -> closeLedgerSeq (LedgerSeq closeOld')
                 -- Finally, close the anchor of @lseq@ (which is a duplicate of
-                -- the head of @olddb'@).
-                --
-                -- Note if the resource registry used to create the Forker is
-                -- ephemeral as the one created on each Chain selection or each
-                -- Forging loop iteration, this first duplicated state will be
-                -- closed by the resource registry closing down, so this will be
-                -- a double release, which is fine. We prefer keeping this
-                -- action just in case some client passes a registry that
-                -- outlives the forker.
-                --
-                -- The rest of the states in the forker will be closed via
-                -- @foeResourcesToRelease@ instead of via the registry.
-                close $ tables $ AS.anchor lseq
+                -- the head of @olddb'@). To close this handle, we have to
+                -- release the 'foeInitialHandleKey' as that one is registered
+                -- on the registry used to open the forker. Releasing it will
+                -- call 'close' on the handle which will call 'release' on the key
+                -- for the handle.
+                Monad.void $ release foeInitialHandleKey
           pure (closeDiscarded, LedgerSeq newdb)
       )
 
@@ -186,6 +183,7 @@ implForkerCommit env = do
     { foeLedgerSeq
     , foeSwitchVar
     , foeResourcesToRelease
+    , foeInitialHandleKey
     } = env
 
   theImpossible =
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/InMemory.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/InMemory.hs
index 6e23ac6d2..be6ec8a08 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/InMemory.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/InMemory.hs
@@ -1,70 +1,77 @@
 {-# LANGUAGE BangPatterns #-}
-{-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingVia #-}
-{-# LANGUAGE EmptyDataDeriving #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE GADTs #-}
 {-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE MultiParamTypeClasses #-}
-{-# LANGUAGE QuantifiedConstraints #-}
 {-# LANGUAGE RankNTypes #-}
-{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE TupleSections #-}
+{-# LANGUAGE TypeData #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-}
+{-# LANGUAGE ViewPatterns #-}
 
 module Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory
-  ( -- * LedgerTablesHandle
-    newInMemoryLedgerTablesHandle
-
-    -- * Snapshots
-  , loadSnapshot
-  , snapshotManager
-  , snapshotToStatePath
-
-    -- * snapshot-converter
-  , implTakeSnapshot
+  ( Backend (..)
+  , Args (InMemArgs)
+  , Mem
+  , YieldArgs (YieldInMemory)
+  , SinkArgs (SinkInMemory)
+  , mkInMemoryArgs
   ) where
 
 import Cardano.Binary as CBOR
+import Cardano.Slotting.Slot
+import Codec.CBOR.Read
 import qualified Codec.CBOR.Write as CBOR
 import Codec.Serialise (decode)
+import Control.Monad (replicateM_, unless)
 import qualified Control.Monad as Monad
-import Control.Monad.Trans (lift)
+import Control.Monad.Class.MonadST
+import Control.Monad.Class.MonadSTM
+import Control.Monad.Class.MonadThrow
+import Control.Monad.Except
+import Control.Monad.State.Strict (execStateT)
 import Control.Monad.Trans.Except
 import Control.ResourceRegistry
 import Control.Tracer
+import Data.ByteString (ByteString)
+import qualified Data.ByteString as BS
+import Data.ByteString.Builder.Extra (defaultChunkSize)
 import Data.Functor.Contravariant ((>$<))
 import Data.Functor.Identity
 import qualified Data.List as List
 import qualified Data.Map.Strict as Map
 import Data.Maybe
-import Data.String (fromString)
+import Data.MemPack
+import Data.Void
 import GHC.Generics
 import NoThunks.Class
 import Ouroboros.Consensus.Block
-import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.Ledger.Abstract
 import Ouroboros.Consensus.Ledger.Extended
 import Ouroboros.Consensus.Ledger.SupportsProtocol
 import qualified Ouroboros.Consensus.Ledger.Tables.Diff as Diff
+import Ouroboros.Consensus.Ledger.Tables.Utils
 import Ouroboros.Consensus.Storage.LedgerDB.API
 import Ouroboros.Consensus.Storage.LedgerDB.Args
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
-import Ouroboros.Consensus.Storage.LedgerDB.TraceEvent
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend
 import Ouroboros.Consensus.Storage.LedgerDB.V2.LedgerSeq
-import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.CBOR (readIncremental)
 import Ouroboros.Consensus.Util.CRC
 import Ouroboros.Consensus.Util.Enclose
 import Ouroboros.Consensus.Util.IOLike
+import Streaming
+import qualified Streaming as S
+import qualified Streaming.Prelude as S
 import System.FS.API
 import System.FS.CRC
+import qualified System.FilePath as F
 import Prelude hiding (read)
 
 {-------------------------------------------------------------------------------
@@ -92,87 +99,153 @@ newInMemoryLedgerTablesHandle ::
   , CanUpgradeLedgerTables l
   , SerializeTablesWithHint l
   ) =>
-  Tracer m V2.FlavorImplSpecificTrace ->
+  Tracer m LedgerDBV2Trace ->
   SomeHasFS m ->
   LedgerTables l ValuesMK ->
   m (LedgerTablesHandle m l)
 newInMemoryLedgerTablesHandle tracer someFS@(SomeHasFS hasFS) l = do
   !tv <- newTVarIO (LedgerTablesHandleOpen l)
-  traceWith tracer V2.TraceLedgerTablesHandleCreate
+  traceWith tracer TraceLedgerTablesHandleCreate
   pure
     LedgerTablesHandle
-      { close = do
-          p <- atomically $ swapTVar tv LedgerTablesHandleClosed
-          case p of
-            LedgerTablesHandleOpen{} -> traceWith tracer V2.TraceLedgerTablesHandleClose
-            _ -> pure ()
-      , duplicate = do
-          hs <- readTVarIO tv
-          !x <- guardClosed hs $ newInMemoryLedgerTablesHandle tracer someFS
-          pure x
-      , read = \keys -> do
-          hs <- readTVarIO tv
-          guardClosed
-            hs
-            (pure . flip (ltliftA2 (\(ValuesMK v) (KeysMK k) -> ValuesMK $ v `Map.restrictKeys` k)) keys)
-      , readRange = \(f, t) -> do
-          hs <- readTVarIO tv
+      { close = implClose tracer tv
+      , duplicate = implDuplicate tracer tv someFS
+      , read = implRead tv
+      , readRange = implReadRange tv
+      , readAll = implReadAll tv
+      , pushDiffs = implPushDiffs tv
+      , takeHandleSnapshot = implTakeHandleSnapshot tv hasFS
+      , tablesSize = implTablesSize tv
+      }
+
+{-# INLINE implClose #-}
+{-# INLINE implDuplicate #-}
+{-# INLINE implRead #-}
+{-# INLINE implReadRange #-}
+{-# INLINE implReadAll #-}
+{-# INLINE implPushDiffs #-}
+{-# INLINE implTakeHandleSnapshot #-}
+{-# INLINE implTablesSize #-}
+
+implClose ::
+  IOLike m =>
+  Tracer m LedgerDBV2Trace ->
+  StrictTVar m (LedgerTablesHandleState l) ->
+  m ()
+implClose tracer tv = do
+  p <- atomically $ swapTVar tv LedgerTablesHandleClosed
+  case p of
+    LedgerTablesHandleOpen{} -> traceWith tracer TraceLedgerTablesHandleClose
+    _ -> pure ()
+
+implDuplicate ::
+  ( IOLike m
+  , HasLedgerTables l
+  , CanUpgradeLedgerTables l
+  , SerializeTablesWithHint l
+  ) =>
+  Tracer m LedgerDBV2Trace ->
+  StrictTVar m (LedgerTablesHandleState l) ->
+  SomeHasFS m ->
+  m (LedgerTablesHandle m l)
+implDuplicate tracer tv someFS = do
+  hs <- readTVarIO tv
+  !x <- guardClosed hs $ newInMemoryLedgerTablesHandle tracer someFS
+  pure x
+
+implRead ::
+  ( IOLike m
+  , HasLedgerTables l
+  ) =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  l EmptyMK ->
+  LedgerTables l KeysMK ->
+  m (LedgerTables l ValuesMK)
+implRead tv _ keys = do
+  hs <- readTVarIO tv
+  guardClosed
+    hs
+    (pure . flip (ltliftA2 (\(ValuesMK v) (KeysMK k) -> ValuesMK $ v `Map.restrictKeys` k)) keys)
+
+implReadRange ::
+  (IOLike m, HasLedgerTables l) =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  l EmptyMK ->
+  (Maybe (TxIn l), Int) ->
+  m (LedgerTables l ValuesMK, Maybe (TxIn l))
+implReadRange tv _ (f, t) = do
+  hs <- readTVarIO tv
+  guardClosed
+    hs
+    ( \(LedgerTables (ValuesMK m)) ->
+        let m' = Map.take t . (maybe id (\g -> snd . Map.split g) f) $ m
+         in pure (LedgerTables (ValuesMK m'), fst <$> Map.lookupMax m')
+    )
+
+implReadAll ::
+  IOLike m =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  l EmptyMK ->
+  m (LedgerTables l ValuesMK)
+implReadAll tv _ = do
+  hs <- readTVarIO tv
+  guardClosed hs pure
+
+implPushDiffs ::
+  ( IOLike m
+  , HasLedgerTables l
+  , CanUpgradeLedgerTables l
+  ) =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  l mk1 ->
+  l DiffMK ->
+  m ()
+implPushDiffs tv st0 !diffs =
+  atomically $
+    modifyTVar
+      tv
+      ( \r ->
           guardClosed
-            hs
-            ( \(LedgerTables (ValuesMK m)) ->
-                let m' = Map.take t . (maybe id (\g -> snd . Map.split g) f) $ m
-                 in pure (LedgerTables (ValuesMK m'), fst <$> Map.lookupMax m')
+            r
+            ( LedgerTablesHandleOpen
+                . flip
+                  (ltliftA2 (\(ValuesMK vals) (DiffMK d) -> ValuesMK (Diff.applyDiff vals d)))
+                  (projectLedgerTables diffs)
+                . upgradeTables st0 diffs
             )
-      , readAll = do
-          hs <- readTVarIO tv
-          guardClosed hs pure
-      , pushDiffs = \st0 !diffs ->
-          atomically $
-            modifyTVar
-              tv
-              ( \r ->
-                  guardClosed
-                    r
-                    ( LedgerTablesHandleOpen
-                        . flip
-                          (ltliftA2 (\(ValuesMK vals) (DiffMK d) -> ValuesMK (Diff.applyDiff vals d)))
-                          (projectLedgerTables diffs)
-                        . upgradeTables st0 diffs
-                    )
-              )
-      , takeHandleSnapshot = \hint snapshotName -> do
-          createDirectoryIfMissing hasFS True $ mkFsPath [snapshotName, "tables"]
-          h <- readTVarIO tv
-          guardClosed h $
-            \values ->
-              withFile hasFS (mkFsPath [snapshotName, "tables", "tvar"]) (WriteMode MustBeNew) $ \hf ->
-                fmap (Just . snd) $
-                  hPutAllCRC hasFS hf $
-                    CBOR.toLazyByteString $
-                      valuesMKEncoder hint values
-      , tablesSize = do
-          hs <- readTVarIO tv
-          guardClosed hs (pure . Just . Map.size . getValuesMK . getLedgerTables)
-      }
+      )
+
+implTakeHandleSnapshot ::
+  (IOLike m, SerializeTablesWithHint l) =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  HasFS m h ->
+  l EmptyMK ->
+  String ->
+  m (Maybe CRC)
+implTakeHandleSnapshot tv hasFS hint snapshotName = do
+  createDirectoryIfMissing hasFS True $ mkFsPath [snapshotName]
+  h <- readTVarIO tv
+  guardClosed h $
+    \values ->
+      withFile hasFS (mkFsPath [snapshotName, "tables"]) (WriteMode MustBeNew) $ \hf ->
+        fmap (Just . snd) $
+          hPutAllCRC hasFS hf $
+            CBOR.toLazyByteString $
+              valuesMKEncoder hint values
+
+implTablesSize ::
+  IOLike m =>
+  StrictTVar m (LedgerTablesHandleState l) ->
+  m (Maybe Int)
+implTablesSize tv = do
+  hs <- readTVarIO tv
+  guardClosed hs (pure . Just . Map.size . getValuesMK . getLedgerTables)
 
 {-------------------------------------------------------------------------------
   Snapshots
 -------------------------------------------------------------------------------}
 
 snapshotManager ::
-  ( IOLike m
-  , LedgerDbSerialiseConstraints blk
-  , LedgerSupportsProtocol blk
-  ) =>
-  Complete LedgerDbArgs m blk ->
-  SnapshotManager m m blk (StateRef m (ExtLedgerState blk))
-snapshotManager args =
-  snapshotManager'
-    (configCodec . getExtLedgerCfg . ledgerDbCfg $ lgrConfig args)
-    (LedgerDBSnapshotEvent >$< lgrTracer args)
-    (lgrHasFS args)
-
-snapshotManager' ::
   ( IOLike m
   , LedgerDbSerialiseConstraints blk
   , LedgerSupportsProtocol blk
@@ -181,35 +254,14 @@ snapshotManager' ::
   Tracer m (TraceSnapshotEvent blk) ->
   SomeHasFS m ->
   SnapshotManager m m blk (StateRef m (ExtLedgerState blk))
-snapshotManager' ccfg tracer fs =
+snapshotManager ccfg tracer fs =
   SnapshotManager
     { listSnapshots = defaultListSnapshots fs
     , deleteSnapshot = defaultDeleteSnapshot fs tracer
     , takeSnapshot = implTakeSnapshot ccfg tracer fs
     }
 
--- | The path within the LedgerDB's filesystem to the file that contains the
--- snapshot's serialized ledger state
-snapshotToStatePath :: DiskSnapshot -> FsPath
-snapshotToStatePath = mkFsPath . (\x -> [x, "state"]) . snapshotToDirName
-
-writeSnapshot ::
-  MonadThrow m =>
-  SomeHasFS m ->
-  (ExtLedgerState blk EmptyMK -> Encoding) ->
-  DiskSnapshot ->
-  StateRef m (ExtLedgerState blk) ->
-  m ()
-writeSnapshot fs@(SomeHasFS hasFs) encLedger ds st = do
-  createDirectoryIfMissing hasFs True $ snapshotToDirPath ds
-  crc1 <- writeExtLedgerState fs encLedger (snapshotToStatePath ds) $ state st
-  crc2 <- takeHandleSnapshot (tables st) (state st) $ snapshotToDirName ds
-  writeSnapshotMetadata fs ds $
-    SnapshotMetadata
-      { snapshotBackend = UTxOHDMemSnapshot
-      , snapshotChecksum = maybe crc1 (crcOfConcat crc1) crc2
-      }
-
+{-# INLINE implTakeSnapshot #-}
 implTakeSnapshot ::
   ( IOLike m
   , LedgerDbSerialiseConstraints blk
@@ -221,20 +273,31 @@ implTakeSnapshot ::
   Maybe String ->
   StateRef m (ExtLedgerState blk) ->
   m (Maybe (DiskSnapshot, RealPoint blk))
-implTakeSnapshot ccfg tracer hasFS suffix st = do
+implTakeSnapshot ccfg tracer shfs@(SomeHasFS hasFS) suffix st = do
   case pointToWithOriginRealPoint (castPoint (getTip $ state st)) of
     Origin -> return Nothing
     NotOrigin t -> do
       let number = unSlotNo (realPointSlot t)
           snapshot = DiskSnapshot number suffix
-      diskSnapshots <- defaultListSnapshots hasFS
+      diskSnapshots <- defaultListSnapshots shfs
       if List.any (== DiskSnapshot number suffix) diskSnapshots
         then
           return Nothing
         else do
           encloseTimedWith (TookSnapshot snapshot t >$< tracer) $
-            writeSnapshot hasFS (encodeDiskExtLedgerState ccfg) snapshot st
+            writeSnapshot snapshot
           return $ Just (snapshot, t)
+ where
+  writeSnapshot ds = do
+    createDirectoryIfMissing hasFS True $ snapshotToDirPath ds
+    crc1 <- writeExtLedgerState shfs (encodeDiskExtLedgerState ccfg) (snapshotToStatePath ds) $ state st
+    crc2 <- takeHandleSnapshot (tables st) (state st) $ snapshotToDirName ds
+    writeSnapshotMetadata shfs ds $
+      SnapshotMetadata
+        { snapshotBackend = UTxOHDMemSnapshot
+        , snapshotChecksum = maybe crc1 (crcOfConcat crc1) crc2
+        , snapshotTablesCodecVersion = TablesCodecVersion1
+        }
 
 -- | Read snapshot from disk.
 --
@@ -247,7 +310,7 @@ loadSnapshot ::
   , IOLike m
   , LedgerSupportsInMemoryLedgerDB (LedgerState blk)
   ) =>
-  Tracer m V2.FlavorImplSpecificTrace ->
+  Tracer m LedgerDBV2Trace ->
   ResourceRegistry m ->
   CodecConfig blk ->
   SomeHasFS m ->
@@ -273,13 +336,180 @@ loadSnapshot tracer _rr ccfg fs ds = do
               fs
               Identity
               (valuesMKDecoder extLedgerSt)
-              ( fsPathFromList $
-                  fsPathToList (snapshotToDirPath ds)
-                    <> [fromString "tables", fromString "tvar"]
-              )
+              (snapshotToDirPath ds </> mkFsPath ["tables"])
       let computedCRC = crcOfConcat checksumAsRead crcTables
       Monad.when (computedCRC /= snapshotChecksum snapshotMeta) $
         throwE $
           InitFailureRead $
             ReadSnapshotDataCorruption
       (,pt) <$> lift (empty extLedgerSt values (newInMemoryLedgerTablesHandle tracer fs))
+
+type data Mem
+
+instance
+  ( IOLike m
+  , LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  , LedgerSupportsInMemoryLedgerDB (LedgerState blk)
+  ) =>
+  Backend m Mem blk
+  where
+  data Args m Mem = InMemArgs
+  newtype Resources m Mem = Resources (SomeHasFS m)
+    deriving newtype NoThunks
+  newtype Trace m Mem = NoTrace Void
+    deriving newtype Show
+
+  mkResources _ _ _ _ = pure . Resources
+  releaseResources _ _ = pure ()
+  newHandleFromValues tracer _ (Resources shfs) =
+    newInMemoryLedgerTablesHandle tracer shfs . ltprj
+  newHandleFromSnapshot trcr reg ccfg shfs _ ds =
+    loadSnapshot trcr reg ccfg shfs ds
+  snapshotManager _ _ =
+    Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory.snapshotManager
+
+-- | Create arguments for initializing the LedgerDB using the InMemory backend.
+mkInMemoryArgs ::
+  ( IOLike m
+  , LedgerDbSerialiseConstraints blk
+  , LedgerSupportsProtocol blk
+  , LedgerSupportsInMemoryLedgerDB (LedgerState blk)
+  ) =>
+  a -> (LedgerDbBackendArgs m blk, a)
+mkInMemoryArgs = (,) $ LedgerDbBackendArgsV2 $ SomeBackendArgs InMemArgs
+
+instance IOLike m => StreamingBackend m Mem l where
+  data YieldArgs m Mem l
+    = -- \| Yield an in-memory snapshot
+      YieldInMemory
+        -- \| How to make a SomeHasFS for @m@
+        (MountPoint -> SomeHasFS m)
+        -- \| The file path at which the HasFS has to be opened
+        FilePath
+        (Decoders l)
+
+  data SinkArgs m Mem l
+    = SinkInMemory
+        Int
+        (TxIn l -> Encoding)
+        (TxOut l -> Encoding)
+        (SomeHasFS m)
+        FilePath
+
+  yield _ (YieldInMemory mkFs fp (Decoders decK decV)) =
+    yieldInMemoryS mkFs fp decK decV
+
+  sink _ (SinkInMemory chunkSize encK encV shfs fp) =
+    sinkInMemoryS chunkSize encK encV shfs fp
+
+{-------------------------------------------------------------------------------
+  Streaming
+-------------------------------------------------------------------------------}
+
+streamingFile ::
+  forall m.
+  MonadThrow m =>
+  SomeHasFS m ->
+  FsPath ->
+  ( Stream (Of ByteString) m (Maybe CRC) ->
+    ExceptT DeserialiseFailure m (Stream (Of ByteString) m (Maybe CRC, Maybe CRC))
+  ) ->
+  ExceptT DeserialiseFailure m (Maybe CRC, Maybe CRC)
+streamingFile (SomeHasFS fs') path cont =
+  ExceptT $ withFile fs' path ReadMode $ \hdl ->
+    runExceptT $ cont (getBS hdl initCRC) >>= noRemainingBytes
+ where
+  getBS h !crc = do
+    bs <- S.lift $ hGetSome fs' h (fromIntegral defaultChunkSize)
+    if BS.null bs
+      then pure (Just crc)
+      else do
+        S.yield bs
+        getBS h $! updateCRC bs crc
+
+  noRemainingBytes s =
+    lift (S.uncons s) >>= \case
+      Nothing -> lift $ S.effects s
+      Just (BS.null -> True, s') -> noRemainingBytes s'
+      Just _ -> throwError $ DeserialiseFailure 0 "Remaining bytes"
+
+yieldCborMapS ::
+  forall m a b.
+  MonadST m =>
+  (forall s. Decoder s a) ->
+  (forall s. Decoder s b) ->
+  Stream (Of ByteString) m (Maybe CRC) ->
+  Stream (Of (a, b)) (ExceptT DeserialiseFailure m) (Stream (Of ByteString) m (Maybe CRC))
+yieldCborMapS decK decV = execStateT $ do
+  hoist lift (decodeCbor decodeListLen >> decodeCbor decodeMapLenOrIndef) >>= \case
+    Nothing -> go
+    Just n -> replicateM_ n yieldKV
+ where
+  yieldKV = do
+    kv <- hoist lift $ decodeCbor $ (,) <$> decK <*> decV
+    lift $ S.yield kv
+
+  go = do
+    doBreak <- hoist lift $ decodeCbor decodeBreakOr
+    unless doBreak $ yieldKV *> go
+
+  decodeCbor dec =
+    StateT $ \s -> go' s =<< lift (stToIO (deserialiseIncremental dec))
+   where
+    go' s = \case
+      Partial k ->
+        lift (S.next s) >>= \case
+          Right (bs, s') -> go' s' =<< lift (stToIO (k (Just bs)))
+          Left r -> go' (pure r) =<< lift (stToIO (k Nothing))
+      Codec.CBOR.Read.Done bs _off a -> pure (a, S.yield bs *> s)
+      Codec.CBOR.Read.Fail _bs _off err -> throwError err
+
+yieldInMemoryS ::
+  (MonadThrow m, MonadST m) =>
+  (MountPoint -> SomeHasFS m) ->
+  FilePath ->
+  (forall s. Decoder s (TxIn l)) ->
+  (forall s. Decoder s (TxOut l)) ->
+  Yield m l
+yieldInMemoryS mkFs (F.splitFileName -> (fp, fn)) decK decV _ k =
+  streamingFile (mkFs $ MountPoint fp) (mkFsPath [fn]) $ \s -> do
+    k $ yieldCborMapS decK decV s
+
+sinkInMemoryS ::
+  forall m l.
+  MonadThrow m =>
+  Int ->
+  (TxIn l -> Encoding) ->
+  (TxOut l -> Encoding) ->
+  SomeHasFS m ->
+  FilePath ->
+  Sink m l
+sinkInMemoryS writeChunkSize encK encV (SomeHasFS fs) fp _ s =
+  ExceptT $ withFile fs (mkFsPath [fp]) (WriteMode MustBeNew) $ \hdl -> do
+    let bs = toStrictByteString (encodeListLen 1 <> encodeMapLenIndef)
+    let !crc0 = updateCRC bs initCRC
+    void $ hPutSome fs hdl bs
+    e <- runExceptT $ go hdl crc0 writeChunkSize mempty s
+    case e of
+      Left err -> pure $ Left err
+      Right (r, crc1) -> do
+        let bs1 = toStrictByteString encodeBreak
+        void $ hPutSome fs hdl bs1
+        let !crc2 = updateCRC bs1 crc1
+        pure $ Right (fmap (,Just crc2) r)
+ where
+  go tb !crc 0 m s' = do
+    let bs = toStrictByteString $ mconcat [encK k <> encV v | (k, v) <- reverse m]
+    lift $ void $ hPutSome fs tb bs
+    let !crc1 = updateCRC bs crc
+    go tb crc1 writeChunkSize mempty s'
+  go tb !crc n m s' = do
+    mbs <- S.uncons s'
+    case mbs of
+      Nothing -> do
+        let bs = toStrictByteString $ mconcat [encK k <> encV v | (k, v) <- reverse m]
+        lift $ void $ hPutSome fs tb bs
+        let !crc1 = updateCRC bs crc
+        (,crc1) <$> S.effects s'
+      Just (item, s'') -> go tb crc (n - 1) (item : m) s''
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/LedgerSeq.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/LedgerSeq.hs
index a92244b64..774c35b5e 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/LedgerSeq.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/LedgerDB/V2/LedgerSeq.hs
@@ -80,22 +80,54 @@ import Prelude hiding (read)
   LedgerTablesHandles
 -------------------------------------------------------------------------------}
 
+-- | The interface fulfilled by handles on both the InMemory and LSM handles.
 data LedgerTablesHandle m l = LedgerTablesHandle
   { close :: !(m ())
   , duplicate :: !(m (LedgerTablesHandle m l))
-  -- ^ It is expected that this operation takes constant time.
-  , read :: !(LedgerTables l KeysMK -> m (LedgerTables l ValuesMK))
-  , readRange :: !((Maybe (TxIn l), Int) -> m (LedgerTables l ValuesMK, Maybe (TxIn l)))
-  , readAll :: !(m (LedgerTables l ValuesMK))
+  -- ^ Create a copy of the handle.
+  --
+  -- A duplicated handle must provide access to all the data that was there in
+  -- the original handle while being able to mutate in ways different than the
+  -- original handle.
+  --
+  -- When applying diffs to a table, we will first duplicate the handle, then
+  -- apply the diffs in the copy. It is expected that duplicating the handle
+  -- takes constant time.
+  , read :: !(l EmptyMK -> LedgerTables l KeysMK -> m (LedgerTables l ValuesMK))
+  -- ^ Read values for the given keys from the tables, and deserialize them as
+  -- if they were from the same era as the given ledger state.
+  , readRange :: !(l EmptyMK -> (Maybe (TxIn l), Int) -> m (LedgerTables l ValuesMK, Maybe (TxIn l)))
+  -- ^ Read the requested number of values, possibly starting from the given
+  -- key, from the tables, and deserialize them as if they were from the same
+  -- era as the given ledger state.
+  --
+  -- The returned value contains both the read values as well as the last key
+  -- retrieved. This is necessary in case the backend uses a serialization
+  -- format such that the order in the store (which will be used when reading)
+  -- might not match the order in a Haskell @Map@ (induced by @Ord@), so the
+  -- backend must tell which key it read last (if any).
+  --
+  -- The last key retrieved is part of the map too. It is intended to be fed
+  -- back into the next iteration of the range read. If the function returns
+  -- Nothing, it means the read returned no results, or in other words, we
+  -- reached the end of the ledger tables.
+  , readAll :: !(l EmptyMK -> m (LedgerTables l ValuesMK))
   -- ^ Costly read all operation, not to be used in Consensus but only in
-  -- snapshot-converter executable.
+  -- snapshot-converter executable. The values will be read as if they were from
+  -- the same era as the given ledger state.
   , pushDiffs :: !(forall mk. l mk -> l DiffMK -> m ())
   -- ^ Push some diffs into the ledger tables handle.
   --
   -- The first argument has to be the ledger state before applying
   -- the block, the second argument should be the ledger state after
   -- applying a block. See 'CanUpgradeLedgerTables'.
+  --
+  -- Note 'CanUpgradeLedgerTables' is only used in the InMemory backend.
   , takeHandleSnapshot :: !(l EmptyMK -> String -> m (Maybe CRC))
+  -- ^ Take a snapshot of a handle. The given ledger state is used to decide the
+  -- encoding of the values based on the current era.
+  --
+  -- It returns a CRC only on backends that support it, as the InMemory backend.
   , tablesSize :: !(m (Maybe Int))
   -- ^ Consult the size of the ledger tables in the database. This will return
   -- 'Nothing' in backends that do not support this operation.
@@ -167,8 +199,8 @@ empty ::
   , IOLike m
   ) =>
   l EmptyMK ->
-  LedgerTables l ValuesMK ->
-  (LedgerTables l ValuesMK -> m (LedgerTablesHandle m l)) ->
+  init ->
+  (init -> m (LedgerTablesHandle m l)) ->
   m (LedgerSeq m l)
 empty st tbs new = LedgerSeq . AS.Empty . StateRef st <$> new tbs
 
@@ -179,9 +211,9 @@ empty' ::
   , HasLedgerTables l
   ) =>
   l ValuesMK ->
-  (LedgerTables l ValuesMK -> m (LedgerTablesHandle m l)) ->
+  (l ValuesMK -> m (LedgerTablesHandle m l)) ->
   m (LedgerSeq m l)
-empty' st = empty (forgetLedgerTables st) (ltprj st)
+empty' st = empty (forgetLedgerTables st) st
 
 -- | Close all 'LedgerTablesHandle' in this 'LedgerSeq', in particular that on
 -- the anchor.
@@ -221,7 +253,7 @@ reapplyBlock evs cfg b _rr db = do
   let ks = getBlockKeySets b
       StateRef st tbs = currentHandle db
   newtbs <- duplicate tbs
-  vals <- read newtbs ks
+  vals <- read newtbs st ks
   let st' = tickThenReapply evs cfg b (st `withLedgerTables` vals)
       newst = forgetLedgerTables st'
 
@@ -527,7 +559,7 @@ volatileStatesBimap f g =
 -- >>> instance LedgerTablesAreTrivial LS where convertMapKind (LS p) = LS p
 -- >>> s = [LS (Point Origin), LS (Point (At (Block 0 0))), LS (Point (At (Block 1 1))), LS (Point (At (Block 2 2))), LS (Point (At (Block 3 3)))]
 -- >>> [l0s, l1s, l2s, l3s, l4s] = s
--- >>> emptyHandle = LedgerTablesHandle (pure ()) (pure emptyHandle) (\_ -> undefined) (\_ -> undefined) (pure trivialLedgerTables) (\_ _ _ -> undefined) (\_ -> undefined) (pure Nothing)
+-- >>> emptyHandle = LedgerTablesHandle (pure ()) (pure emptyHandle) (\_ -> undefined) (\_ -> undefined) (\_ -> pure trivialLedgerTables) (\_ _ _ -> undefined) (\_ -> undefined) (pure Nothing)
 -- >>> [l0, l1, l2, l3, l4] = map (flip StateRef emptyHandle) s
 -- >>> instance GetTip LS where getTip (LS p) = p
 -- >>> instance Eq (LS EmptyMK) where LS p1 == LS p2 = p1 == p2
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB.hs
new file mode 100644
index 000000000..288039b30
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB.hs
@@ -0,0 +1,4 @@
+module Ouroboros.Consensus.Storage.PerasCertDB (module X) where
+
+import Ouroboros.Consensus.Storage.PerasCertDB.API as X
+import Ouroboros.Consensus.Storage.PerasCertDB.Impl as X
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/API.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/API.hs
new file mode 100644
index 000000000..873ebe29f
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/API.hs
@@ -0,0 +1,67 @@
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+module Ouroboros.Consensus.Storage.PerasCertDB.API
+  ( PerasCertDB (..)
+  , AddPerasCertResult (..)
+
+    -- * 'PerasCertSnapshot'
+  , PerasCertSnapshot (..)
+  , PerasCertTicketNo
+  , zeroPerasCertTicketNo
+  ) where
+
+import Data.Map (Map)
+import Data.Word (Word64)
+import NoThunks.Class
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.STM (WithFingerprint (..))
+
+data PerasCertDB m blk = PerasCertDB
+  { addCert :: ValidatedPerasCert blk -> m AddPerasCertResult
+  -- ^ Add a Peras certificate to the database. The result indicates whether
+  -- the certificate was actually added, or if it was already present.
+  , getWeightSnapshot :: STM m (WithFingerprint (PerasWeightSnapshot blk))
+  -- ^ Return the Peras weights in order compare the current selection against
+  -- potential candidate chains, namely the weights for blocks not older than
+  -- the current immutable tip. It might contain weights for even older blocks
+  -- if they have not yet been garbage-collected.
+  --
+  -- The 'Fingerprint' is updated every time a new certificate is added, but it
+  -- stays the same when certificates are garbage-collected.
+  , getCertSnapshot :: STM m (PerasCertSnapshot blk)
+  , garbageCollect :: SlotNo -> m ()
+  -- ^ Garbage-collect state older than the given slot number.
+  , closeDB :: m ()
+  }
+  deriving NoThunks via OnlyCheckWhnfNamed "PerasCertDB" (PerasCertDB m blk)
+
+data AddPerasCertResult = AddedPerasCertToDB | PerasCertAlreadyInDB
+  deriving stock (Show, Eq)
+
+data PerasCertSnapshot blk = PerasCertSnapshot
+  { containsCert :: PerasRoundNo -> Bool
+  -- ^ Do we have the certificate for this round?
+  , getCertsAfter :: PerasCertTicketNo -> Map PerasCertTicketNo (ValidatedPerasCert blk)
+  -- ^ Get certificates after the given ticket number (excluded).
+  -- The result is a map of ticket numbers to validated certificates.
+  }
+
+-- | A sequence number, incremented every time we receive a new certificate.
+--
+-- Note that we will /usually/ receive certificates monotonically by round
+-- number, so round numbers could /almost/ fulfill the role of ticket numbers.
+-- However, in certain edge cases (while catching up, or during cooldowns), this
+-- might not be true, such as during syncing or during cooldown periods.
+-- Therefore, for robustness, we choose to maintain dedicated ticket numbers
+-- separately.
+newtype PerasCertTicketNo = PerasCertTicketNo Word64
+  deriving stock Show
+  deriving newtype (Eq, Ord, Enum, NoThunks)
+
+zeroPerasCertTicketNo :: PerasCertTicketNo
+zeroPerasCertTicketNo = PerasCertTicketNo 0
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/Impl.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/Impl.hs
new file mode 100644
index 000000000..8b8a33c34
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Storage/PerasCertDB/Impl.hs
@@ -0,0 +1,340 @@
+{-# LANGUAGE DataKinds #-}
+{-# LANGUAGE DeriveAnyClass #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneKindSignatures #-}
+
+module Ouroboros.Consensus.Storage.PerasCertDB.Impl
+  ( -- * Opening
+    PerasCertDbArgs (..)
+  , defaultArgs
+  , openDB
+
+    -- * Trace types
+  , TraceEvent (..)
+
+    -- * Exceptions
+  , PerasCertDbError (..)
+  ) where
+
+import Control.Monad (when)
+import Control.Monad.Except (throwError)
+import Control.Tracer (Tracer, nullTracer, traceWith)
+import Data.Foldable (for_)
+import Data.Functor ((<&>))
+import Data.Kind (Type)
+import Data.Map.Strict (Map)
+import qualified Data.Map.Strict as Map
+import qualified Data.Set as Set
+import GHC.Generics (Generic)
+import NoThunks.Class
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight
+import Ouroboros.Consensus.Storage.PerasCertDB.API
+import Ouroboros.Consensus.Util.Args
+import Ouroboros.Consensus.Util.CallStack
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.STM
+
+{------------------------------------------------------------------------------
+  Opening the database
+------------------------------------------------------------------------------}
+
+type PerasCertDbArgs :: (Type -> Type) -> (Type -> Type) -> Type -> Type
+data PerasCertDbArgs f m blk = PerasCertDbArgs
+  { pcdbaTracer :: Tracer m (TraceEvent blk)
+  }
+
+defaultArgs :: Applicative m => Incomplete PerasCertDbArgs m blk
+defaultArgs =
+  PerasCertDbArgs
+    { pcdbaTracer = nullTracer
+    }
+
+openDB ::
+  forall m blk.
+  ( IOLike m
+  , StandardHash blk
+  ) =>
+  Complete PerasCertDbArgs m blk ->
+  m (PerasCertDB m blk)
+openDB args = do
+  pcdbVolatileState <-
+    newTVarWithInvariantIO
+      (either Just (const Nothing) . invariantForPerasVolatileCertState)
+      initialPerasVolatileCertState
+  let env =
+        PerasCertDbEnv
+          { pcdbTracer
+          , pcdbVolatileState
+          }
+  h <- PerasCertDbHandle <$> newTVarIO (PerasCertDbOpen env)
+  traceWith pcdbTracer OpenedPerasCertDB
+  pure
+    PerasCertDB
+      { addCert = getEnv1 h implAddCert
+      , getWeightSnapshot = getEnvSTM h implGetWeightSnapshot
+      , getCertSnapshot = getEnvSTM h implGetCertSnapshot
+      , garbageCollect = getEnv1 h implGarbageCollect
+      , closeDB = implCloseDB h
+      }
+ where
+  PerasCertDbArgs
+    { pcdbaTracer = pcdbTracer
+    } = args
+
+{-------------------------------------------------------------------------------
+  Database state
+-------------------------------------------------------------------------------}
+
+newtype PerasCertDbHandle m blk = PerasCertDbHandle (StrictTVar m (PerasCertDbState m blk))
+
+data PerasCertDbState m blk
+  = PerasCertDbOpen !(PerasCertDbEnv m blk)
+  | PerasCertDbClosed
+  deriving stock Generic
+  deriving anyclass NoThunks
+
+data PerasCertDbEnv m blk = PerasCertDbEnv
+  { pcdbTracer :: !(Tracer m (TraceEvent blk))
+  , pcdbVolatileState :: !(StrictTVar m (WithFingerprint (PerasVolatileCertState blk)))
+  -- ^ The 'RoundNo's of all certificates currently in the db.
+  }
+  deriving NoThunks via OnlyCheckWhnfNamed "PerasCertDbEnv" (PerasCertDbEnv m blk)
+
+getEnv ::
+  (IOLike m, HasCallStack) =>
+  PerasCertDbHandle m blk ->
+  (PerasCertDbEnv m blk -> m r) ->
+  m r
+getEnv (PerasCertDbHandle varState) f =
+  readTVarIO varState >>= \case
+    PerasCertDbOpen env -> f env
+    PerasCertDbClosed -> throwIO $ ClosedDBError prettyCallStack
+
+getEnv1 ::
+  (IOLike m, HasCallStack) =>
+  PerasCertDbHandle m blk ->
+  (PerasCertDbEnv m blk -> a -> m r) ->
+  a ->
+  m r
+getEnv1 h f a = getEnv h (\env -> f env a)
+
+getEnvSTM ::
+  (IOLike m, HasCallStack) =>
+  PerasCertDbHandle m blk ->
+  (PerasCertDbEnv m blk -> STM m r) ->
+  STM m r
+getEnvSTM (PerasCertDbHandle varState) f =
+  readTVar varState >>= \case
+    PerasCertDbOpen env -> f env
+    PerasCertDbClosed -> throwIO $ ClosedDBError prettyCallStack
+
+{-------------------------------------------------------------------------------
+  API implementation
+-------------------------------------------------------------------------------}
+
+implCloseDB :: IOLike m => PerasCertDbHandle m blk -> m ()
+implCloseDB (PerasCertDbHandle varState) =
+  atomically (swapTVar varState PerasCertDbClosed) >>= \case
+    PerasCertDbOpen PerasCertDbEnv{pcdbTracer} -> do
+      traceWith pcdbTracer ClosedPerasCertDB
+    -- DB was already closed.
+    PerasCertDbClosed -> pure ()
+
+-- TODO: we will need to update this method with non-trivial validation logic
+-- see https://github.com/tweag/cardano-peras/issues/120
+implAddCert ::
+  ( IOLike m
+  , StandardHash blk
+  ) =>
+  PerasCertDbEnv m blk ->
+  ValidatedPerasCert blk ->
+  m AddPerasCertResult
+implAddCert env cert = do
+  traceWith pcdbTracer $ AddingPerasCert roundNo boostedPt
+  res <- atomically $ do
+    WithFingerprint
+      PerasVolatileCertState
+        { pvcsCerts
+        , pvcsWeightByPoint
+        , pvcsCertsByTicket
+        , pvcsLastTicketNo
+        }
+      fp <-
+      readTVar pcdbVolatileState
+    if Map.member roundNo pvcsCerts
+      then pure PerasCertAlreadyInDB
+      else do
+        let pvcsLastTicketNo' = succ pvcsLastTicketNo
+        writeTVar pcdbVolatileState $
+          WithFingerprint
+            PerasVolatileCertState
+              { pvcsCerts =
+                  Map.insert roundNo cert pvcsCerts
+              , -- Note that the same block might be boosted by multiple points.
+                pvcsWeightByPoint =
+                  addToPerasWeightSnapshot boostedPt (getPerasCertBoost cert) pvcsWeightByPoint
+              , pvcsCertsByTicket =
+                  Map.insert pvcsLastTicketNo' cert pvcsCertsByTicket
+              , pvcsLastTicketNo = pvcsLastTicketNo'
+              }
+            (succ fp)
+        pure AddedPerasCertToDB
+  traceWith pcdbTracer $ case res of
+    AddedPerasCertToDB -> AddedPerasCert roundNo boostedPt
+    PerasCertAlreadyInDB -> IgnoredCertAlreadyInDB roundNo boostedPt
+  pure res
+ where
+  PerasCertDbEnv
+    { pcdbTracer
+    , pcdbVolatileState
+    } = env
+
+  boostedPt = getPerasCertBoostedBlock cert
+  roundNo = getPerasCertRound cert
+
+implGetWeightSnapshot ::
+  IOLike m =>
+  PerasCertDbEnv m blk -> STM m (WithFingerprint (PerasWeightSnapshot blk))
+implGetWeightSnapshot PerasCertDbEnv{pcdbVolatileState} =
+  fmap pvcsWeightByPoint <$> readTVar pcdbVolatileState
+
+implGetCertSnapshot ::
+  IOLike m =>
+  PerasCertDbEnv m blk -> STM m (PerasCertSnapshot blk)
+implGetCertSnapshot PerasCertDbEnv{pcdbVolatileState} =
+  readTVar pcdbVolatileState
+    <&> forgetFingerprint
+    <&> \PerasVolatileCertState
+           { pvcsCerts
+           , pvcsCertsByTicket
+           } ->
+        PerasCertSnapshot
+          { containsCert = \r -> Map.member r pvcsCerts
+          , getCertsAfter = \ticketNo ->
+              snd $ Map.split ticketNo pvcsCertsByTicket
+          }
+
+implGarbageCollect ::
+  forall m blk.
+  (IOLike m, StandardHash blk) =>
+  PerasCertDbEnv m blk -> SlotNo -> m ()
+implGarbageCollect PerasCertDbEnv{pcdbVolatileState} slot =
+  -- No need to update the 'Fingerprint' as we only remove certificates that do
+  -- not matter for comparing interesting chains.
+  atomically $ modifyTVar pcdbVolatileState (fmap gc)
+ where
+  gc :: PerasVolatileCertState blk -> PerasVolatileCertState blk
+  gc
+    PerasVolatileCertState
+      { pvcsCerts
+      , pvcsWeightByPoint
+      , pvcsLastTicketNo
+      , pvcsCertsByTicket
+      } =
+      PerasVolatileCertState
+        { pvcsCerts = Map.filter keepCert pvcsCerts
+        , pvcsWeightByPoint = prunePerasWeightSnapshot slot pvcsWeightByPoint
+        , pvcsCertsByTicket = Map.filter keepCert pvcsCertsByTicket
+        , pvcsLastTicketNo = pvcsLastTicketNo
+        }
+     where
+      keepCert cert =
+        pointSlot (getPerasCertBoostedBlock cert) >= NotOrigin slot
+
+{-------------------------------------------------------------------------------
+  Implementation-internal types
+-------------------------------------------------------------------------------}
+
+-- | Volatile Peras certificate state, i.e. certificates that could influence
+-- chain selection by boosting a volatile block.
+--
+-- INVARIANT: See 'invariantForPerasVolatileCertState'.
+data PerasVolatileCertState blk = PerasVolatileCertState
+  { pvcsCerts :: !(Map PerasRoundNo (ValidatedPerasCert blk))
+  -- ^ The boosted blocks by 'RoundNo' of all certificates currently in the db.
+  , pvcsWeightByPoint :: !(PerasWeightSnapshot blk)
+  -- ^ The weight of boosted blocks w.r.t. the certificates currently in the db.
+  , pvcsCertsByTicket :: !(Map PerasCertTicketNo (ValidatedPerasCert blk))
+  -- ^ The certificates by 'PerasCertTicketNo'.
+  , pvcsLastTicketNo :: !PerasCertTicketNo
+  -- ^ The most recent 'PerasCertTicketNo' (or 'zeroPerasCertTicketNo'
+  -- otherwise).
+  }
+  deriving stock (Show, Generic)
+  deriving anyclass NoThunks
+
+initialPerasVolatileCertState :: WithFingerprint (PerasVolatileCertState blk)
+initialPerasVolatileCertState =
+  WithFingerprint
+    PerasVolatileCertState
+      { pvcsCerts = Map.empty
+      , pvcsWeightByPoint = emptyPerasWeightSnapshot
+      , pvcsCertsByTicket = Map.empty
+      , pvcsLastTicketNo = zeroPerasCertTicketNo
+      }
+    (Fingerprint 0)
+
+-- | Check that the fields of 'PerasVolatileCertState' are in sync.
+invariantForPerasVolatileCertState ::
+  forall blk.
+  StandardHash blk =>
+  WithFingerprint (PerasVolatileCertState blk) -> Either String ()
+invariantForPerasVolatileCertState pvcs = do
+  for_ (Map.toList pvcsCerts) $ \(roundNo, vpc) ->
+    checkEqual "pvcsCerts rounds" roundNo (getPerasCertRound vpc)
+  checkEqual "pvcsWeightByPoint" pvcsWeightByPoint expectedWeightByPoint
+  checkEqual
+    "pvcsCertsByTicket"
+    (Set.fromList (getPerasCertRound <$> Map.elems pvcsCertsByTicket))
+    (Set.fromList (getPerasCertRound <$> Map.elems pvcsCerts))
+  for_ (Map.keys pvcsCertsByTicket) $ \ticketNo ->
+    when (ticketNo > pvcsLastTicketNo) $
+      throwError $
+        "Ticket number monotonicity violation: "
+          <> show ticketNo
+          <> " > "
+          <> show pvcsLastTicketNo
+ where
+  PerasVolatileCertState _ _ _ _keep = forgetFingerprint pvcs
+  PerasVolatileCertState
+    { pvcsCerts
+    , pvcsWeightByPoint
+    , pvcsCertsByTicket
+    , pvcsLastTicketNo
+    } = forgetFingerprint pvcs
+
+  checkEqual :: (Eq a, Show a) => String -> a -> a -> Either String ()
+  checkEqual msg a b =
+    when (a /= b) $ throwError $ msg <> ": Not equal: " <> show a <> ", " <> show b
+
+  expectedWeightByPoint =
+    mkPerasWeightSnapshot
+      [ (getPerasCertBoostedBlock vpc, getPerasCertBoost vpc)
+      | vpc <- Map.elems pvcsCerts
+      ]
+
+{-------------------------------------------------------------------------------
+  Trace types
+-------------------------------------------------------------------------------}
+
+data TraceEvent blk
+  = OpenedPerasCertDB
+  | ClosedPerasCertDB
+  | AddingPerasCert PerasRoundNo (Point blk)
+  | AddedPerasCert PerasRoundNo (Point blk)
+  | IgnoredCertAlreadyInDB PerasRoundNo (Point blk)
+  deriving stock (Show, Eq, Generic)
+
+{-------------------------------------------------------------------------------
+  Exceptions
+-------------------------------------------------------------------------------}
+
+data PerasCertDbError
+  = ClosedDBError PrettyCallStack
+  deriving stock Show
+  deriving anyclass Exception
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util.hs
index 57e53aa12..734569a90 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util.hs
@@ -1,4 +1,5 @@
 {-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
@@ -13,6 +14,7 @@
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE StandaloneKindSignatures #-}
+{-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE UndecidableInstances #-}
 
 -- | Miscellaneous utilities
@@ -94,6 +96,10 @@ module Ouroboros.Consensus.Util
 
     -- * Type-safe boolean flags
   , Flag (..)
+
+    -- * Unsafe coercions or maps
+  , coerceMapKeys
+  , coerceSet
   ) where
 
 import Cardano.Crypto.Hash
@@ -108,6 +114,7 @@ import Control.Monad.Trans.Class
 import qualified Data.ByteString as Strict
 import qualified Data.ByteString.Lazy as Lazy
 import Data.ByteString.Short (ShortByteString)
+import Data.Coerce
 import Data.Foldable (asum, toList)
 import Data.Function (on)
 import Data.Functor.Identity
@@ -115,7 +122,9 @@ import Data.Functor.Product
 import Data.Kind (Type)
 import Data.List as List (foldl', maximumBy)
 import Data.List.NonEmpty (NonEmpty (..), (<|))
+import Data.Map (Map)
 import Data.Maybe (fromMaybe)
+import Data.Proxy
 import Data.Set (Set)
 import qualified Data.Set as Set
 import Data.Text (Text)
@@ -125,8 +134,10 @@ import GHC.Generics (Generic)
 import GHC.Stack
 import GHC.TypeLits (Symbol)
 import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.RedundantConstraints
 import Ouroboros.Network.Protocol.LocalStateQuery.Codec (Some (..))
 import Ouroboros.Network.Util.ShowProxy (ShowProxy (..))
+import Unsafe.Coerce
 
 {-------------------------------------------------------------------------------
   Type-level utility
@@ -505,3 +516,33 @@ newtype FuseBlownException = FuseBlownException Text
 -- for an example.
 newtype Flag (name :: Symbol) = Flag {getFlag :: Bool}
   deriving (Eq, Show, Generic)
+
+{-------------------------------------------------------------------------------
+  Unsafe coercions from maps
+-------------------------------------------------------------------------------}
+
+#if __GLASGOW_HASKELL__ >= 908
+{-# WARNING in "x-ord-preserving-coercions"
+  coerceMapKeys
+  [ "This function expects the types of the keys to have exactly the same Ord ordering."
+  , "If you are certain this is the case, ignore this warning with `-Wno-x-ord-preserving-coercions`."
+  ]
+  #-}
+#endif
+coerceMapKeys :: forall k1 k2 v. Coercible k1 k2 => Map k1 v -> Map k2 v
+coerceMapKeys = unsafeCoerce
+ where
+  _ = keepRedundantConstraint (Proxy @(Coercible k1 k2))
+
+#if __GLASGOW_HASKELL__ >= 908
+{-# WARNING in "x-ord-preserving-coercions"
+  coerceSet
+  [ "This function expects the types of the keys to have exactly the same Ord ordering."
+  , "If you are certain this is the case, ignore this warning with `-Wno-x-ord-preserving-coercions`."
+  ]
+  #-}
+#endif
+coerceSet :: forall k1 k2. Coercible k1 k2 => Set k1 -> Set k2
+coerceSet = unsafeCoerce
+ where
+  _ = keepRedundantConstraint (Proxy @(Coercible k1 k2))
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredFragment.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredFragment.hs
index cfcb5c305..7a82c4622 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredFragment.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredFragment.hs
@@ -10,7 +10,7 @@ module Ouroboros.Consensus.Util.AnchoredFragment
   ( compareAnchoredFragments
   , compareHeadBlockNo
   , cross
-  , forksAtMostKBlocks
+  , forksAtMostKWeight
   , preferAnchoredCandidate
   , stripCommonPrefix
   ) where
@@ -21,9 +21,10 @@ import qualified Data.Foldable1 as F1
 import Data.Function (on)
 import qualified Data.List.NonEmpty as NE
 import Data.Maybe (isJust)
-import Data.Word (Word64)
 import GHC.Stack
 import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.SelectView
+import Ouroboros.Consensus.Peras.Weight
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Util.Assert
 import Ouroboros.Network.AnchoredFragment
@@ -59,76 +60,96 @@ compareHeadBlockNo ::
   Ordering
 compareHeadBlockNo = compare `on` AF.headBlockNo
 
-forksAtMostKBlocks ::
-  HasHeader b =>
-  -- | How many blocks can it fork?
-  Word64 ->
-  -- | Our chain.
+-- | Check that we can switch from @ours@ to @theirs@ by rolling back our chain
+-- by at most @k@ weight.
+--
+-- If @ours@ and @cand@ do not intersect, this returns 'False'. If they do
+-- intersect, then we check that the suffix of @ours@ after the intersection has
+-- total weight at most @k@.
+forksAtMostKWeight ::
+  ( StandardHash blk
+  , HasHeader b
+  , HeaderHash blk ~ HeaderHash b
+  ) =>
+  PerasWeightSnapshot blk ->
+  -- | By how much weight can we roll back our chain at most?
+  PerasWeight ->
+  -- | Our chain @ours@.
   AnchoredFragment b ->
-  -- | Their chain
+  -- | Their chain @theirs@.
   AnchoredFragment b ->
-  -- | Indicates whether their chain forks at most the
-  -- specified number of blocks.
+  -- | Indicates whether their chain forks at most the given the amount of
+  -- weight. Returns 'False' if the two fragments do not intersect.
   Bool
-forksAtMostKBlocks k ours theirs = case ours `AF.intersect` theirs of
-  Nothing -> False
-  Just (_, _, ourSuffix, _) -> fromIntegral (AF.length ourSuffix) <= k
+forksAtMostKWeight weights maxWeight ours theirs =
+  case ours `AF.intersect` theirs of
+    Nothing -> False
+    Just (_, _, ourSuffix, _) ->
+      totalWeightOfFragment weights ourSuffix <= maxWeight
 
 -- | Compare two (potentially empty!) 'AnchoredFragment's.
 --
--- PRECONDITION: Either both fragments are non-empty or they intersect.
---
--- For a detailed discussion of this precondition, and a justification for the
--- definition of this function, please refer to the Consensus Report.
+-- PRECONDITION: The fragments must intersect.
 --
 -- Usage note: the primary user of this function is the chain database when
 -- sorting fragments that are preferred over our selection. It establishes the
 -- precondition in the following way: It will only compare candidate fragments
--- that it has previously verified are preferable to our current chain.
--- Therefore, they are non-empty, as an empty fragment anchored in our chain can
--- never be preferable to our chain.
+-- that it has previously verified are preferable to our current chain. Since
+-- these fragments intersect with our current chain, we can enlarge them to all
+-- be anchored in the immutable tip. Therefore, they intersect pairwise.
 compareAnchoredFragments ::
   forall blk h.
   ( BlockSupportsProtocol blk
   , HasCallStack
   , GetHeader1 h
   , HasHeader (h blk)
+  , HeaderHash (h blk) ~ HeaderHash blk
   ) =>
   BlockConfig blk ->
+  PerasWeightSnapshot blk ->
   AnchoredFragment (h blk) ->
   AnchoredFragment (h blk) ->
   Ordering
-compareAnchoredFragments cfg frag1 frag2 =
-  assertWithMsg (precondition frag1 frag2) $
-    case (frag1, frag2) of
-      (Empty _, Empty _) ->
-        -- The fragments intersect but are equal: their anchors must be equal,
-        -- and hence the fragments represent the same chain. They are therefore
-        -- equally preferable.
-        EQ
-      (Empty anchor, _ :> tip') ->
-        -- Since the fragments intersect, but the first one is empty, its anchor
-        -- must lie somewhere along the the second. If it is the tip, the two
-        -- fragments represent the same chain and are equally preferable. If
-        -- not, the second chain is a strict extension of the first and is
-        -- therefore strictly preferable.
-        if blockPoint tip' == AF.castPoint (AF.anchorToPoint anchor)
-          then EQ
-          else LT
-      (_ :> tip, Empty anchor') ->
-        -- This case is symmetric to the previous
-        if blockPoint tip == AF.castPoint (AF.anchorToPoint anchor')
-          then EQ
-          else GT
-      (_ :> tip, _ :> tip') ->
-        -- Case 4
-        compare
-          (selectView cfg (getHeader1 tip))
-          (selectView cfg (getHeader1 tip'))
+compareAnchoredFragments cfg weights frag1 frag2
+  -- Optimize the case where Peras is disabled.
+  | isEmptyPerasWeightSnapshot weights =
+      assertWithMsg (precondition frag1 frag2) $
+        case (frag1, frag2) of
+          (Empty _, Empty _) ->
+            -- The fragments intersect but are equal: their anchors must be equal,
+            -- and hence the fragments represent the same chain. They are therefore
+            -- equally preferable.
+            EQ
+          (Empty anchor, _ :> tip') ->
+            -- Since the fragments intersect, but the first one is empty, its anchor
+            -- must lie somewhere along the the second. If it is the tip, the two
+            -- fragments represent the same chain and are equally preferable. If
+            -- not, the second chain is a strict extension of the first and is
+            -- therefore strictly preferable.
+            if blockPoint tip' == AF.castPoint (AF.anchorToPoint anchor)
+              then EQ
+              else LT
+          (_ :> tip, Empty anchor') ->
+            -- This case is symmetric to the previous
+            if blockPoint tip == AF.castPoint (AF.anchorToPoint anchor')
+              then EQ
+              else GT
+          (_ :> tip, _ :> tip') ->
+            -- Case 4
+            compare
+              (selectView cfg (getHeader1 tip))
+              (selectView cfg (getHeader1 tip'))
+  | otherwise =
+      case AF.intersect frag1 frag2 of
+        Nothing -> error "precondition violated: fragments must intersect"
+        Just (_oursPrefix, _candPrefix, oursSuffix, candSuffix) ->
+          compare
+            (weightedSelectView cfg weights oursSuffix)
+            (weightedSelectView cfg weights candSuffix)
 
 -- | Lift 'preferCandidate' to 'AnchoredFragment'
 --
--- PRECONDITION: Either both fragments are non-empty or they intersect.
+-- PRECONDITION: The fragments must intersect.
 --
 -- Usage note: the primary user of this function is the chain database. It
 -- establishes the precondition when comparing a candidate fragment to our
@@ -142,27 +163,39 @@ preferAnchoredCandidate ::
   , HasCallStack
   , GetHeader1 h
   , GetHeader1 h'
+  , HeaderHash (h blk) ~ HeaderHash blk
   , HeaderHash (h blk) ~ HeaderHash (h' blk)
   , HasHeader (h blk)
   , HasHeader (h' blk)
   ) =>
   BlockConfig blk ->
+  -- | Peras weights used to judge this chain.
+  PerasWeightSnapshot blk ->
   -- | Our chain
   AnchoredFragment (h blk) ->
   -- | Candidate
   AnchoredFragment (h' blk) ->
   Bool
-preferAnchoredCandidate cfg ours cand =
-  assertWithMsg (precondition ours cand) $
-    case (ours, cand) of
-      (_, Empty _) -> False
-      (Empty ourAnchor, _ :> theirTip) ->
-        blockPoint theirTip /= castPoint (AF.anchorToPoint ourAnchor)
-      (_ :> ourTip, _ :> theirTip) ->
-        preferCandidate
-          (projectChainOrderConfig cfg)
-          (selectView cfg (getHeader1 ourTip))
-          (selectView cfg (getHeader1 theirTip))
+preferAnchoredCandidate cfg weights ours cand
+  | isEmptyPerasWeightSnapshot weights =
+      assertWithMsg (precondition ours cand) $
+        case (ours, cand) of
+          (_, Empty _) -> False
+          (Empty ourAnchor, _ :> theirTip) ->
+            blockPoint theirTip /= castPoint (AF.anchorToPoint ourAnchor)
+          (_ :> ourTip, _ :> theirTip) ->
+            preferCandidate
+              (projectChainOrderConfig cfg)
+              (selectView cfg (getHeader1 ourTip))
+              (selectView cfg (getHeader1 theirTip))
+  | otherwise =
+      case AF.intersect ours cand of
+        Nothing -> error "precondition violated: fragments must intersect"
+        Just (_oursPrefix, _candPrefix, oursSuffix, candSuffix) ->
+          preferCandidate
+            (projectChainOrderConfig cfg)
+            (weightedSelectView cfg weights oursSuffix)
+            (weightedSelectView cfg weights candSuffix)
 
 -- For 'compareAnchoredFragment' and 'preferAnchoredCandidate'.
 precondition ::
@@ -174,9 +207,6 @@ precondition ::
   AnchoredFragment (h' blk) ->
   Either String ()
 precondition frag1 frag2
-  | not (AF.null frag1)
-  , not (AF.null frag2) =
-      return ()
   | isJust (AF.intersectionPoint frag1 frag2) =
       return ()
   | otherwise =
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredSeq.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredSeq.hs
new file mode 100644
index 000000000..06a74fd45
--- /dev/null
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/AnchoredSeq.hs
@@ -0,0 +1,64 @@
+{-# LANGUAGE ScopedTypeVariables #-}
+
+-- | Utilities on 'AnchoredSeq's.
+module Ouroboros.Consensus.Util.AnchoredSeq
+  ( takeLongestSuffix
+  ) where
+
+import Data.Maybe (fromMaybe)
+import Ouroboros.Network.AnchoredSeq (AnchoredSeq)
+import qualified Ouroboros.Network.AnchoredSeq as AS
+
+-- | Take the longest suffix of an 'AnchoredSeq' @as@ satisfying the given
+-- predicate @p@ on the monoidal summary given by @f@.
+--
+-- TODO: upstream this function
+--
+-- === PRECONDITIONS:
+--
+-- For @as0, as1@ such that @AS.join as0 as1 = Just as2@, we must have the
+-- following homomorphism property:
+--
+-- > f as0 <> f as1 ≡ f as2
+--
+-- For empty @ase@, we must have @f ase ≡ mempty@.
+--
+-- The predicate must be monotonic, ie when @suf0@ is a suffix of @as@ and
+-- @suf1@ is a suffix of @suf0@, then @p (f suf0)@ must imply @p (f suf1)@.
+-- Furthermore, we must have @p mempty@.
+takeLongestSuffix ::
+  forall s v a b.
+  (Monoid s, AS.Anchorable v a b) =>
+  -- | @f@: Compute a monoidal summary of a fragment.
+  (AnchoredSeq v a b -> s) ->
+  -- | @p@: Predicate on the summary of a fragment.
+  (s -> Bool) ->
+  -- | Input sequence @as@.
+  AnchoredSeq v a b ->
+  -- | A suffix of the input sequence.
+  AnchoredSeq v a b
+takeLongestSuffix f p as =
+  go (AS.Empty $ AS.headAnchor as) mempty as
+ where
+  go ::
+    -- @suf@: the longest suffix of @as@ for which we currently know that @p (f
+    -- suf)@.
+    AnchoredSeq v a b ->
+    -- Equal to @f suf@.
+    s ->
+    -- @pre@: longest infix of @as@ ending just before @suf@ such that we don't
+    -- know whether @p (f (AS.join pre suf))@.
+    AnchoredSeq v a b ->
+    -- Longest suffix of @as@ satisfying @p . f@.
+    AnchoredSeq v a b
+  go suf sufS pre
+    | AS.null pre = suf
+    | p suf'S = go suf' suf'S pre0
+    | AS.null pre0 = suf
+    | otherwise = go suf sufS pre1
+   where
+    (pre0, pre1) = AS.splitAt (AS.length pre `div` 2) pre
+    suf' =
+      fromMaybe (error "takeLongestSuffix: internal invariant violation") $
+        AS.join (\_ _ -> True) pre1 suf
+    suf'S = f pre1 <> sufS
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/EarlyExit.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/EarlyExit.hs
index 4eba0f7c8..7f9b5905e 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/EarlyExit.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/EarlyExit.hs
@@ -374,6 +374,7 @@ instance MonadSay m => MonadSay (WithEarlyExit m) where
 
 instance (MonadInspectSTM m, Monad (InspectMonadSTM m)) => MonadInspectSTM (WithEarlyExit m) where
   type InspectMonadSTM (WithEarlyExit m) = InspectMonadSTM m
+
   inspectTVar _ = inspectTVar (Proxy @m)
   inspectTMVar _ = inspectTMVar (Proxy @m)
 
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/IndexedMemPack.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/IndexedMemPack.hs
index 22939e57c..ae972120f 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/IndexedMemPack.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/IndexedMemPack.hs
@@ -14,12 +14,17 @@ module Ouroboros.Consensus.Util.IndexedMemPack
   ( IndexedMemPack (..)
   , MemPack (..)
   , indexedPackByteString
+  , indexedPackByteArray
   , indexedUnpackError
+  , indexedUnpackEither
+  , unpackEither
   ) where
 
 import qualified Control.Monad as Monad
-import Control.Monad.Trans.Fail (Fail, errorFail, failT)
+import Control.Monad.ST
+import Control.Monad.Trans.Fail
 import Data.Array.Byte (ByteArray (..))
+import Data.Bifunctor (first)
 import Data.ByteString
 import Data.MemPack
 import Data.MemPack.Buffer
@@ -30,7 +35,7 @@ import GHC.Stack
 class IndexedMemPack idx a where
   indexedPackedByteCount :: idx -> a -> Int
   indexedPackM :: idx -> a -> Pack s ()
-  indexedUnpackM :: Buffer b => idx -> Unpack b a
+  indexedUnpackM :: Buffer b => forall s. idx -> Unpack s b a
   indexedTypeName :: idx -> String
 
 indexedPackByteString ::
@@ -71,12 +76,30 @@ indexedUnpackFail idx b = do
 indexedUnpackLeftOver ::
   forall idx a b.
   (IndexedMemPack idx a, Buffer b, HasCallStack) => idx -> b -> Fail SomeError (a, Int)
-indexedUnpackLeftOver idx b = do
+indexedUnpackLeftOver idx b = FailT $ pure $ runST $ runFailAggT $ indexedUnpackLeftOverST idx b
+{-# INLINEABLE indexedUnpackLeftOver #-}
+
+indexedUnpackLeftOverST ::
+  forall idx a b s.
+  (IndexedMemPack idx a, Buffer b, HasCallStack) => idx -> b -> FailT SomeError (ST s) (a, Int)
+indexedUnpackLeftOverST idx b = do
   let len = bufferByteCount b
   res@(_, consumedBytes) <- runStateT (runUnpack (indexedUnpackM idx) b) 0
   Monad.when (consumedBytes > len) $ errorLeftOver (indexedTypeName @idx @a idx) consumedBytes len
   pure res
-{-# INLINEABLE indexedUnpackLeftOver #-}
+{-# INLINEABLE indexedUnpackLeftOverST #-}
+
+indexedUnpackEither ::
+  forall idx a b.
+  (IndexedMemPack idx a, Buffer b, HasCallStack) => idx -> b -> Either SomeError a
+indexedUnpackEither idx = first fromMultipleErrors . runFailAgg . indexedUnpackFail idx
+{-# INLINEABLE indexedUnpackEither #-}
+
+unpackEither ::
+  forall a b.
+  (MemPack a, Buffer b, HasCallStack) => b -> Either SomeError a
+unpackEither = first fromMultipleErrors . runFailAgg . unpackFail
+{-# INLINEABLE unpackEither #-}
 
 errorLeftOver :: HasCallStack => String -> Int -> Int -> a
 errorLeftOver name consumedBytes len =
diff --git a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/STM.hs b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/STM.hs
index 9130e3bee..e3f23eace 100644
--- a/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/STM.hs
+++ b/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/STM.hs
@@ -1,9 +1,5 @@
-{-# LANGUAGE DeriveAnyClass #-}
-{-# LANGUAGE DeriveFunctor #-}
-{-# LANGUAGE DeriveGeneric #-}
 {-# LANGUAGE DerivingStrategies #-}
 {-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
@@ -12,6 +8,8 @@ module Ouroboros.Consensus.Util.STM
   ( -- * 'Watcher'
     Watcher (..)
   , forkLinkedWatcher
+  , forkLinkedWatcherAllocate
+  , forkLinkedWatcherFinalize
   , withWatcher
 
     -- * Misc
@@ -36,10 +34,12 @@ import Control.Monad (void)
 import Control.Monad.State (StateT (..))
 import Control.ResourceRegistry
 import Data.Void
-import Data.Word (Word64)
-import GHC.Generics (Generic)
 import GHC.Stack
 import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Network.BlockFetch.ConsensusInterface
+  ( Fingerprint (..)
+  , WithFingerprint (..)
+  )
 
 {-------------------------------------------------------------------------------
   Misc
@@ -83,20 +83,6 @@ blockUntilJust getMaybeA = do
 blockUntilAllJust :: MonadSTM m => [STM m (Maybe a)] -> STM m [a]
 blockUntilAllJust = mapM blockUntilJust
 
--- | Simple type that can be used to indicate something in a @TVar@ is
--- changed.
-newtype Fingerprint = Fingerprint Word64
-  deriving stock (Show, Eq, Generic)
-  deriving newtype Enum
-  deriving anyclass NoThunks
-
--- | Store a value together with its fingerprint.
-data WithFingerprint a = WithFingerprint
-  { forgetFingerprint :: !a
-  , getFingerprint :: !Fingerprint
-  }
-  deriving (Show, Eq, Functor, Generic, NoThunks)
-
 {-------------------------------------------------------------------------------
   Simulate monad stacks
 -------------------------------------------------------------------------------}
@@ -181,6 +167,42 @@ forkLinkedWatcher ::
 forkLinkedWatcher registry label watcher =
   forkLinkedThread registry label $ runWatcher watcher
 
+-- | Spawn a new thread that safely allocates a resource, then runs a 'Watcher'
+-- using the resource, finalizing the resource safely when the watcher
+-- terminates in any way.
+--
+-- The allocated resource and thread are both linked to the registry.
+forkLinkedWatcherAllocate ::
+  forall m r a fp.
+  (IOLike m, Eq fp, HasCallStack) =>
+  ResourceRegistry m ->
+  -- | Label for the thread
+  String ->
+  m r ->
+  (r -> m ()) ->
+  (r -> Watcher m a fp) ->
+  m (Thread m Void)
+forkLinkedWatcherAllocate registry label allocater finalizer f =
+  forkLinkedThread registry label $ do
+    (rk, r) <- allocate registry (const allocater) finalizer
+    runWatcher (f r) `finally` release rk
+
+-- | Spawn a new thread that runs a 'Watcher', executing a finalizer when the
+-- thread terminates.
+--
+-- The thread will be linked to the registry.
+forkLinkedWatcherFinalize ::
+  forall m a fp.
+  (IOLike m, Eq fp, HasCallStack) =>
+  ResourceRegistry m ->
+  -- | Label for the thread
+  String ->
+  Watcher m a fp ->
+  m () ->
+  m (Thread m Void)
+forkLinkedWatcherFinalize registry label watcher finalizer =
+  forkLinkedThread registry label $ runWatcher watcher `finally` finalizer
+
 -- | Spawn a new thread that runs a 'Watcher'
 --
 -- The thread is bracketed via 'withAsync' and 'link'ed.
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Ouroboros/Storage/TestBlock.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Ouroboros/Storage/TestBlock.hs
index 08ef2fa6f..47b4ab762 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Ouroboros/Storage/TestBlock.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Ouroboros/Storage/TestBlock.hs
@@ -750,6 +750,7 @@ mkTestConfig k ChunkSize{chunkCanContainEBB, numRegularBlocks} =
       , eraSlotLength = slotLength
       , eraSafeZone = HardFork.StandardSafeZone (unNonZero (maxRollbacks k) * 2)
       , eraGenesisWin = GenesisWindow (unNonZero (maxRollbacks k) * 2)
+      , eraPerasRoundLength = HardFork.PerasEnabled defaultPerasRoundLength
       }
 
 instance ImmutableEraParams TestBlock where
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/ChainDB.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/ChainDB.hs
index d32ee6522..702c22a89 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/ChainDB.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/ChainDB.hs
@@ -14,7 +14,6 @@ module Test.Util.ChainDB
 import Control.Concurrent.Class.MonadSTM.Strict
 import Control.ResourceRegistry (ResourceRegistry)
 import Control.Tracer (nullTracer)
-import Ouroboros.Consensus.Block.Abstract
 import Ouroboros.Consensus.Config
   ( TopLevelConfig (topLevelConfigLedger)
   , configCodec
@@ -22,7 +21,7 @@ import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.HardFork.History.EraParams (eraEpochSize)
 import Ouroboros.Consensus.Ledger.Basics
 import Ouroboros.Consensus.Ledger.Extended (ExtLedgerState)
-import Ouroboros.Consensus.Protocol.Abstract
+import Ouroboros.Consensus.Ledger.SupportsProtocol
 import Ouroboros.Consensus.Storage.ChainDB hiding
   ( TraceFollowerEvent (..)
   )
@@ -31,7 +30,9 @@ import Ouroboros.Consensus.Storage.ImmutableDB
 import qualified Ouroboros.Consensus.Storage.ImmutableDB as ImmutableDB
 import Ouroboros.Consensus.Storage.LedgerDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB.Snapshots as LedgerDB
-import Ouroboros.Consensus.Storage.LedgerDB.V2.Args
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as V2
+import Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory
+import Ouroboros.Consensus.Storage.PerasCertDB (PerasCertDbArgs (..))
 import Ouroboros.Consensus.Storage.VolatileDB
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util.Args
@@ -84,10 +85,9 @@ mkTestChunkInfo = simpleChunkInfo . eraEpochSize . tblcHardForkParams . topLevel
 
 -- | Creates a default set of of arguments for ChainDB tests.
 fromMinimalChainDbArgs ::
-  ( MonadThrow m
-  , MonadSTM m
-  , ConsensusProtocol (BlockProtocol blk)
-  , PrimMonad m
+  ( IOLike m
+  , LedgerSupportsProtocol blk
+  , LedgerSupportsLedgerDB blk
   ) =>
   MinimalChainDbArgs m blk -> Complete ChainDbArgs m blk
 fromMinimalChainDbArgs MinimalChainDbArgs{..} =
@@ -131,10 +131,14 @@ fromMinimalChainDbArgs MinimalChainDbArgs{..} =
           , lgrTracer = nullTracer
           , lgrRegistry = mcdbRegistry
           , lgrConfig = configLedgerDb mcdbTopLevelConfig OmitLedgerEvents
-          , lgrFlavorArgs = LedgerDbFlavorArgsV2 (V2Args InMemoryHandleArgs)
+          , lgrBackendArgs = LedgerDbBackendArgsV2 $ V2.SomeBackendArgs InMemArgs
           , lgrQueryBatchSize = DefaultQueryBatchSize
           , lgrStartSnapshot = Nothing
           }
+    , cdbPerasCertDbArgs =
+        PerasCertDbArgs
+          { pcdbaTracer = nullTracer
+          }
     , cdbsArgs =
         ChainDbSpecificArgs
           { cdbsBlocksToAddSize = 1
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/Arbitrary.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/Arbitrary.hs
index 27b96abf4..544f25db2 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/Arbitrary.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/Arbitrary.hs
@@ -310,7 +310,17 @@ instance
 -------------------------------------------------------------------------------}
 
 instance Arbitrary EraParams where
-  arbitrary = EraParams <$> arbitrary <*> arbitrary <*> arbitrary <*> (GenesisWindow <$> arbitrary)
+  arbitrary =
+    EraParams
+      <$> arbitrary
+      <*> arbitrary
+      <*> arbitrary
+      <*> (GenesisWindow <$> arbitrary)
+      <*> mPerasRoundLength
+   where
+    mPerasRoundLength :: Gen (PerasEnabled PerasRoundLength)
+    mPerasRoundLength = do
+      (\x -> if x == 0 then NoPerasEnabled else PerasEnabled . PerasRoundLength $ x) <$> arbitrary
 
 instance Arbitrary SafeZone where
   arbitrary =
@@ -332,6 +342,15 @@ instance Arbitrary Bound where
       <$> (RelativeTime <$> arbitrary)
       <*> (SlotNo <$> arbitrary)
       <*> (EpochNo <$> arbitrary)
+      <*> mPerasRoundNo
+   where
+    mPerasRoundNo :: Gen (PerasEnabled PerasRoundNo)
+    mPerasRoundNo = do
+      n <- arbitrary
+      pure $
+        if n == 0
+          then NoPerasEnabled
+          else PerasEnabled (PerasRoundNo n)
 
 instance Arbitrary (K Past blk) where
   arbitrary = K <$> (Past <$> arbitrary <*> arbitrary)
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/ToExpr.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/ToExpr.hs
index 683014129..e5560f70f 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/ToExpr.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/Orphans/ToExpr.hs
@@ -119,6 +119,14 @@ instance ToExpr FsError where
 
 deriving instance ToExpr a => ToExpr (LoE a)
 
+deriving anyclass instance ToExpr PerasRoundNo
+
+deriving anyclass instance ToExpr PerasWeight
+
+deriving anyclass instance ToExpr (HeaderHash blk) => ToExpr (PerasCert blk)
+
+deriving anyclass instance ToExpr (HeaderHash blk) => ToExpr (ValidatedPerasCert blk)
+
 {-------------------------------------------------------------------------------
   si-timers
 --------------------------------------------------------------------------------}
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestBlock.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestBlock.hs
index f1f397011..27a8d0c64 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestBlock.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestBlock.hs
@@ -139,6 +139,8 @@ import Ouroboros.Consensus.Ledger.Tables.Utils
 import Ouroboros.Consensus.Node.NetworkProtocolVersion
 import Ouroboros.Consensus.Node.ProtocolInfo
 import Ouroboros.Consensus.NodeId
+import Ouroboros.Consensus.Peras.SelectView (weightedSelectView)
+import Ouroboros.Consensus.Peras.Weight (PerasWeightSnapshot)
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Protocol.BFT
 import Ouroboros.Consensus.Protocol.MockChainSel
@@ -859,15 +861,21 @@ treeToBlocks = Tree.flatten . blockTree
 treeToChains :: BlockTree -> [Chain TestBlock]
 treeToChains = map Chain.fromOldestFirst . allPaths . blockTree
 
-treePreferredChain :: BlockTree -> Chain TestBlock
-treePreferredChain =
+treePreferredChain ::
+  PerasWeightSnapshot TestBlock ->
+  BlockTree ->
+  Chain TestBlock
+treePreferredChain weights =
   fromMaybe Genesis
     . selectUnvalidatedChain
       (Proxy @(BlockProtocol TestBlock))
       (() :: ChainOrderConfig (SelectView (BlockProtocol TestBlock)))
-      (\hdr -> SelectView (blockNo hdr) NoTiebreaker)
+      (weightedSelectView bcfg weights . Chain.toAnchoredFragment . fmap getHeader)
       Genesis
     . treeToChains
+ where
+  -- inconsequential for this function
+  bcfg = TestBlockConfig (NumCoreNodes 0)
 
 instance Show BlockTree where
   show (BlockTree t) = Tree.drawTree (fmap show t)
diff --git a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestEnv.hs b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestEnv.hs
index 1c64f801f..2891eea64 100644
--- a/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestEnv.hs
+++ b/ouroboros-consensus/src/unstable-consensus-testlib/Test/Util/TestEnv.hs
@@ -1,7 +1,8 @@
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE RecordWildCards #-}
 
--- | A @tasty@ command-line option for enabling nightly tests
+-- | This module provides @tasty@ command-line options for enabling nightly tests
+--   and controlling test output verbosity
 module Test.Util.TestEnv
   ( TestEnv (..)
   , adjustQuickCheckMaxSize
@@ -17,6 +18,7 @@ import Main.Utf8 (withStdTerminalHandles)
 import Options.Applicative (metavar)
 import Test.Tasty
 import Test.Tasty.Ingredients
+import Test.Tasty.Ingredients.Basic (HideSuccesses (..))
 import Test.Tasty.Ingredients.Rerun
 import Test.Tasty.Options
 import Test.Tasty.QuickCheck
@@ -28,12 +30,15 @@ defaultMainWithTestEnv testConfig testTree = do
   cryptoInit
   withStdTerminalHandles $
     defaultMainWithIngredients
-      [rerunningTests (testEnvIngredient : defaultIngredients)]
+      [rerunningTests (hideSuccessIngredient : testEnvIngredient : defaultIngredients)]
       (withTestEnv testConfig testTree)
  where
   testEnvIngredient :: Ingredient
   testEnvIngredient = includingOptions [Option (Proxy :: Proxy TestEnv)]
 
+  hideSuccessIngredient :: Ingredient
+  hideSuccessIngredient = includingOptions [Option (Proxy :: Proxy HideSuccesses)]
+
 -- | Set the appropriate options for the test environment
 withTestEnv :: TestEnvConfig -> TestTree -> TestTree
 withTestEnv TestEnvConfig{..} testTree = askOption $ \case
diff --git a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Ledger/Block.hs b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Ledger/Block.hs
index a57d6d4d8..b5abe5b2c 100644
--- a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Ledger/Block.hs
+++ b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Ledger/Block.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE DeriveAnyClass #-}
 {-# LANGUAGE DeriveGeneric #-}
@@ -183,6 +184,8 @@ instance
 
   headerIsEBB = const Nothing
 
+type KnownHashSize c = KnownNat (Hash.SizeHash (SimpleHash c))
+
 data SimpleStdHeader c ext = SimpleStdHeader
   { simplePrev :: ChainHash (SimpleBlock c ext)
   , simpleSlotNo :: SlotNo
@@ -194,7 +197,7 @@ data SimpleStdHeader c ext = SimpleStdHeader
   deriving anyclass NoThunks
 
 deriving anyclass instance
-  KnownNat (Hash.SizeHash (SimpleHash c)) =>
+  KnownHashSize c =>
   Serialise (SimpleStdHeader c ext)
 
 data SimpleBody = SimpleBody
@@ -728,10 +731,7 @@ instance InspectLedger (SimpleBlock c ext)
   Crypto needed for simple blocks
 -------------------------------------------------------------------------------}
 
-class
-  (KnownNat (Hash.SizeHash (SimpleHash c)), HashAlgorithm (SimpleHash c), Typeable c) =>
-  SimpleCrypto c
-  where
+class (KnownHashSize c, HashAlgorithm (SimpleHash c), Typeable c) => SimpleCrypto c where
   type SimpleHash c :: Type
 
 data SimpleStandardCrypto
@@ -791,7 +791,7 @@ instance ToCBOR SimpleBody where
   toCBOR = encode
 
 encodeSimpleHeader ::
-  KnownNat (Hash.SizeHash (SimpleHash c)) =>
+  KnownHashSize c =>
   (ext' -> CBOR.Encoding) ->
   Header (SimpleBlock' c ext ext') ->
   CBOR.Encoding
diff --git a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node.hs b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node.hs
index ee5928b29..9eccd4e07 100644
--- a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node.hs
+++ b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node.hs
@@ -110,6 +110,7 @@ simpleBlockForging aCanBeLeader aForgeExt =
             lst
             (map txForgetValidated txs)
             proof
+    , finalize = pure ()
     }
  where
   _ = keepRedundantConstraint (Proxy @(ForgeStateUpdateError (SimpleBlock c ext) ~ Void))
diff --git a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/PBFT.hs b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/PBFT.hs
index 5b97a5b44..497d232b3 100644
--- a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/PBFT.hs
+++ b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/PBFT.hs
@@ -118,4 +118,5 @@ pbftBlockForging canBeLeader =
             lst
             (map txForgetValidated txs)
             proof
+    , finalize = pure ()
     }
diff --git a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/Praos.hs b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/Praos.hs
index 97c533f68..09a33db86 100644
--- a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/Praos.hs
+++ b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Node/Praos.hs
@@ -145,4 +145,5 @@ praosBlockForging cid initHotKey = do
               tickedLedgerSt
               (map txForgetValidated txs)
               isLeader
+      , finalize = pure ()
       }
diff --git a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Protocol/Praos.hs b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Protocol/Praos.hs
index 7865770fd..53164edf6 100644
--- a/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Protocol/Praos.hs
+++ b/ouroboros-consensus/src/unstable-mock-block/Ouroboros/Consensus/Mock/Protocol/Praos.hs
@@ -82,7 +82,6 @@ import Ouroboros.Consensus.NodeId (CoreNodeId (..))
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Protocol.Signed
 import Ouroboros.Consensus.Util.Condense
-import Test.Cardano.Slotting.Numeric ()
 
 -- The Praos paper can be located at https://ia.cr/2017/573
 --
@@ -216,7 +215,8 @@ data HotKey c
   | HotKeyPoisoned
   deriving Generic
 
-instance PraosCrypto c => NoThunks (HotKey c)
+instance (PraosCrypto c, NoThunks (UnsoundPureSignKeyKES (PraosKES c))) => NoThunks (HotKey c)
+
 instance PraosCrypto c => Show (HotKey c) where
   show (HotKey p _) = "HotKey " ++ show p ++ " <SignKeyKES: hidden>"
   show HotKeyPoisoned = "HotKeyPoisoned"
@@ -263,7 +263,7 @@ forgePraosFields ::
   PraosProof c ->
   HotKey c ->
   (PraosExtraFields c -> toSign) ->
-  PraosFields c toSign
+  (PraosFields c toSign)
 forgePraosFields PraosProof{..} hotKey mkToSign =
   case hotKey of
     HotKey kesPeriod key ->
@@ -423,14 +423,14 @@ infosEta ::
   [BlockInfo c] ->
   EpochNo ->
   Natural
-infosEta l _ 0 =
+infosEta l _ (EpochNo 0) =
   praosInitialEta l
-infosEta l@PraosConfig{praosParams = PraosParams{..}} xs e =
+infosEta l@PraosConfig{praosParams = PraosParams{..}} xs (EpochNo e) =
   let e' = e - 1
       -- the η from the previous epoch
-      eta' = infosEta l xs e'
+      eta' = infosEta l xs (EpochNo e')
       -- the first slot in previous epoch
-      from = epochFirst l e'
+      from = epochFirst l (EpochNo e')
       -- 2/3 of the slots per epoch
       n = div (2 * praosSlotsPerEpoch) 3
       -- the last of the 2/3 of slots in this epoch
diff --git a/ouroboros-consensus/test/consensus-test/Main.hs b/ouroboros-consensus/test/consensus-test/Main.hs
index 88681b82f..79d681213 100644
--- a/ouroboros-consensus/test/consensus-test/Main.hs
+++ b/ouroboros-consensus/test/consensus-test/Main.hs
@@ -16,6 +16,9 @@ import qualified Test.Consensus.MiniProtocol.BlockFetch.Client (tests)
 import qualified Test.Consensus.MiniProtocol.ChainSync.CSJ (tests)
 import qualified Test.Consensus.MiniProtocol.ChainSync.Client (tests)
 import qualified Test.Consensus.MiniProtocol.LocalStateQuery.Server (tests)
+import qualified Test.Consensus.MiniProtocol.ObjectDiffusion.PerasCert.Smoke (tests)
+import qualified Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke (tests)
+import qualified Test.Consensus.Peras.WeightSnapshot (tests)
 import qualified Test.Consensus.Util.MonadSTM.NormalForm (tests)
 import qualified Test.Consensus.Util.Versioned (tests)
 import Test.Tasty
@@ -36,6 +39,8 @@ tests =
     , Test.Consensus.MiniProtocol.BlockFetch.Client.tests
     , Test.Consensus.MiniProtocol.ChainSync.CSJ.tests
     , Test.Consensus.MiniProtocol.ChainSync.Client.tests
+    , Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke.tests
+    , Test.Consensus.MiniProtocol.ObjectDiffusion.PerasCert.Smoke.tests
     , Test.Consensus.MiniProtocol.LocalStateQuery.Server.tests
     , testGroup
         "Mempool"
@@ -43,6 +48,7 @@ tests =
         , Test.Consensus.Mempool.Fairness.tests
         , Test.Consensus.Mempool.StateMachine.tests
         ]
+    , Test.Consensus.Peras.WeightSnapshot.tests
     , Test.Consensus.Util.MonadSTM.NormalForm.tests
     , Test.Consensus.Util.Versioned.tests
     , testGroup
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Forecast.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Forecast.hs
index 7e4018e6c..60cc0f5fb 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Forecast.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Forecast.hs
@@ -56,9 +56,23 @@ import Ouroboros.Consensus.HardFork.History.Util
 import Ouroboros.Consensus.Ledger.Tables.Combinators (K2 (..))
 import Ouroboros.Consensus.Util (Some (..), repeatedly, splits)
 import Test.Consensus.HardFork.Infra
-import Test.QuickCheck hiding (Some (..))
+import Test.QuickCheck
+  ( Arbitrary (..)
+  , Gen
+  , Property
+  , choose
+  , conjoin
+  , counterexample
+  , elements
+  , oneof
+  , property
+  , shrinkList
+  , sized
+  , tabulate
+  , (===)
+  )
 import Test.Tasty
-import Test.Tasty.QuickCheck hiding (Some (..))
+import Test.Tasty.QuickCheck (testProperty)
 import Test.Util.QuickCheck
 
 tests :: TestTree
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/History.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/History.hs
index 95491738d..a2ad4d3bc 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/History.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/History.hs
@@ -2,6 +2,7 @@
 {-# LANGUAGE ExistentialQuantification #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
@@ -65,11 +66,11 @@ import Test.Util.QuickCheck
 -- General approach:
 --
 -- * Generate a chain of events
--- * Each event records its own 'RelativeTime', 'SlotNo', and 'EpochNo'
+-- * Each event records its own 'RelativeTime', 'SlotNo', 'EpochNo', and 'PerasRoundNo'
 -- * We then construct a 'HF.Summary' from a /prefix/ of this chain
 -- * We then pick an arbitrary event from the (full) chain:
 --   a. If that event is on the prefix of the chain, or within the safe zone, we
---      expect to be able to do any slot/epoch or slot/time conversion, and we
+--      expect to be able to do any slot/epoch, slot/time or Peras round/slot conversion, and we
 --      can easily verify the result by comparing it to the values the 'Event'
 --      itself reports.
 --   b. If the event is outside of safe zone, we expect the conversion to throw
@@ -96,6 +97,7 @@ tests =
         , testProperty "eventWallclockToSlot" eventWallclockToSlot
         , testProperty "epochInfoSlotToEpoch" epochInfoSlotToEpoch
         , testProperty "epochInfoEpochToSlot" epochInfoEpochToSlot
+        , testProperty "eventPerasRounNoToSlot" eventPerasRoundNoToSlot
         , testProperty "query vs expr" queryVsExprConsistency
         ]
     ]
@@ -208,6 +210,20 @@ eventWallclockToSlot chain@ArbitraryChain{..} =
   diff :: NominalDiffTime
   diff = arbitraryDiffTime arbitraryParams
 
+eventPerasRoundNoToSlot :: ArbitraryChain -> Property
+eventPerasRoundNoToSlot chain@ArbitraryChain{..} =
+  testSkeleton chain (HF.perasRoundNoToSlot eventTimePerasRoundNo) $
+    \case
+      HF.NoPerasEnabled -> property True
+      HF.PerasEnabled (startOfPerasRound, roundLength) ->
+        conjoin
+          [ eventTimeSlot
+              === (HF.addSlots eventTimeSlotInPerasRound startOfPerasRound)
+          , eventTimeSlotInPerasRound `lt` (unPerasRoundLength roundLength)
+          ]
+ where
+  EventTime{..} = eventTime arbitraryEvent
+
 -- | Composing queries should be equivalent to composing expressions.
 --
 -- This is a regression test. Each expression in a query should be evaluated in
@@ -503,7 +519,13 @@ data EventTime = EventTime
   { eventTimeSlot :: SlotNo
   , eventTimeEpochNo :: EpochNo
   , eventTimeEpochSlot :: Word64
+  -- ^ Relative slot withing the current epoch round,
+  --   needed to be able to advance the epoch number
   , eventTimeRelative :: RelativeTime
+  , eventTimePerasRoundNo :: PerasRoundNo
+  , eventTimeSlotInPerasRound :: Word64
+  -- ^ Relative slot withing the current Peras round,
+  --   needed to be able to advance the round number
   }
   deriving Show
 
@@ -514,6 +536,8 @@ initEventTime =
     , eventTimeEpochNo = EpochNo 0
     , eventTimeEpochSlot = 0
     , eventTimeRelative = RelativeTime 0
+    , eventTimePerasRoundNo = PerasRoundNo 0
+    , eventTimeSlotInPerasRound = 0
     }
 
 -- | Next time slot
@@ -526,6 +550,8 @@ stepEventTime HF.EraParams{..} EventTime{..} =
     , eventTimeRelative =
         addRelTime (getSlotLength eraSlotLength) $
           eventTimeRelative
+    , eventTimePerasRoundNo = perasRoundNo'
+    , eventTimeSlotInPerasRound = slotInPerasRound'
     }
  where
   epoch' :: EpochNo
@@ -535,6 +561,16 @@ stepEventTime HF.EraParams{..} EventTime{..} =
       then (succ eventTimeEpochNo, 0)
       else (eventTimeEpochNo, succ eventTimeEpochSlot)
 
+  perasRoundNo' :: PerasRoundNo
+  slotInPerasRound' :: Word64
+  args@(perasRoundNo', slotInPerasRound') =
+    case eraPerasRoundLength of
+      HF.NoPerasEnabled -> args
+      HF.PerasEnabled (PerasRoundLength perasRoundLength) ->
+        if succ eventTimeSlotInPerasRound == perasRoundLength
+          then (succ eventTimePerasRoundNo, 0)
+          else (eventTimePerasRoundNo, succ eventTimeSlotInPerasRound)
+
 {-------------------------------------------------------------------------------
   Chain model
 -----------------------------------------------------------------------------}
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Infra.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Infra.hs
index 150ccda30..4cecb8c96 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Infra.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Infra.hs
@@ -35,7 +35,9 @@ import Data.SOP.Strict
 import Data.Word
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.BlockchainTime
+import Ouroboros.Consensus.HardFork.History (Bound (..))
 import qualified Ouroboros.Consensus.HardFork.History as HF
+import Ouroboros.Consensus.HardFork.History.EraParams (EraParams (..))
 import Test.QuickCheck
 
 {-------------------------------------------------------------------------------
@@ -121,6 +123,11 @@ genEraParams = do
   eraSlotLength <- slotLengthFromSec <$> choose (1, 5)
   eraSafeZone <- genSafeZone
   eraGenesisWin <- GenesisWindow <$> choose (1, 10)
+  -- we restrict Peras round length to divide the epoch size.
+  -- for testing purposes, we include Peras round length in every era.
+  eraPerasRoundLength <-
+    HF.PerasEnabled . PerasRoundLength
+      <$> choose (1, 10) `suchThat` (\x -> (unEpochSize eraEpochSize) `mod` x == 0)
   return HF.EraParams{..}
  where
   genSafeZone :: Gen HF.SafeZone
@@ -154,8 +161,13 @@ genShape eras = HF.Shape <$> erasMapStateM genParams eras (EpochNo 0)
 
 genSummary :: Eras xs -> Gen (HF.Summary xs)
 genSummary is =
-  HF.Summary <$> erasUnfoldAtMost genEraSummary is HF.initBound
+  HF.Summary <$> erasUnfoldAtMost genEraSummary is initBoundWithPeras
  where
+  -- TODO(geo2a): revisit this hard-coding of enabling Peras when
+  -- we're further into the integration process
+  -- see https://github.com/tweag/cardano-peras/issues/112
+  initBoundWithPeras = HF.initBound{boundPerasRound = HF.PerasEnabled . PerasRoundNo $ 0}
+
   genEraSummary :: Era -> HF.Bound -> Gen (HF.EraSummary, HF.EraEnd)
   genEraSummary _era lo = do
     params <- genEraParams
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Summary.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Summary.hs
index c1bc38c9f..361e5d096 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Summary.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/HardFork/Summary.hs
@@ -1,5 +1,6 @@
 {-# LANGUAGE ExistentialQuantification #-}
 {-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE NamedFieldPuns #-}
 {-# LANGUAGE NumericUnderscores #-}
 {-# LANGUAGE RankNTypes #-}
@@ -19,6 +20,7 @@
 -- * Converting slot to an epoch and then back to a slot should be an identity
 --   (modulo the time spent in that epoch).
 -- * Converting an epoch to a slot and then back should be an identity.
+-- * Converting a Peras round number to a slot and then back should be an identity.
 module Test.Consensus.HardFork.Summary (tests) where
 
 import Data.Time
@@ -50,6 +52,7 @@ tests =
         , testProperty "roundtripSlotWallclock" roundtripSlotWallclock
         , testProperty "roundtripSlotEpoch" roundtripSlotEpoch
         , testProperty "roundtripEpochSlot" roundtripEpochSlot
+        , testProperty "roundtripPerasRoundSlot" roundtripPerasRoundSlot
         , testProperty "reportsPastHorizon" reportsPastHorizon
         ]
     ]
@@ -131,6 +134,28 @@ roundtripEpochSlot s@ArbitrarySummary{beforeHorizonEpoch = epoch} =
         , inEpoch + slotsLeft === unEpochSize epochSize
         ]
 
+-- | Test that conversion between Peras rounds and slots roundtips.
+--   Additionally, test that the relative slot in round and remaining
+--   slots in round are withing the round length.
+roundtripPerasRoundSlot :: ArbitrarySummary -> Property
+roundtripPerasRoundSlot s@ArbitrarySummary{beforeHorizonPerasRoundNo} =
+  case beforeHorizonPerasRoundNo of
+    HF.NoPerasEnabled -> property True
+    HF.PerasEnabled perasRoundNo ->
+      noPastHorizonException s $
+        HF.perasRoundNoToSlot perasRoundNo >>= \case
+          HF.NoPerasEnabled -> pure $ property True
+          HF.PerasEnabled (slot, PerasRoundLength perasRoundLength) -> do
+            HF.slotToPerasRoundNo slot >>= \case
+              HF.NoPerasEnabled -> pure $ property True
+              HF.PerasEnabled (perasRoundNo', slotInRound, remainingSlotsInRound) ->
+                pure $
+                  conjoin
+                    [ perasRoundNo' === perasRoundNo
+                    , slotInRound `lt` perasRoundLength
+                    , remainingSlotsInRound `le` perasRoundLength
+                    ]
+
 reportsPastHorizon :: ArbitrarySummary -> Property
 reportsPastHorizon s@ArbitrarySummary{..} =
   conjoin
@@ -146,6 +171,9 @@ reportsPastHorizon s@ArbitrarySummary{..} =
     , case mPastHorizonEpoch of
         Just x -> isPastHorizonException s $ HF.epochToSlot x
         Nothing -> property True
+    , case mPastHorizonPerasRoundNo of
+        Just (HF.PerasEnabled x) -> isPastHorizonException s $ HF.perasRoundNoToSlot x
+        _ -> property True
     ]
 
 {-------------------------------------------------------------------------------
@@ -160,9 +188,13 @@ data ArbitrarySummary = forall xs. ArbitrarySummary
   , beforeHorizonTime :: RelativeTime
   , beforeHorizonSlot :: SlotNo
   , beforeHorizonEpoch :: EpochNo
+  , beforeHorizonPerasRoundNo :: HF.PerasEnabled PerasRoundNo
+  -- ^ 'PerasRoundNo' is not optional here,
+  -- i.e. we do not model non-Peras eras in the time conversion tests
   , mPastHorizonTime :: Maybe RelativeTime
   , mPastHorizonSlot :: Maybe SlotNo
   , mPastHorizonEpoch :: Maybe EpochNo
+  , mPastHorizonPerasRoundNo :: Maybe (HF.PerasEnabled PerasRoundNo)
   }
 
 deriving instance Show ArbitrarySummary
@@ -181,10 +213,12 @@ instance Arbitrary ArbitrarySummary where
         beforeHorizonSlots <- choose (0, 100_000_000)
         beforeHorizonEpochs <- choose (0, 1_000_000)
         beforeHorizonSeconds <- choose (0, 1_000_000_000)
+        beforeHorizonPerasRounds <- HF.PerasEnabled <$> choose (0, 1_000)
 
         let beforeHorizonSlot :: SlotNo
             beforeHorizonEpoch :: EpochNo
             beforeHorizonTime :: RelativeTime
+            beforeHorizonPerasRoundNo :: HF.PerasEnabled PerasRoundNo
 
             beforeHorizonSlot =
               HF.addSlots
@@ -198,19 +232,25 @@ instance Arbitrary ArbitrarySummary where
               addRelTime
                 (realToFrac (beforeHorizonSeconds :: Double))
                 (HF.boundTime summaryStart)
-
+            beforeHorizonPerasRoundNo =
+              HF.addPerasRounds
+                <$> beforeHorizonPerasRounds
+                <*> HF.boundPerasRound summaryStart
         return
           ArbitrarySummary
             { arbitrarySummary = summary
             , beforeHorizonTime
             , beforeHorizonSlot
             , beforeHorizonEpoch
+            , beforeHorizonPerasRoundNo
             , mPastHorizonTime = Nothing
             , mPastHorizonSlot = Nothing
             , mPastHorizonEpoch = Nothing
+            , mPastHorizonPerasRoundNo = Nothing
             }
       HF.EraEnd summaryEnd -> do
         let summarySlots, summaryEpochs :: Word64
+            summaryPerasRounds :: HF.PerasEnabled Word64
             summarySlots =
               HF.countSlots
                 (HF.boundSlot summaryEnd)
@@ -219,7 +259,10 @@ instance Arbitrary ArbitrarySummary where
               HF.countEpochs
                 (HF.boundEpoch summaryEnd)
                 (HF.boundEpoch summaryStart)
-
+            summaryPerasRounds =
+              HF.countPerasRounds
+                <$> HF.boundPerasRound summaryEnd
+                <*> HF.boundPerasRound summaryStart
             summaryTimeSpan :: NominalDiffTime
             summaryTimeSpan =
               diffRelTime
@@ -236,7 +279,9 @@ instance Arbitrary ArbitrarySummary where
         beforeHorizonSeconds <-
           choose (0, summaryTimeSpanSeconds)
             `suchThat` \x -> x /= summaryTimeSpanSeconds
-
+        beforeHorizonPerasRounds <- case summaryPerasRounds of
+          HF.NoPerasEnabled -> pure HF.NoPerasEnabled
+          HF.PerasEnabled rounds -> HF.PerasEnabled <$> choose (0, rounds - 1)
         let beforeHorizonSlot :: SlotNo
             beforeHorizonEpoch :: EpochNo
             beforeHorizonTime :: RelativeTime
@@ -253,16 +298,22 @@ instance Arbitrary ArbitrarySummary where
               addRelTime
                 (realToFrac beforeHorizonSeconds)
                 (HF.boundTime summaryStart)
+            beforeHorizonPerasRoundNo =
+              HF.addPerasRounds
+                <$> beforeHorizonPerasRounds
+                <*> HF.boundPerasRound summaryStart
 
         -- Pick arbitrary values past the horizon
 
         pastHorizonSlots :: Word64 <- choose (0, 10)
         pastHorizonEpochs :: Word64 <- choose (0, 10)
         pastHorizonSeconds :: Double <- choose (0, 10)
+        pastHorizonPerasRounds :: HF.PerasEnabled Word64 <- HF.PerasEnabled <$> choose (0, 10)
 
         let pastHorizonSlot :: SlotNo
             pastHorizonEpoch :: EpochNo
             pastHorizonTime :: RelativeTime
+            pastHorizonPerasRoundNo :: HF.PerasEnabled PerasRoundNo
 
             pastHorizonSlot =
               HF.addSlots
@@ -276,16 +327,21 @@ instance Arbitrary ArbitrarySummary where
               addRelTime
                 (realToFrac pastHorizonSeconds)
                 (HF.boundTime summaryEnd)
-
+            pastHorizonPerasRoundNo =
+              HF.addPerasRounds
+                <$> pastHorizonPerasRounds
+                <*> HF.boundPerasRound summaryEnd
         return
           ArbitrarySummary
             { arbitrarySummary = summary
             , beforeHorizonTime
             , beforeHorizonSlot
             , beforeHorizonEpoch
+            , beforeHorizonPerasRoundNo
             , mPastHorizonTime = Just pastHorizonTime
             , mPastHorizonSlot = Just pastHorizonSlot
             , mPastHorizonEpoch = Just pastHorizonEpoch
+            , mPastHorizonPerasRoundNo = Just pastHorizonPerasRoundNo
             }
 
   shrink summary@ArbitrarySummary{..} =
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/BlockFetch/Client.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/BlockFetch/Client.hs
index e45c89ab6..1a440370e 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/BlockFetch/Client.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/BlockFetch/Client.hs
@@ -306,6 +306,7 @@ runBlockFetchTest BlockFetchClientTestSetup{..} = withRegistry \registry -> do
       getMaxSlotNo = ChainDB.getMaxSlotNo chainDB
       addBlockAsync = ChainDB.addBlockAsync chainDB
       getChainSelStarvation = ChainDB.getChainSelStarvation chainDB
+      getPerasWeightSnapshot = ChainDB.getPerasWeightSnapshot chainDB
     pure BlockFetchClientInterface.ChainDbView{..}
    where
     cdbTracer = Tracer \case
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/LocalStateQuery/Server.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/LocalStateQuery/Server.hs
index efafdc18a..cc86a428b 100644
--- a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/LocalStateQuery/Server.hs
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/LocalStateQuery/Server.hs
@@ -37,6 +37,7 @@ import Ouroboros.Consensus.Ledger.Query (Query (..))
 import Ouroboros.Consensus.MiniProtocol.LocalStateQuery.Server
 import Ouroboros.Consensus.Node.ProtocolInfo (NumCoreNodes (..))
 import Ouroboros.Consensus.NodeId
+import Ouroboros.Consensus.Peras.Weight (emptyPerasWeightSnapshot)
 import Ouroboros.Consensus.Protocol.BFT
 import qualified Ouroboros.Consensus.Storage.ChainDB.Impl.BlockCache as BlockCache
 import Ouroboros.Consensus.Storage.ImmutableDB.Stream hiding
@@ -45,7 +46,8 @@ import Ouroboros.Consensus.Storage.ImmutableDB.Stream hiding
 import Ouroboros.Consensus.Storage.LedgerDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
-import Ouroboros.Consensus.Storage.LedgerDB.V1.Args
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as V2
+import Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory
 import Ouroboros.Consensus.Util.IOLike hiding (newTVarIO)
 import Ouroboros.Network.Mock.Chain (Chain (..))
 import qualified Ouroboros.Network.Mock.Chain as Chain
@@ -100,7 +102,7 @@ prop_localStateQueryServer ::
 prop_localStateQueryServer k bt p (Positive (Small n)) = checkOutcome k chain actualOutcome
  where
   chain :: Chain TestBlock
-  chain = treePreferredChain bt
+  chain = treePreferredChain emptyPerasWeightSnapshot bt
 
   points :: [Target (Point TestBlock)]
   points =
@@ -231,7 +233,7 @@ initLedgerDB s c = do
           , lgrHasFS = SomeHasFS $ simHasFS fs
           , lgrGenesis = return testInitExtLedger
           , lgrTracer = nullTracer
-          , lgrFlavorArgs = LedgerDbFlavorArgsV1 $ V1Args DefaultFlushFrequency InMemoryBackingStoreArgs
+          , lgrBackendArgs = LedgerDbBackendArgsV2 $ V2.SomeBackendArgs InMemArgs
           , lgrConfig = LedgerDB.configLedgerDb (testCfg s) OmitLedgerEvents
           , lgrQueryBatchSize = DefaultQueryBatchSize
           , lgrRegistry = reg
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/PerasCert/Smoke.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/PerasCert/Smoke.hs
new file mode 100644
index 000000000..bfdabbe57
--- /dev/null
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/PerasCert/Smoke.hs
@@ -0,0 +1,134 @@
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE RankNTypes #-}
+{-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE UndecidableInstances #-}
+{-# OPTIONS_GHC -Wno-orphans #-}
+
+module Test.Consensus.MiniProtocol.ObjectDiffusion.PerasCert.Smoke (tests) where
+
+import Control.Tracer (contramap, nullTracer)
+import Data.Functor.Identity (Identity (..))
+import qualified Data.List.NonEmpty as NE
+import qualified Data.Map as Map
+import Network.TypedProtocol.Driver.Simple (runPeer, runPipelinedPeer)
+import Ouroboros.Consensus.Block.SupportsPeras
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.PerasCert
+import Ouroboros.Consensus.Storage.PerasCertDB.API
+  ( AddPerasCertResult (..)
+  , PerasCertDB
+  , PerasCertTicketNo
+  )
+import qualified Ouroboros.Consensus.Storage.PerasCertDB.API as PerasCertDB
+import qualified Ouroboros.Consensus.Storage.PerasCertDB.Impl as PerasCertDB
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Network.Block (Point (..), SlotNo (SlotNo), StandardHash)
+import Ouroboros.Network.Point (Block (Block), WithOrigin (..))
+import Ouroboros.Network.Protocol.ObjectDiffusion.Codec
+import Ouroboros.Network.Protocol.ObjectDiffusion.Inbound
+  ( objectDiffusionInboundPeerPipelined
+  )
+import Ouroboros.Network.Protocol.ObjectDiffusion.Outbound (objectDiffusionOutboundPeer)
+import Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke
+  ( ListWithUniqueIds (..)
+  , ProtocolConstants
+  , WithId
+  , getId
+  , prop_smoke_object_diffusion
+  )
+import Test.QuickCheck
+import Test.Tasty
+import Test.Tasty.QuickCheck (testProperty)
+import Test.Util.TestBlock
+
+tests :: TestTree
+tests =
+  testGroup
+    "ObjectDiffusion.PerasCert.Smoke"
+    [ testProperty "PerasCertDiffusion smoke test" prop_smoke
+    ]
+
+instance Arbitrary (Point TestBlock) where
+  arbitrary =
+    -- Sometimes pick the genesis point
+    frequency
+      [ (1, pure $ Point Origin)
+      ,
+        ( 4
+        , do
+            slotNo <- SlotNo <$> arbitrary
+            hash <- TestHash . NE.fromList . getNonEmpty <$> arbitrary
+            pure $ Point (At (Block slotNo hash))
+        )
+      ]
+
+instance Arbitrary (Point blk) => Arbitrary (PerasCert blk) where
+  arbitrary = do
+    pcCertRound <- PerasRoundNo <$> arbitrary
+    pcCertBoostedBlock <- arbitrary
+    pure $ PerasCert{pcCertRound, pcCertBoostedBlock}
+
+instance WithId (PerasCert blk) PerasRoundNo where
+  getId = pcCertRound
+
+newCertDB :: (IOLike m, StandardHash blk) => [PerasCert blk] -> m (PerasCertDB m blk)
+newCertDB certs = do
+  db <- PerasCertDB.openDB (PerasCertDB.PerasCertDbArgs @Identity nullTracer)
+  mapM_
+    ( \cert -> do
+        let validatedCert =
+              ValidatedPerasCert
+                { vpcCert = cert
+                , vpcCertBoost = boostPerCert
+                }
+        result <- PerasCertDB.addCert db validatedCert
+        case result of
+          AddedPerasCertToDB -> pure ()
+          PerasCertAlreadyInDB -> throwIO (userError "Expected AddedPerasCertToDB, but cert was already in DB")
+    )
+    certs
+  pure db
+
+prop_smoke :: ProtocolConstants -> ListWithUniqueIds (PerasCert TestBlock) PerasRoundNo -> Property
+prop_smoke protocolConstants (ListWithUniqueIds certs) =
+  prop_smoke_object_diffusion protocolConstants certs runOutboundPeer runInboundPeer mkPoolInterfaces
+ where
+  runOutboundPeer outbound outboundChannel tracer =
+    runPeer
+      ((\x -> "Outbound (Client): " ++ show x) `contramap` tracer)
+      codecObjectDiffusionId
+      outboundChannel
+      (objectDiffusionOutboundPeer outbound)
+      >> pure ()
+  runInboundPeer inbound inboundChannel tracer =
+    runPipelinedPeer
+      ((\x -> "Inbound (Server): " ++ show x) `contramap` tracer)
+      codecObjectDiffusionId
+      inboundChannel
+      (objectDiffusionInboundPeerPipelined inbound)
+      >> pure ()
+  mkPoolInterfaces ::
+    forall m.
+    IOLike m =>
+    m
+      ( ObjectPoolReader PerasRoundNo (PerasCert TestBlock) PerasCertTicketNo m
+      , ObjectPoolWriter PerasRoundNo (PerasCert TestBlock) m
+      , m [PerasCert TestBlock]
+      )
+  mkPoolInterfaces = do
+    outboundPool <- newCertDB certs
+    inboundPool <- newCertDB []
+
+    let outboundPoolReader = makePerasCertPoolReaderFromCertDB outboundPool
+        inboundPoolWriter = makePerasCertPoolWriterFromCertDB inboundPool
+        getAllInboundPoolContent = do
+          snap <- atomically $ PerasCertDB.getCertSnapshot inboundPool
+          let rawContent =
+                Map.toAscList $
+                  PerasCertDB.getCertsAfter snap (PerasCertDB.zeroPerasCertTicketNo)
+          pure $ getPerasCert . snd <$> rawContent
+
+    return (outboundPoolReader, inboundPoolWriter, getAllInboundPoolContent)
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/Smoke.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/Smoke.hs
new file mode 100644
index 000000000..d2f21c9b6
--- /dev/null
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/MiniProtocol/ObjectDiffusion/Smoke.hs
@@ -0,0 +1,302 @@
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE FunctionalDependencies #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE KindSignatures #-}
+{-# LANGUAGE RankNTypes #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+-- | Smoke tests for the object diffusion protocol. This uses a trivial object
+-- pool and checks that a few objects can indeed be transferred from the
+-- outbound to the inbound peer.
+module Test.Consensus.MiniProtocol.ObjectDiffusion.Smoke
+  ( tests
+  , WithId (..)
+  , ListWithUniqueIds (..)
+  , ProtocolConstants
+  , prop_smoke_object_diffusion
+  ) where
+
+import Control.Monad.IOSim (runSimStrictShutdown)
+import Control.ResourceRegistry (forkLinkedThread, waitAnyThread, withRegistry)
+import Control.Tracer (Tracer, nullTracer, traceWith)
+import Data.Containers.ListUtils (nubOrdOn)
+import Data.Functor.Contravariant (contramap)
+import Network.TypedProtocol.Channel (Channel, createConnectedChannels)
+import Network.TypedProtocol.Codec (AnyMessage)
+import Network.TypedProtocol.Driver.Simple (runPeer, runPipelinedPeer)
+import NoThunks.Class (NoThunks)
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Inbound
+  ( objectDiffusionInbound
+  )
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.ObjectPool.API
+  ( ObjectPoolReader (..)
+  , ObjectPoolWriter (..)
+  )
+import Ouroboros.Consensus.MiniProtocol.ObjectDiffusion.Outbound (objectDiffusionOutbound)
+import Ouroboros.Consensus.Util.IOLike
+  ( IOLike
+  , MonadDelay (..)
+  , MonadSTM (..)
+  , StrictTVar
+  , modifyTVar
+  , readTVar
+  , uncheckedNewTVarM
+  , writeTVar
+  )
+import Ouroboros.Network.ControlMessage (ControlMessage (..))
+import Ouroboros.Network.NodeToNode.Version (NodeToNodeVersion (..))
+import Ouroboros.Network.Protocol.ObjectDiffusion.Codec (codecObjectDiffusionId)
+import Ouroboros.Network.Protocol.ObjectDiffusion.Inbound
+  ( ObjectDiffusionInboundPipelined
+  , objectDiffusionInboundPeerPipelined
+  )
+import Ouroboros.Network.Protocol.ObjectDiffusion.Outbound
+  ( ObjectDiffusionOutbound
+  , objectDiffusionOutboundPeer
+  )
+import Ouroboros.Network.Protocol.ObjectDiffusion.Type
+  ( NumObjectIdsReq (..)
+  , NumObjectsOutstanding (..)
+  , NumObjectsReq (..)
+  , ObjectDiffusion
+  )
+import Test.QuickCheck
+import Test.Tasty
+import Test.Tasty.QuickCheck
+import Test.Util.Orphans.Arbitrary ()
+import Test.Util.Orphans.IOLike ()
+
+tests :: TestTree
+tests =
+  testGroup
+    "ObjectDiffusion.Smoke"
+    [ testProperty
+        "ObjectDiffusion smoke test with mock objects"
+        prop_smoke
+    ]
+
+{-------------------------------------------------------------------------------
+  Provides a way to generate lists composed of objects with no duplicate ids,
+  with an Arbitrary instance
+-------------------------------------------------------------------------------}
+
+class WithId a idTy | a -> idTy where
+  getId :: a -> idTy
+
+newtype ListWithUniqueIds a idTy = ListWithUniqueIds [a]
+  deriving (Eq, Show, Ord)
+
+instance (Ord idTy, WithId a idTy, Arbitrary a) => Arbitrary (ListWithUniqueIds a idTy) where
+  arbitrary = ListWithUniqueIds . nubOrdOn getId <$> arbitrary
+
+instance WithId SmokeObject SmokeObjectId where getId = getSmokeObjectId
+
+{-------------------------------------------------------------------------------
+  Mock objectPools
+-------------------------------------------------------------------------------}
+
+newtype SmokeObjectId = SmokeObjectId Int
+  deriving (Eq, Ord, Show, NoThunks, Arbitrary)
+
+newtype SmokeObject = SmokeObject {getSmokeObjectId :: SmokeObjectId}
+  deriving (Eq, Ord, Show, NoThunks, Arbitrary)
+
+newtype SmokeObjectPool m = SmokeObjectPool (StrictTVar m [SmokeObject])
+
+newObjectPool :: MonadSTM m => [SmokeObject] -> m (SmokeObjectPool m)
+newObjectPool initialPoolContent = SmokeObjectPool <$> uncheckedNewTVarM initialPoolContent
+
+makeObjectPoolReader ::
+  MonadSTM m => SmokeObjectPool m -> ObjectPoolReader SmokeObjectId SmokeObject Int m
+makeObjectPoolReader (SmokeObjectPool poolContentTvar) =
+  ObjectPoolReader
+    { oprObjectId = getSmokeObjectId
+    , oprObjectsAfter = \minTicketNo limit -> do
+        poolContent <- readTVar poolContentTvar
+        pure $
+          take (fromIntegral limit) $
+            drop (minTicketNo + 1) $
+              ( (\(ticketNo, smokeObject) -> (ticketNo, getSmokeObjectId smokeObject, pure smokeObject))
+                  <$> zip [(0 :: Int) ..] poolContent
+              )
+    , oprZeroTicketNo = -1 -- objectPoolObjectIdsAfter uses strict comparison, and first ticketNo is 0.
+    }
+
+makeObjectPoolWriter ::
+  MonadSTM m => SmokeObjectPool m -> ObjectPoolWriter SmokeObjectId SmokeObject m
+makeObjectPoolWriter (SmokeObjectPool poolContentTvar) =
+  ObjectPoolWriter
+    { opwObjectId = getSmokeObjectId
+    , opwAddObjects = \objects -> do
+        atomically $ modifyTVar poolContentTvar (++ objects)
+        return ()
+    , opwHasObject = do
+        poolContent <- readTVar poolContentTvar
+        pure $ \objectId -> any (\obj -> getSmokeObjectId obj == objectId) poolContent
+    }
+
+mkMockPoolInterfaces ::
+  MonadSTM m =>
+  [SmokeObject] ->
+  m
+    ( ObjectPoolReader SmokeObjectId SmokeObject Int m
+    , ObjectPoolWriter SmokeObjectId SmokeObject m
+    , m [SmokeObject]
+    )
+mkMockPoolInterfaces objects = do
+  outboundPool <- newObjectPool objects
+  inboundPool@(SmokeObjectPool tvar) <- newObjectPool []
+
+  let outboundPoolReader = makeObjectPoolReader outboundPool
+      inboundPoolWriter = makeObjectPoolWriter inboundPool
+
+  return (outboundPoolReader, inboundPoolWriter, atomically $ readTVar tvar)
+
+{-------------------------------------------------------------------------------
+  Main properties
+-------------------------------------------------------------------------------}
+
+-- Protocol constants
+
+newtype ProtocolConstants
+  = ProtocolConstants (NumObjectsOutstanding, NumObjectIdsReq, NumObjectsReq)
+  deriving Show
+
+instance Arbitrary ProtocolConstants where
+  arbitrary = do
+    maxFifoSize <- choose (5, 20)
+    maxIdsToReq <- choose (3, maxFifoSize)
+    maxObjectsToReq <- choose (2, maxIdsToReq)
+    pure $
+      ProtocolConstants
+        ( NumObjectsOutstanding maxFifoSize
+        , NumObjectIdsReq maxIdsToReq
+        , NumObjectsReq maxObjectsToReq
+        )
+
+nodeToNodeVersion :: NodeToNodeVersion
+nodeToNodeVersion = NodeToNodeV_14
+
+prop_smoke :: ProtocolConstants -> ListWithUniqueIds SmokeObject idTy -> Property
+prop_smoke protocolConstants (ListWithUniqueIds objects) =
+  prop_smoke_object_diffusion
+    protocolConstants
+    objects
+    runOutboundPeer
+    runInboundPeer
+    (mkMockPoolInterfaces objects)
+ where
+  runOutboundPeer outbound outboundChannel tracer =
+    runPeer
+      ((\x -> "Outbound (Server): " ++ show x) `contramap` tracer)
+      codecObjectDiffusionId
+      outboundChannel
+      (objectDiffusionOutboundPeer outbound)
+      >> pure ()
+
+  runInboundPeer inbound inboundChannel tracer =
+    runPipelinedPeer
+      ((\x -> "Inbound (Client): " ++ show x) `contramap` tracer)
+      codecObjectDiffusionId
+      inboundChannel
+      (objectDiffusionInboundPeerPipelined inbound)
+      >> pure ()
+
+--- The core logic of the smoke test is shared between the generic smoke tests for ObjectDiffusion, and the ones specialised to PerasCert/PerasVote diffusion
+prop_smoke_object_diffusion ::
+  ( Eq object
+  , Show object
+  , Ord objectId
+  , NoThunks objectId
+  , Show objectId
+  , NoThunks object
+  , Ord ticketNo
+  ) =>
+  ProtocolConstants ->
+  [object] ->
+  ( forall m.
+    IOLike m =>
+    ObjectDiffusionOutbound objectId object m () ->
+    Channel m (AnyMessage (ObjectDiffusion objectId object)) ->
+    (Tracer m String) ->
+    m ()
+  ) ->
+  ( forall m.
+    IOLike m =>
+    ObjectDiffusionInboundPipelined objectId object m () ->
+    (Channel m (AnyMessage (ObjectDiffusion objectId object))) ->
+    (Tracer m String) ->
+    m ()
+  ) ->
+  ( forall m.
+    IOLike m =>
+    m
+      ( ObjectPoolReader objectId object ticketNo m
+      , ObjectPoolWriter objectId object m
+      , m [object]
+      )
+  ) ->
+  Property
+prop_smoke_object_diffusion
+  (ProtocolConstants (maxFifoSize, maxIdsToReq, maxObjectsToReq))
+  objects
+  runOutboundPeer
+  runInboundPeer
+  mkPoolInterfaces =
+    let
+      simulationResult = runSimStrictShutdown $ do
+        let tracer = nullTracer
+
+        traceWith tracer "========== [ Starting ObjectDiffusion smoke test ] =========="
+        traceWith tracer (show objects)
+
+        (outboundPoolReader, inboundPoolWriter, getAllInboundPoolContent) <- mkPoolInterfaces
+        controlMessage <- uncheckedNewTVarM Continue
+
+        let
+          inbound =
+            objectDiffusionInbound
+              tracer
+              ( maxFifoSize
+              , maxIdsToReq
+              , maxObjectsToReq
+              )
+              inboundPoolWriter
+              nodeToNodeVersion
+              (readTVar controlMessage)
+
+          outbound =
+            objectDiffusionOutbound
+              tracer
+              maxFifoSize
+              outboundPoolReader
+              nodeToNodeVersion
+
+        withRegistry $ \reg -> do
+          (outboundChannel, inboundChannel) <- createConnectedChannels
+          outboundThread <-
+            forkLinkedThread reg "ObjectDiffusion Outbound peer thread" $
+              runOutboundPeer outbound outboundChannel tracer
+          inboundThread <-
+            forkLinkedThread reg "ObjectDiffusion Inbound peer thread" $
+              runInboundPeer inbound inboundChannel tracer
+          controlMessageThread <- forkLinkedThread reg "ObjectDiffusion Control thread" $ do
+            threadDelay 1000 -- give a head start to the other threads
+            atomically $ writeTVar controlMessage Terminate
+            threadDelay 1000 -- wait for the other threads to finish
+          waitAnyThread [outboundThread, inboundThread, controlMessageThread]
+
+        traceWith tracer "========== [ ObjectDiffusion smoke test finished ] =========="
+        poolContent <- getAllInboundPoolContent
+
+        traceWith tracer "inboundPoolContent:"
+        traceWith tracer (show poolContent)
+        traceWith tracer "========== ======================================= =========="
+        pure poolContent
+     in
+      case simulationResult of
+        Right inboundPoolContent -> inboundPoolContent === objects
+        Left msg -> counterexample (show msg) $ property False
diff --git a/ouroboros-consensus/test/consensus-test/Test/Consensus/Peras/WeightSnapshot.hs b/ouroboros-consensus/test/consensus-test/Test/Consensus/Peras/WeightSnapshot.hs
new file mode 100644
index 000000000..d300f2d4e
--- /dev/null
+++ b/ouroboros-consensus/test/consensus-test/Test/Consensus/Peras/WeightSnapshot.hs
@@ -0,0 +1,239 @@
+{-# LANGUAGE BlockArguments #-}
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE DerivingStrategies #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE TupleSections #-}
+{-# LANGUAGE TypeApplications #-}
+
+#if __GLASGOW_HASKELL__ >= 910
+{-# OPTIONS_GHC -Wno-x-partial #-}
+#endif
+
+-- | Test that 'PerasWeightSnapshot' can correctly compute the weight of points
+-- and fragments.
+module Test.Consensus.Peras.WeightSnapshot (tests) where
+
+import Cardano.Ledger.BaseTypes (unNonZero)
+import Data.Containers.ListUtils (nubOrd)
+import Data.List (find)
+import Data.Map.Strict (Map)
+import qualified Data.Map.Strict as Map
+import Data.Maybe (catMaybes, fromJust)
+import Data.Traversable (for)
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Config.SecurityParam
+import Ouroboros.Consensus.Peras.Weight
+import Ouroboros.Consensus.Util.Condense
+import Ouroboros.Network.AnchoredFragment (AnchoredFragment)
+import qualified Ouroboros.Network.AnchoredFragment as AF
+import Ouroboros.Network.Mock.Chain (Chain)
+import qualified Ouroboros.Network.Mock.Chain as Chain
+import Test.QuickCheck
+import Test.Tasty
+import Test.Tasty.QuickCheck
+import Test.Util.Orphans.Arbitrary ()
+import Test.Util.QuickCheck
+import Test.Util.TestBlock
+
+tests :: TestTree
+tests =
+  testGroup
+    "PerasWeightSnapshot"
+    [ testProperty "correctness" prop_perasWeightSnapshot
+    ]
+
+prop_perasWeightSnapshot :: TestSetup -> Property
+prop_perasWeightSnapshot testSetup =
+  tabulate "log₂ # of points" [show $ round @Double @Int $ logBase 2 (fromIntegral (length tsPoints))]
+    . counterexample ("PerasWeightSnapshot: " <> show snap)
+    $ conjoin
+      [ conjoin
+          [ counterexample ("Incorrect weight for " <> condense pt) $
+              weightBoostOfPointReference pt =:= weightBoostOfPoint snap pt
+          | pt <- tsPoints
+          ]
+      , conjoin
+          [ conjoin
+              [ counterexample ("Incorrect weight for " <> condense frag) $
+                  weightBoostOfFragmentReference frag =:= weightBoostOfFragment snap frag
+              , counterexample ("Weight not inductively consistent for " <> condense frag) $
+                  prop_fragmentInduction snap frag
+              ]
+          | frag <- tsFragments
+          ]
+      , conjoin
+          [ conjoin
+              [ counterexample ("Incorrect volatile suffix for " <> condense frag) $
+                  takeVolatileSuffixReference frag =:= volSuffix
+              , counterexample ("Volatile suffix must be a suffix of" <> condense frag) $
+                  AF.headPoint frag =:= AF.headPoint volSuffix
+                    .&&. AF.withinFragmentBounds (AF.anchorPoint volSuffix) frag
+              , counterexample ("A longer volatile suffix still has total weight at most k") $
+                  let isImproperSuffix = AF.length volSuffix == AF.length frag
+                      fragSuffixOneLonger =
+                        AF.anchorNewest (fromIntegral (AF.length volSuffix) + 1) frag
+                      weightOneLonger = totalWeightOfFragment snap fragSuffixOneLonger
+                   in isImproperSuffix .||. weightOneLonger `gt` maxRollbackWeight tsSecParam
+              , counterexample ("Volatile suffix of " <> condense frag <> " must contain at most k blocks") $
+                  AF.length volSuffix `le` fromIntegral (unNonZero (maxRollbacks tsSecParam))
+              ]
+          | frag <- tsFragments
+          , let volSuffix = takeVolatileSuffix snap tsSecParam frag
+          ]
+      ]
+ where
+  TestSetup
+    { tsWeights
+    , tsPoints
+    , tsFragments
+    , tsSecParam
+    } = testSetup
+
+  snap = mkPerasWeightSnapshot $ Map.toList tsWeights
+
+  weightBoostOfPointReference :: Point TestBlock -> PerasWeight
+  weightBoostOfPointReference pt = Map.findWithDefault mempty pt tsWeights
+
+  weightBoostOfFragmentReference :: AnchoredFragment TestBlock -> PerasWeight
+  weightBoostOfFragmentReference frag =
+    foldMap
+      (weightBoostOfPointReference . blockPoint)
+      (AF.toOldestFirst frag)
+
+  takeVolatileSuffixReference ::
+    AnchoredFragment TestBlock -> AnchoredFragment TestBlock
+  takeVolatileSuffixReference =
+    fromJust . find hasWeightAtMostK . suffixes
+   where
+    -- Consider suffixes of @frag@, longest first
+    suffixes frag =
+      [ AF.anchorNewest (fromIntegral len) frag
+      | len <- reverse [0 .. AF.length frag]
+      ]
+
+    hasWeightAtMostK frag =
+      totalWeight <= maxRollbackWeight tsSecParam
+     where
+      weightBoost = weightBoostOfFragmentReference frag
+      lengthWeight = PerasWeight (fromIntegral (AF.length frag))
+      totalWeight = lengthWeight <> weightBoost
+
+-- | Test that the weight of a fragment is equal to the weight of its
+-- first\/last point plus the weight of the remaining suffix\/infix.
+prop_fragmentInduction ::
+  PerasWeightSnapshot TestBlock ->
+  AnchoredFragment TestBlock ->
+  Property
+prop_fragmentInduction snap =
+  \frag -> fromLeft frag .&&. fromRight frag
+ where
+  fromLeft :: AnchoredFragment TestBlock -> Property
+  fromLeft frag = case frag of
+    AF.Empty _ ->
+      weightBoostOfFragment snap frag === mempty
+    b AF.:< frag' ->
+      weightBoostOfFragment snap frag
+        === weightBoostOfPoint snap (blockPoint b) <> weightBoostOfFragment snap frag'
+
+  fromRight :: AnchoredFragment TestBlock -> Property
+  fromRight frag = case frag of
+    AF.Empty _ ->
+      weightBoostOfFragment snap frag === mempty
+    frag' AF.:> b ->
+      weightBoostOfFragment snap frag
+        === weightBoostOfPoint snap (blockPoint b) <> weightBoostOfFragment snap frag'
+
+data TestSetup = TestSetup
+  { tsWeights :: Map (Point TestBlock) PerasWeight
+  , tsPoints :: [Point TestBlock]
+  -- ^ Check the weight of these points.
+  , tsFragments :: [AnchoredFragment TestBlock]
+  -- ^ Check the weight of these fragments.
+  , tsSecParam :: SecurityParam
+  }
+  deriving stock Show
+
+instance Arbitrary TestSetup where
+  arbitrary = do
+    -- Generate a block tree rooted at Genesis.
+    tree :: BlockTree <- arbitrary
+
+    let
+      -- Points for all blocks in the block tree.
+      tsPoints :: [Point TestBlock]
+      tsPoints = nubOrd $ GenesisPoint : (blockPoint <$> treeToBlocks tree)
+
+      -- Chains from Genesis to all leaves of the block tree.
+      treeChains :: [Chain TestBlock]
+      treeChains = treeToChains tree
+
+    -- Randomly boost some points. This might need to be refined in the future
+    -- (as per https://github.com/tweag/cardano-peras/issues/124).
+    tsWeights :: Map (Point TestBlock) PerasWeight <-
+      Map.fromList . catMaybes <$> for tsPoints \pt ->
+        fmap (pt,) <$> genWeightBoost
+
+    -- Generate a list of fragments as random infixes of the @treeChains@.
+    tsFragments <-
+      for treeChains genInfixFragment
+
+    tsSecParam <- arbitrary
+    pure
+      TestSetup
+        { tsWeights
+        , tsPoints
+        , tsFragments
+        , tsSecParam
+        }
+   where
+    -- Generate a weight boost (for some point).
+    genWeightBoost :: Gen (Maybe PerasWeight)
+    genWeightBoost =
+      frequency
+        [ (3, pure Nothing)
+        , (1, Just . PerasWeight <$> choose (1, 10))
+        ]
+
+    -- Given a chain, generate an infix fragment of that chain.
+    genInfixFragment :: Chain TestBlock -> Gen (AnchoredFragment TestBlock)
+    genInfixFragment chain = do
+      let lenChain = Chain.length chain
+          fullFrag = Chain.toAnchoredFragment chain
+      nTakeNewest <- choose (0, lenChain)
+      nDropNewest <- choose (0, nTakeNewest)
+      pure $
+        AF.dropNewest nDropNewest $
+          AF.anchorNewest (fromIntegral nTakeNewest) fullFrag
+
+  shrink ts =
+    concat
+      [ [ ts{tsWeights = Map.fromList tsWeights'}
+        | tsWeights' <-
+            shrinkList
+              (\(pt, w) -> (pt,) <$> shrinkWeight w)
+              $ Map.toList tsWeights
+        ]
+      , [ ts{tsPoints = tsPoints'}
+        | tsPoints' <- shrinkList (\_pt -> []) tsPoints
+        ]
+      , [ ts{tsFragments = tsFragments'}
+        | tsFragments' <- shrinkList (\_frag -> []) tsFragments
+        ]
+      , [ ts{tsSecParam = tsSecParam'}
+        | tsSecParam' <- shrink tsSecParam
+        ]
+      ]
+   where
+    -- Decrease by @1@, unless this would mean that it is non-positive.
+    shrinkWeight :: PerasWeight -> [PerasWeight]
+    shrinkWeight (PerasWeight w)
+      | w >= 1 = [PerasWeight (w - 1)]
+      | otherwise = []
+
+    TestSetup
+      { tsWeights
+      , tsPoints
+      , tsFragments
+      , tsSecParam
+      } = ts
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage.hs
index 419d8872a..1153457c7 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage.hs
@@ -5,6 +5,7 @@ module Test.Ouroboros.Storage (tests) where
 import qualified Test.Ouroboros.Storage.ChainDB as ChainDB
 import qualified Test.Ouroboros.Storage.ImmutableDB as ImmutableDB
 import qualified Test.Ouroboros.Storage.LedgerDB as LedgerDB
+import qualified Test.Ouroboros.Storage.PerasCertDB as PerasCertDB
 import qualified Test.Ouroboros.Storage.VolatileDB as VolatileDB
 import Test.Tasty (TestTree, testGroup)
 
@@ -20,4 +21,5 @@ tests =
     , VolatileDB.tests
     , LedgerDB.tests
     , ChainDB.tests
+    , PerasCertDB.tests
     ]
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model.hs
index d8cbf1acb..910c7e113 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model.hs
@@ -25,6 +25,7 @@ module Test.Ouroboros.Storage.ChainDB.Model
   , addBlock
   , addBlockPromise
   , addBlocks
+  , addPerasCert
   , empty
 
     -- * Queries
@@ -44,7 +45,7 @@ module Test.Ouroboros.Storage.ChainDB.Model
   , invalid
   , isOpen
   , isValid
-  , lastK
+  , maxPerasRoundNo
   , tipBlock
   , tipPoint
   , volatileChain
@@ -90,6 +91,7 @@ import Control.Monad.Except (runExcept)
 import Data.Bifunctor (first)
 import qualified Data.ByteString.Lazy as Lazy
 import Data.Containers.ListUtils (nubOrdOn)
+import Data.Foldable (foldMap')
 import Data.Function (on, (&))
 import Data.Functor (($>), (<&>))
 import Data.List (isInfixOf, isPrefixOf, sortBy)
@@ -100,7 +102,6 @@ import Data.Proxy
 import Data.Set (Set)
 import qualified Data.Set as Set
 import Data.TreeDiff
-import Data.Word (Word64)
 import GHC.Generics (Generic)
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
@@ -108,6 +109,8 @@ import Ouroboros.Consensus.HeaderValidation
 import Ouroboros.Consensus.Ledger.Abstract
 import Ouroboros.Consensus.Ledger.Extended
 import Ouroboros.Consensus.Ledger.SupportsProtocol
+import Ouroboros.Consensus.Peras.SelectView
+import Ouroboros.Consensus.Peras.Weight
 import Ouroboros.Consensus.Protocol.Abstract
 import Ouroboros.Consensus.Protocol.MockChainSel
 import Ouroboros.Consensus.Storage.ChainDB.API
@@ -145,6 +148,7 @@ data Model blk = Model
   -- ^ The VolatileDB
   , immutableDbChain :: Chain blk
   -- ^ The ImmutableDB
+  , perasCerts :: Map PerasRoundNo (ValidatedPerasCert blk)
   , cps :: CPS.ChainProducerState blk
   , currentLedger :: ExtLedgerState blk EmptyMK
   , initLedger :: ExtLedgerState blk EmptyMK
@@ -231,72 +235,78 @@ tipPoint = maybe GenesisPoint blockPoint . tipBlock
 getMaxSlotNo :: HasHeader blk => Model blk -> MaxSlotNo
 getMaxSlotNo = foldMap (MaxSlotNo . blockSlot) . blocks
 
-lastK ::
-  HasHeader a =>
-  SecurityParam ->
-  -- | Provided since `AnchoredFragment` is not a functor
-  (blk -> a) ->
-  Model blk ->
-  AnchoredFragment a
-lastK (SecurityParam k) f =
-  Fragment.anchorNewest (unNonZero k)
-    . Chain.toAnchoredFragment
-    . fmap f
-    . currentChain
-
--- | Actual number of blocks that can be rolled back. Equal to @k@, except
--- when:
+-- | Actual amount of weight that can be rolled back. This can non-trivially
+-- smaller than @k@ in the following cases:
 --
--- * Near genesis, the chain might not be @k@ blocks long yet.
--- * After VolatileDB corruption, the whole chain might be >= @k@ blocks, but
---   the tip of the ImmutableDB might be closer than @k@ blocks away from the
---   current chain's tip.
-maxActualRollback :: HasHeader blk => SecurityParam -> Model blk -> Word64
+-- * Near genesis, the chain might not have grown sufficiently yet.
+-- * After VolatileDB corruption, the whole chain might have more than weight
+--   @k@, but the tip of the ImmutableDB might be buried under significantly
+--   less than weight @k@ worth of blocks.
+maxActualRollback :: HasHeader blk => SecurityParam -> Model blk -> PerasWeight
 maxActualRollback k m =
-  fromIntegral
-    . length
+  foldMap' (weightBoostOfPoint weights)
     . takeWhile (/= immutableTipPoint)
     . map blockPoint
     . Chain.toNewestFirst
     . currentChain
     $ m
  where
+  weights = perasWeights m
+
   immutableTipPoint = Chain.headPoint (immutableChain k m)
 
 -- | Return the immutable prefix of the current chain.
 --
 -- This is the longest of the given two chains:
 --
--- 1. The current chain with the last @k@ blocks dropped.
+-- 1. The current chain with the longest suffix of weight at most @k@ dropped.
 -- 2. The chain formed by the blocks in 'immutableDbChain', i.e., the
 --    \"ImmutableDB\". We need to take this case in consideration because the
 --    VolatileDB might have been wiped.
 --
--- We need this because we do not allow rolling back more than @k@ blocks, but
+-- We need this because we do not allow rolling back more than weight @k@, but
 -- the background thread copying blocks from the VolatileDB to the ImmutableDB
 -- might not have caught up yet. This means we cannot use the tip of the
 -- ImmutableDB to know the most recent \"immutable\" block.
 immutableChain ::
+  forall blk.
+  HasHeader blk =>
   SecurityParam ->
   Model blk ->
   Chain blk
-immutableChain (SecurityParam k) m =
+immutableChain k m =
   maxBy
+    -- As one of the two chains is a prefix of the other, Peras weight doesn't
+    -- matter here.
     Chain.length
-    (Chain.drop (fromIntegral $ unNonZero k) (currentChain m))
+    (dropAtMostWeight (maxRollbackWeight k) (currentChain m))
     (immutableDbChain m)
  where
   maxBy f a b
     | f a >= f b = a
     | otherwise = b
 
+  weights = perasWeights m
+
+  -- Drop the longest suffix with at most the given weight.
+  dropAtMostWeight :: PerasWeight -> Chain blk -> Chain blk
+  dropAtMostWeight budget = go mempty
+   where
+    go w = \case
+      Genesis -> Genesis
+      c@(c' :> b)
+        | w' <= budget -> go w' c'
+        | otherwise -> c
+       where
+        w' = w <> PerasWeight 1 <> weightBoostOfPoint weights (blockPoint b)
+
 -- | Return the volatile suffix of the current chain.
 --
 -- The opposite of 'immutableChain'.
 --
 -- This is the shortest of the given two chain fragments:
 --
--- 1. The last @k@ blocks of the current chain.
+-- 1. The longest suffix of the current chain with weight at most @k@.
 -- 2. The suffix of the current chain not part of the 'immutableDbChain', i.e.,
 --    the \"ImmutableDB\".
 volatileChain ::
@@ -368,6 +378,16 @@ isValid = flip getIsValid
 getLoEFragment :: Model blk -> LoE (AnchoredFragment blk)
 getLoEFragment = loeFragment
 
+perasWeights :: StandardHash blk => Model blk -> PerasWeightSnapshot blk
+perasWeights =
+  mkPerasWeightSnapshot
+    . fmap (\cert -> (getPerasCertBoostedBlock cert, getPerasCertBoost cert))
+    . Map.elems
+    . perasCerts
+
+maxPerasRoundNo :: Model blk -> Maybe PerasRoundNo
+maxPerasRoundNo m = fst <$> Map.lookupMax (perasCerts m)
+
 {-------------------------------------------------------------------------------
   Construction
 -------------------------------------------------------------------------------}
@@ -381,6 +401,7 @@ empty loe initLedger =
   Model
     { volatileDbBlocks = Map.empty
     , immutableDbChain = Chain.Genesis
+    , perasCerts = Map.empty
     , cps = CPS.initChainProducerState Chain.Genesis
     , currentLedger = initLedger
     , initLedger = initLedger
@@ -420,6 +441,23 @@ addBlock cfg blk m
       -- If it's an invalid block we've seen before, ignore it.
       Map.member (blockHash blk) (invalid m)
 
+addPerasCert ::
+  forall blk.
+  (LedgerSupportsProtocol blk, LedgerTablesAreTrivial (ExtLedgerState blk)) =>
+  TopLevelConfig blk ->
+  ValidatedPerasCert blk ->
+  Model blk ->
+  Model blk
+addPerasCert cfg cert m
+  -- Do not alter the model when a certificate for that round already exists.
+  | Map.member certRound (perasCerts m) = m
+  | otherwise =
+      chainSelection
+        cfg
+        m{perasCerts = Map.insert certRound cert (perasCerts m)}
+ where
+  certRound = getPerasCertRound cert
+
 chainSelection ::
   forall blk.
   ( LedgerTablesAreTrivial (ExtLedgerState blk)
@@ -432,6 +470,7 @@ chainSelection cfg m =
   Model
     { volatileDbBlocks = volatileDbBlocks m
     , immutableDbChain = immutableDbChain m
+    , perasCerts = perasCerts m
     , cps = CPS.switchFork newChain (cps m)
     , currentLedger = newLedger
     , initLedger = initLedger m
@@ -531,7 +570,10 @@ chainSelection cfg m =
       . selectChain
         (Proxy @(BlockProtocol blk))
         (projectChainOrderConfig (configBlock cfg))
-        (selectView (configBlock cfg) . getHeader)
+        ( weightedSelectView (configBlock cfg) (perasWeights m)
+            . Chain.toAnchoredFragment
+            . fmap getHeader
+        )
         (currentChain m)
       $ consideredCandidates
 
@@ -863,7 +905,7 @@ validChains cfg m bs =
   sortChains =
     sortBy $
       flip
-        ( Fragment.compareAnchoredFragments (configBlock cfg)
+        ( Fragment.compareAnchoredFragments (configBlock cfg) (perasWeights m)
             `on` (Chain.toAnchoredFragment . fmap getHeader)
         )
 
@@ -899,7 +941,11 @@ between k from to m = do
   fork <- errFork
   -- See #871.
   if partOfCurrentChain fork
-    || Fragment.forksAtMostKBlocks (maxActualRollback k m) currentFrag fork
+    || Fragment.forksAtMostKWeight
+      (perasWeights m)
+      (maxActualRollback k m)
+      currentFrag
+      fork
     then return $ Fragment.toOldestFirst fork
     -- We cannot stream from an old fork
     else Left $ ForkTooOld from
@@ -1039,6 +1085,8 @@ garbageCollect ::
 garbageCollect secParam m@Model{..} =
   m
     { volatileDbBlocks = Map.filter (not . collectable) volatileDbBlocks
+    -- TODO garbage collection Peras certs?
+    -- See https://github.com/tweag/cardano-peras/issues/121
     }
  where
   -- TODO what about iterators that will stream garbage collected blocks?
@@ -1078,6 +1126,8 @@ closeDB m@Model{..} =
 reopen :: Model blk -> Model blk
 reopen m = m{isOpen = True}
 
+-- TODO: update to account for persisted Peras certificates.
+-- see https://github.com/tweag/cardano-peras/issues/122
 wipeVolatileDB ::
   forall blk.
   (LedgerSupportsProtocol blk, LedgerTablesAreTrivial (ExtLedgerState blk)) =>
@@ -1090,6 +1140,7 @@ wipeVolatileDB cfg m =
   m' =
     (closeDB m)
       { volatileDbBlocks = Map.empty
+      , perasCerts = Map.empty
       , cps = CPS.switchFork newChain (cps m)
       , currentLedger = newLedger
       , invalid = Map.empty
@@ -1108,7 +1159,11 @@ wipeVolatileDB cfg m =
       $ selectChain
         (Proxy @(BlockProtocol blk))
         (projectChainOrderConfig (configBlock cfg))
-        (selectView (configBlock cfg) . getHeader)
+        -- Weight is inconsequential as there is only a single candidate.
+        ( weightedSelectView (configBlock cfg) emptyPerasWeightSnapshot
+            . Chain.toAnchoredFragment
+            . fmap getHeader
+        )
         Chain.genesis
       $ snd
       $ validChains cfg m (immutableDbBlocks m)
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model/Test.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model/Test.hs
index 6293e1196..b991a13da 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model/Test.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/Model/Test.hs
@@ -22,11 +22,11 @@
 -- chain DB, we always pick the most preferred chain.
 module Test.Ouroboros.Storage.ChainDB.Model.Test (tests) where
 
-import Cardano.Ledger.BaseTypes (unNonZero)
 import GHC.Stack
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
 import Ouroboros.Consensus.Ledger.Tables
+import Ouroboros.Consensus.Peras.Weight
 import Ouroboros.Consensus.Storage.ChainDB.API
   ( LoE (..)
   , StreamFrom (..)
@@ -96,16 +96,21 @@ prop_alwaysPickPreferredChain bt p =
 
   curFragment = Chain.toAnchoredFragment (getHeader <$> current)
 
-  SecurityParam k = configSecurityParam singleNodeTestConfig
+  k = configSecurityParam singleNodeTestConfig
 
   bcfg = configBlock singleNodeTestConfig
 
   preferCandidate' candidate =
-    AF.preferAnchoredCandidate bcfg curFragment candFragment
-      && AF.forksAtMostKBlocks (unNonZero k) curFragment candFragment
+    AF.preferAnchoredCandidate bcfg weights curFragment candFragment
+      && AF.forksAtMostKWeight weights (maxRollbackWeight k) curFragment candFragment
    where
     candFragment = Chain.toAnchoredFragment (getHeader <$> candidate)
 
+    -- TODO test with non-trivial weights
+    -- see https://github.com/tweag/cardano-peras/issues/123
+    weights :: PerasWeightSnapshot TestBlock
+    weights = emptyPerasWeightSnapshot
+
 -- TODO add properties about forks too
 prop_between_currentChain :: LoE () -> BlockTree -> Property
 prop_between_currentChain loe bt =
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/StateMachine.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/StateMachine.hs
index 4e97810d9..e3a787a6c 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/StateMachine.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/ChainDB/StateMachine.hs
@@ -127,6 +127,7 @@ import Ouroboros.Consensus.Storage.ImmutableDB.Chunks.Internal
 import Ouroboros.Consensus.Storage.LedgerDB (LedgerSupportsLedgerDB)
 import qualified Ouroboros.Consensus.Storage.LedgerDB.TraceEvent as LedgerDB
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.DbChangelog as DbChangelog
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
 import qualified Ouroboros.Consensus.Storage.VolatileDB as VolatileDB
 import Ouroboros.Consensus.Util (split)
 import Ouroboros.Consensus.Util.CallStack
@@ -178,6 +179,7 @@ import Test.Util.WithEq
 -- | Commands
 data Cmd blk it flr
   = AddBlock blk
+  | AddPerasCert (ValidatedPerasCert blk)
   | GetCurrentChain
   | GetTipBlock
   | GetTipHeader
@@ -402,8 +404,9 @@ run ::
   Cmd blk (TestIterator m blk) (TestFollower m blk) ->
   m (Success blk (TestIterator m blk) (TestFollower m blk))
 run cfg env@ChainDBEnv{varDB, ..} cmd =
-  readTVarIO varDB >>= \st@ChainDBState{chainDB = ChainDB{..}, internal} -> case cmd of
+  readTVarIO varDB >>= \st@ChainDBState{chainDB = chainDB@ChainDB{..}, internal} -> case cmd of
     AddBlock blk -> Point <$> advanceAndAdd st blk
+    AddPerasCert cert -> Unit <$> addPerasCertSync chainDB cert
     GetCurrentChain -> Chain <$> atomically getCurrentChain
     GetTipBlock -> MbBlock <$> getTipBlock
     GetTipHeader -> MbHeader <$> getTipHeader
@@ -638,6 +641,7 @@ runPure ::
   (Resp blk IteratorId FollowerId, DBModel blk)
 runPure cfg = \case
   AddBlock blk -> ok Point $ update (add blk)
+  AddPerasCert cert -> ok Unit $ ((),) . update (Model.addPerasCert cfg cert)
   GetCurrentChain -> ok Chain $ query (Model.volatileChain k getHeader)
   GetTipBlock -> ok MbBlock $ query Model.tipBlock
   GetTipHeader -> ok MbHeader $ query (fmap getHeader . Model.tipBlock)
@@ -909,6 +913,11 @@ generator loe genBlock m@Model{..} =
   At
     <$> frequency
       [ (30, genAddBlock)
+      , let freq = case loe of
+              LoEDisabled -> 10
+              -- The LoE does not yet support Peras.
+              LoEEnabled () -> 0
+         in (freq, AddPerasCert <$> genAddPerasCert)
       , (if empty then 1 else 10, return GetCurrentChain)
       , --    , (if empty then 1 else 10, return GetLedgerDB)
         (if empty then 1 else 10, return GetTipBlock)
@@ -1034,6 +1043,24 @@ generator loe genBlock m@Model{..} =
 
   genAddBlock = AddBlock <$> genBlock m
 
+  genAddPerasCert :: Gen (ValidatedPerasCert blk)
+  genAddPerasCert = do
+    -- TODO should we be more strict on which blocks we add certs to?
+    -- see https://github.com/tweag/cardano-peras/issues/124
+    blk <- genBlock m
+    let roundNo = case Model.maxPerasRoundNo dbModel of
+          Nothing -> PerasRoundNo 0
+          Just (PerasRoundNo r) -> PerasRoundNo (r + 1)
+    pure $
+      ValidatedPerasCert
+        { vpcCert =
+            PerasCert
+              { pcCertRound = roundNo
+              , pcCertBoostedBlock = blockPoint blk
+              }
+        , vpcCertBoost = boostPerCert
+        }
+
   genBounds :: Gen (StreamFrom blk, StreamTo blk)
   genBounds =
     frequency
@@ -1232,16 +1259,33 @@ invariant cfg Model{..} =
 
 postcondition ::
   TestConstraints blk =>
+  TopLevelConfig blk ->
   Model blk m Concrete ->
   At Cmd blk m Concrete ->
   At Resp blk m Concrete ->
   Logic
-postcondition model cmd resp =
+postcondition cfg model cmd resp =
   (toMock (eventAfter ev) resp .== eventMockResp ev)
     .// "real response didn't match model response"
+    .&& immutableTipMonotonicity
  where
   ev = lockstep model cmd resp
 
+  immutableTipMonotonicity = case unAt cmd of
+    -- When we wipe the VolatileDB (and haven't persisted all immutable blocks),
+    -- the immutable tip can recede.
+    WipeVolatileDB -> Top
+    _ ->
+      Annotate ("Immutable tip non-monotonicity: " <> show before <> " > " <> show after) $
+        Boolean (before <= after)
+   where
+    before = immTipBlockNo $ eventBefore ev
+    after = immTipBlockNo $ eventAfter ev
+    immTipBlockNo =
+      Chain.headBlockNo
+        . Model.immutableChain (configSecurityParam cfg)
+        . dbModel
+
 semantics ::
   forall blk.
   TestConstraints blk =>
@@ -1271,7 +1315,7 @@ sm loe env genBlock cfg initLedger =
     { initModel = initModel loe cfg initLedger
     , transition = transition
     , precondition = precondition
-    , postcondition = postcondition
+    , postcondition = postcondition cfg
     , generator = Just . generator loe genBlock
     , shrinker = shrinker
     , semantics = semantics cfg env
@@ -1329,14 +1373,19 @@ deriving instance SOP.Generic (ImmutableDB.TraceEvent blk)
 deriving instance SOP.HasDatatypeInfo (ImmutableDB.TraceEvent blk)
 deriving instance SOP.Generic (VolatileDB.TraceEvent blk)
 deriving instance SOP.HasDatatypeInfo (VolatileDB.TraceEvent blk)
+deriving instance SOP.Generic (PerasCertDB.TraceEvent blk)
+deriving instance SOP.HasDatatypeInfo (PerasCertDB.TraceEvent blk)
 deriving anyclass instance SOP.Generic (TraceChainSelStarvationEvent blk)
 deriving anyclass instance SOP.HasDatatypeInfo (TraceChainSelStarvationEvent blk)
+deriving anyclass instance SOP.Generic (TraceAddPerasCertEvent blk)
+deriving anyclass instance SOP.HasDatatypeInfo (TraceAddPerasCertEvent blk)
 
 data Tag
   = TagGetIsValidJust
   | TagGetIsValidNothing
   | TagChainSelReprocessChangedSelection
   | TagChainSelReprocessKeptSelection
+  | TagSwitchedToShorterChain
   deriving (Show, Eq)
 
 -- | Predicate on events
@@ -1363,6 +1412,7 @@ tag =
     , tagGetIsValidNothing
     , tagChainSelReprocess TagChainSelReprocessChangedSelection (/=)
     , tagChainSelReprocess TagChainSelReprocessKeptSelection (==)
+    , tagSwitchedToShorterChain
     ]
  where
   tagGetIsValidJust :: EventPred m
@@ -1387,6 +1437,21 @@ tag =
           Left t
     _ -> Right $ tagChainSelReprocess t test
 
+  -- Tag this test case if we ever switch from a longer to a shorter chain in a
+  -- non-degenerate case.
+  tagSwitchedToShorterChain :: EventPred m
+  tagSwitchedToShorterChain = C.predicate $ \case
+    ev
+      | case unAt $ eventCmd ev of
+          -- Wiping the VolatileDB is not interesting here.
+          WipeVolatileDB{} -> False
+          _ -> True
+      , ((>) `on` curChainLength) (eventBefore ev) (eventAfter ev) ->
+          Left TagSwitchedToShorterChain
+      | otherwise -> Right tagSwitchedToShorterChain
+   where
+    curChainLength = Chain.length . Model.currentChain . dbModel
+
 -- | Step the model using a 'QSM.Command' (i.e., a command associated with
 -- an explicit set of variables)
 execCmd ::
@@ -1755,8 +1820,10 @@ traceEventName = \case
   TraceLedgerDBEvent ev -> "Ledger." <> constrName ev
   TraceImmutableDBEvent ev -> "ImmutableDB." <> constrName ev
   TraceVolatileDBEvent ev -> "VolatileDB." <> constrName ev
+  TracePerasCertDbEvent ev -> "PerasCertDB." <> constrName ev
   TraceLastShutdownUnclean -> "LastShutdownUnclean"
   TraceChainSelStarvationEvent ev -> "ChainSelStarvation." <> constrName ev
+  TraceAddPerasCertEvent ev -> "AddPerasCert." <> constrName ev
 
 mkArgs ::
   IOLike m =>
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/Snapshots.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/Snapshots.hs
index e69c3b75e..c65ba8435 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/Snapshots.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/Snapshots.hs
@@ -35,3 +35,4 @@ instance Arbitrary SnapshotMetadata where
     SnapshotMetadata
       <$> arbitrary
       <*> fmap CRC arbitrary
+      <*> pure TablesCodecVersion1
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/StateMachine.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/StateMachine.hs
index 5ab41c055..1c45dae1b 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/StateMachine.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/StateMachine.hs
@@ -12,11 +12,11 @@
 {-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE MultiParamTypeClasses #-}
 {-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE PackageImports #-}
 {-# LANGUAGE PolyKinds #-}
 {-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-}
 {-# OPTIONS_GHC -Wno-orphans #-}
@@ -44,11 +44,11 @@ import Control.Monad.Except
 import Control.Monad.State hiding (state)
 import Control.ResourceRegistry
 import Control.Tracer (Tracer (..))
+import Data.Functor.Contravariant ((>$<))
 import qualified Data.List as L
 import Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
 import qualified Data.SOP.Dict as Dict
-import Data.Void
 import Data.Word
 import Ouroboros.Consensus.Block
 import Ouroboros.Consensus.Config
@@ -62,17 +62,17 @@ import qualified Ouroboros.Consensus.Storage.LedgerDB as LedgerDB
 import Ouroboros.Consensus.Storage.LedgerDB.Snapshots
 import Ouroboros.Consensus.Storage.LedgerDB.V1 as V1
 import Ouroboros.Consensus.Storage.LedgerDB.V1.Args hiding
-  ( LedgerDbFlavorArgs
+  ( LedgerDbBackendArgs
   )
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots as V1
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as V1
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.InMemory as V1.InMemory
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB as LMDB
+import Ouroboros.Consensus.Storage.LedgerDB.V1.Snapshots as V1
 import Ouroboros.Consensus.Storage.LedgerDB.V2 as V2
-import Ouroboros.Consensus.Storage.LedgerDB.V2.Args hiding
-  ( LedgerDbFlavorArgs
-  )
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.Args as V2
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as InMemory
+import Ouroboros.Consensus.Storage.LedgerDB.V2.Backend as V2
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.InMemory as V2.InMemory
+import qualified Ouroboros.Consensus.Storage.LedgerDB.V2.LSM as LSM
 import Ouroboros.Consensus.Util hiding (Some)
-import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.IOLike
 import qualified Ouroboros.Network.AnchoredSeq as AS
 import Ouroboros.Network.Protocol.LocalStateQuery.Type
@@ -89,13 +89,12 @@ import qualified Test.QuickCheck as QC
 import qualified Test.QuickCheck.Monadic as QC
 import Test.QuickCheck.StateModel
 import Test.Tasty
-import Test.Tasty.QuickCheck hiding (Some (..))
+import Test.Tasty.QuickCheck (frequency, tabulate, testProperty)
 import Test.Util.TestBlock hiding
   ( TestBlock
   , TestBlockCodecConfig
   , TestBlockStorageConfig
   )
-import "quickcheck-dynamic" Test.QuickCheck.Extras
 
 tests :: TestTree
 tests =
@@ -106,23 +105,45 @@ tests =
     , testProperty "InMemV2" $
         prop_sequential 100000 inMemV2TestArguments noFilePath simulatedFS
     , testProperty "LMDB" $
-        prop_sequential 1000 lmdbTestArguments realFilePath realFS
+        prop_sequential 1000 lmdbTestArguments (realFilePath "lmdb") realFS
+    , testProperty "LSM" $
+        prop_sequential 1000 lsmTestArguments (realFilePath "lsm") realFS
     ]
 
 prop_sequential ::
   Int ->
-  (SecurityParam -> FilePath -> TestArguments IO) ->
+  (SecurityParam -> LSM.Salt -> FilePath -> TestArguments IO) ->
   IO (FilePath, IO ()) ->
   IO (SomeHasFS IO, IO ()) ->
   Actions Model ->
   QC.Property
-prop_sequential maxSuccess mkTestArguments getLmdbDir fsOps as = QC.withMaxSuccess maxSuccess $
-  QC.monadicIO $ do
-    ref <- lift $ initialEnvironment fsOps getLmdbDir mkTestArguments =<< initChainDB
-    (_, env@(Environment _ testInternals _ _ _ _ clean)) <- runPropertyStateT (runActions as) ref
-    checkNoLeakedHandles env
-    QC.run $ closeLedgerDB testInternals >> clean
-    QC.assert True
+prop_sequential maxSuccess mkTestArguments getDiskDir fsOps actions =
+  QC.withMaxSuccess maxSuccess $
+    QC.monadic runner $
+      Monad.void $
+        runActions $
+          actions
+ where
+  setup :: IO Environment
+  setup = do
+    cdb <- initChainDB
+    rr <- unsafeNewRegistry
+    initialEnvironment fsOps getDiskDir mkTestArguments cdb rr
+
+  cleanup :: Environment -> IO ()
+  cleanup (Environment _ testInternals _ _ _ _ clean registry) = do
+    closeRegistry registry
+    closeLedgerDB testInternals
+    clean
+
+  runner :: StateT Environment IO QC.Property -> QC.Property
+  runner mprop =
+    QC.ioProperty $
+      bracket setup cleanup $
+        \env0 -> do
+          (prop1, env1) <- runStateT mprop env0
+          p2 <- checkNoLeakedHandles env1
+          pure $ prop1 QC..&&. p2
 
 -- | The initial environment is mostly undefined because it will be initialized
 -- by the @Init@ command. We are forced to provide this dummy implementation
@@ -132,37 +153,40 @@ prop_sequential maxSuccess mkTestArguments getLmdbDir fsOps as = QC.withMaxSucce
 initialEnvironment ::
   IO (SomeHasFS IO, IO ()) ->
   IO (FilePath, IO ()) ->
-  (SecurityParam -> FilePath -> TestArguments IO) ->
+  (SecurityParam -> LSM.Salt -> FilePath -> TestArguments IO) ->
   ChainDB IO ->
+  ResourceRegistry IO ->
   IO Environment
-initialEnvironment fsOps getLmdbDir mkTestArguments cdb = do
+initialEnvironment fsOps getDiskDir mkTestArguments cdb rr = do
   (sfs, cleanupFS) <- fsOps
-  (lmdbDir, cleanupLMDB) <- getLmdbDir
+  (diskDir, cleanupDisk) <- getDiskDir
   pure $
     Environment
       undefined
       (TestInternals undefined undefined undefined undefined undefined (pure ()) (pure 0))
       cdb
-      (flip mkTestArguments lmdbDir)
+      (\sp st -> mkTestArguments sp st diskDir)
       sfs
       (pure $ NumOpenHandles 0)
-      (cleanupFS >> cleanupLMDB)
+      (cleanupFS >> cleanupDisk)
+      rr
 
 {-------------------------------------------------------------------------------
   Arguments
 -------------------------------------------------------------------------------}
 
 data TestArguments m = TestArguments
-  { argFlavorArgs :: !(Complete LedgerDbFlavorArgs m)
+  { argFlavorArgs :: !(LedgerDbBackendArgs m TestBlock)
   , argLedgerDbCfg :: !(LedgerDbCfg (ExtLedgerState TestBlock))
   }
 
 noFilePath :: IO (FilePath, IO ())
 noFilePath = pure ("Bogus", pure ())
 
-realFilePath :: IO (FilePath, IO ())
-realFilePath = liftIO $ do
-  tmpdir <- (FilePath.</> "test_lmdb") <$> Dir.getTemporaryDirectory
+realFilePath :: String -> IO (FilePath, IO ())
+realFilePath l = liftIO $ do
+  tmpdir <- (FilePath.</> ("test_" <> l)) <$> Dir.getTemporaryDirectory
+  Dir.createDirectoryIfMissing False tmpdir
   pure
     ( tmpdir
     , do
@@ -183,34 +207,53 @@ realFS = liftIO $ do
 
 inMemV1TestArguments ::
   SecurityParam ->
+  LSM.Salt ->
   FilePath ->
   TestArguments IO
-inMemV1TestArguments secParam _ =
+inMemV1TestArguments secParam _ _ =
   TestArguments
-    { argFlavorArgs = LedgerDbFlavorArgsV1 $ V1Args DisableFlushing InMemoryBackingStoreArgs
+    { argFlavorArgs =
+        LedgerDbBackendArgsV1 $ V1Args DisableFlushing $ V1.SomeBackendArgs V1.InMemory.InMemArgs
     , argLedgerDbCfg = extLedgerDbConfig secParam
     }
 
 inMemV2TestArguments ::
   SecurityParam ->
+  LSM.Salt ->
+  FilePath ->
+  TestArguments IO
+inMemV2TestArguments secParam _ _ =
+  TestArguments
+    { argFlavorArgs = LedgerDbBackendArgsV2 $ SomeBackendArgs V2.InMemory.InMemArgs
+    , argLedgerDbCfg = extLedgerDbConfig secParam
+    }
+
+lsmTestArguments ::
+  SecurityParam ->
+  LSM.Salt ->
   FilePath ->
   TestArguments IO
-inMemV2TestArguments secParam _ =
+lsmTestArguments secParam salt fp =
   TestArguments
-    { argFlavorArgs = LedgerDbFlavorArgsV2 $ V2Args InMemoryHandleArgs
+    { argFlavorArgs =
+        LedgerDbBackendArgsV2 $
+          SomeBackendArgs $
+            LSM.LSMArgs (mkFsPath $ FilePath.splitDirectories fp) salt (LSM.stdMkBlockIOFS fp)
     , argLedgerDbCfg = extLedgerDbConfig secParam
     }
 
 lmdbTestArguments ::
   SecurityParam ->
+  LSM.Salt ->
   FilePath ->
   TestArguments IO
-lmdbTestArguments secParam fp =
+lmdbTestArguments secParam _ fp =
   TestArguments
     { argFlavorArgs =
-        LedgerDbFlavorArgsV1 $
+        LedgerDbBackendArgsV1 $
           V1Args DisableFlushing $
-            LMDBBackingStoreArgs fp (testLMDBLimits 16) Dict.Dict
+            V1.SomeBackendArgs $
+              LMDB.LMDBBackingStoreArgs fp (testLMDBLimits 16) Dict.Dict
     , argLedgerDbCfg = extLedgerDbConfig secParam
     }
 
@@ -278,11 +321,11 @@ instance StateModel Model where
   data Action Model a where
     WipeLedgerDB :: Action Model ()
     TruncateSnapshots :: Action Model ()
-    DropAndRestore :: Word64 -> Action Model ()
+    DropAndRestore :: Word64 -> LSM.Salt -> Action Model ()
     ForceTakeSnapshot :: Action Model ()
     GetState ::
       Action Model (ExtLedgerState TestBlock EmptyMK, ExtLedgerState TestBlock EmptyMK)
-    Init :: SecurityParam -> Action Model ()
+    Init :: SecurityParam -> LSM.Salt -> Action Model ()
     ValidateAndCommit :: Word64 -> [TestBlock] -> Action Model ()
     -- \| This action is used only to observe the side effects of closing an
     -- uncommitted forker, to ensure all handles are properly deallocated.
@@ -297,12 +340,12 @@ instance StateModel Model where
   actionName ValidateAndCommit{} = "ValidateAndCommit"
   actionName OpenAndCloseForker = "OpenAndCloseForker"
 
-  arbitraryAction _ UnInit = Some . Init <$> QC.arbitrary
+  arbitraryAction _ UnInit = Some <$> (Init <$> QC.arbitrary <*> QC.arbitrary)
   arbitraryAction _ model@(Model chain secParam) =
     frequency $
       [ (2, pure $ Some GetState)
       , (2, pure $ Some ForceTakeSnapshot)
-      , (1, Some . DropAndRestore <$> QC.choose (0, fromIntegral $ AS.length chain))
+      , (1, Some <$> (DropAndRestore <$> QC.choose (0, fromIntegral $ AS.length chain) <*> QC.arbitrary))
       ,
         ( 4
         , Some <$> do
@@ -335,7 +378,7 @@ instance StateModel Model where
 
   initialState = UnInit
 
-  nextState _ (Init secParam) _var = Model (AS.Empty genesis) secParam
+  nextState _ (Init secParam _) _var = Model (AS.Empty genesis) secParam
   nextState state GetState _var = state
   nextState state ForceTakeSnapshot _var = state
   nextState state@(Model _ secParam) (ValidateAndCommit n blks) _var =
@@ -371,7 +414,7 @@ instance StateModel Model where
       mapM_ push blks
   nextState state WipeLedgerDB _var = state
   nextState state TruncateSnapshots _var = state
-  nextState state (DropAndRestore n) _var = modelRollback n state
+  nextState state (DropAndRestore n _) _var = modelRollback n state
   nextState state OpenAndCloseForker _var = state
   nextState UnInit _ _ = error "Uninitialized model created a command different than Init"
 
@@ -485,16 +528,16 @@ blockNotFound =
 -------------------------------------------------------------------------------}
 
 openLedgerDB ::
-  Complete LedgerDbFlavorArgs IO ->
+  LedgerDbBackendArgs IO TestBlock ->
   ChainDB IO ->
   LedgerDbCfg (ExtLedgerState TestBlock) ->
   SomeHasFS IO ->
+  ResourceRegistry IO ->
   IO (LedgerDB' IO TestBlock, TestInternals' IO TestBlock, IO NumOpenHandles)
-openLedgerDB flavArgs env cfg fs = do
+openLedgerDB flavArgs env cfg fs rr = do
   (stream, volBlocks) <- dbStreamAPI (ledgerDbCfgSecParam cfg) env
   let getBlock f = Map.findWithDefault (error blockNotFound) f <$> readTVarIO (dbBlocks env)
   replayGoal <- fmap (realPointToPoint . last . Map.keys) . atomically $ readTVar (dbBlocks env)
-  rr <- unsafeNewRegistry
   (tracer, getNumOpenHandles) <- mkTrackOpenHandles
   let args =
         LedgerDbArgs
@@ -507,8 +550,8 @@ openLedgerDB flavArgs env cfg fs = do
           rr
           DefaultQueryBatchSize
           Nothing
-  (ldb, _, od) <- case flavArgs of
-    LedgerDbFlavorArgsV1 bss ->
+  (ldb, _, od) <- case lgrBackendArgs args of
+    LedgerDbBackendArgsV1 bss ->
       let snapManager = V1.snapshotManager args
           initDb =
             V1.mkInitDb
@@ -518,17 +561,22 @@ openLedgerDB flavArgs env cfg fs = do
               snapManager
               (praosGetVolatileSuffix $ ledgerDbCfgSecParam cfg)
        in openDBInternal args initDb snapManager stream replayGoal
-    LedgerDbFlavorArgsV2 bss -> do
-      (snapManager, bss') <- case bss of
-        V2.V2Args V2.InMemoryHandleArgs -> pure (InMemory.snapshotManager args, V2.InMemoryHandleEnv)
-        V2.V2Args (V2.LSMHandleArgs (V2.LSMArgs x)) -> absurd x
-      let initDb =
-            V2.mkInitDb
-              args
-              bss'
-              getBlock
-              snapManager
-              (praosGetVolatileSuffix $ ledgerDbCfgSecParam cfg)
+    LedgerDbBackendArgsV2 (V2.SomeBackendArgs bArgs) -> do
+      res <-
+        mkResources
+          (Proxy @TestBlock)
+          (LedgerDBFlavorImplEvent . FlavorImplSpecificTraceV2 >$< lgrTracer args)
+          bArgs
+          (lgrRegistry args)
+          (lgrHasFS args)
+      let snapManager =
+            V2.snapshotManager
+              (Proxy @TestBlock)
+              res
+              (configCodec . getExtLedgerCfg . ledgerDbCfg $ lgrConfig args)
+              (LedgerDBSnapshotEvent >$< lgrTracer args)
+              (lgrHasFS args)
+      let initDb = V2.mkInitDb args getBlock snapManager (praosGetVolatileSuffix $ ledgerDbCfgSecParam cfg) res
       openDBInternal args initDb snapManager stream replayGoal
   withRegistry $ \reg -> do
     vr <- validateFork ldb reg (const $ pure ()) BlockCache.empty 0 (map getHeader volBlocks)
@@ -549,36 +597,38 @@ data Environment
       (LedgerDB' IO TestBlock)
       (TestInternals' IO TestBlock)
       (ChainDB IO)
-      (SecurityParam -> TestArguments IO)
+      (SecurityParam -> LSM.Salt -> TestArguments IO)
       (SomeHasFS IO)
-      (IO NumOpenHandles)
-      (IO ())
+      !(IO NumOpenHandles)
+      !(IO ())
+      !(ResourceRegistry IO)
 
 data LedgerDBError = ErrorValidateExceededRollback
 
 instance RunModel Model (StateT Environment IO) where
   type Error Model (StateT Environment IO) = LedgerDBError
 
-  perform _ (Init secParam) _ = do
-    Environment _ _ chainDb mkArgs fs _ cleanup <- get
+  perform _ (Init secParam salt) _ = do
+    Environment _ _ chainDb mkArgs fs _ cleanup rr <- get
     (ldb, testInternals, getNumOpenHandles) <- lift $ do
-      let args = mkArgs secParam
-      openLedgerDB (argFlavorArgs args) chainDb (argLedgerDbCfg args) fs
-    put (Environment ldb testInternals chainDb mkArgs fs getNumOpenHandles cleanup)
+      let args = mkArgs secParam salt
+      -- TODO after a drop and restore we restart the db but the session has been closed below where I wrote blahblahblah
+      openLedgerDB (argFlavorArgs args) chainDb (argLedgerDbCfg args) fs rr
+    put (Environment ldb testInternals chainDb mkArgs fs getNumOpenHandles cleanup rr)
     pure $ pure ()
   perform _ WipeLedgerDB _ = do
-    Environment _ testInternals _ _ _ _ _ <- get
+    Environment _ testInternals _ _ _ _ _ _ <- get
     lift $ wipeLedgerDB testInternals
     pure $ pure ()
   perform _ GetState _ = do
-    Environment ldb _ _ _ _ _ _ <- get
+    Environment ldb _ _ _ _ _ _ _ <- get
     lift $ fmap pure $ atomically $ (,) <$> getImmutableTip ldb <*> getVolatileTip ldb
   perform _ ForceTakeSnapshot _ = do
-    Environment _ testInternals _ _ _ _ _ <- get
+    Environment _ testInternals _ _ _ _ _ _ <- get
     lift $ takeSnapshotNOW testInternals TakeAtImmutableTip Nothing
     pure $ pure ()
   perform _ (ValidateAndCommit n blks) _ = do
-    Environment ldb _ chainDb _ _ _ _ <- get
+    Environment ldb _ chainDb _ _ _ _ _ <- get
     lift $ do
       atomically $
         modifyTVar (dbBlocks chainDb) $
@@ -594,15 +644,16 @@ instance RunModel Model (StateT Environment IO) where
             forkerClose forker
             pure $ pure ()
           ValidateExceededRollBack{} -> pure $ Left ErrorValidateExceededRollback
-          ValidateLedgerError (AnnLedgerError forker _ _) -> forkerClose forker >> error "Unexpected ledger error"
-  perform state@(Model _ secParam) (DropAndRestore n) lk = do
-    Environment _ testInternals chainDb _ _ _ _ <- get
+          ValidateLedgerError (AnnLedgerError forker _ err) -> forkerClose forker >> error ("Unexpected ledger error" <> show err)
+  perform state@(Model _ secParam) (DropAndRestore n salt) lk = do
+    Environment _ testInternals chainDb _ _ _ _ _ <- get
     lift $ do
       atomically $ modifyTVar (dbChain chainDb) (drop (fromIntegral n))
+      -- blahblahblah
       closeLedgerDB testInternals
-    perform state (Init secParam) lk
+    perform state (Init secParam salt) lk
   perform _ OpenAndCloseForker _ = do
-    Environment ldb _ _ _ _ _ _ <- get
+    Environment ldb _ _ _ _ _ _ _ <- get
     lift $ withRegistry $ \rr -> do
       eFrk <- LedgerDB.getForkerAtTarget ldb rr VolatileTip
       case eFrk of
@@ -610,7 +661,7 @@ instance RunModel Model (StateT Environment IO) where
         Right frk -> forkerClose frk
     pure $ pure ()
   perform _ TruncateSnapshots _ = do
-    Environment _ testInternals _ _ _ _ _ <- get
+    Environment _ testInternals _ _ _ _ _ _ <- get
     lift $ truncateSnapshots testInternals
     pure $ pure ()
   perform UnInit _ _ = error "Uninitialized model created a command different than Init"
@@ -666,13 +717,16 @@ mkTrackOpenHandles = do
           atomically $ modifyTVar varOpen $ case ev of
             V2.TraceLedgerTablesHandleCreate -> succ
             V2.TraceLedgerTablesHandleClose -> pred
+            _ -> id
         _ -> pure ()
   pure (tracer, readTVarIO varOpen)
 
 -- | Check that we didn't leak any 'LedgerTablesHandle's (with V2 only).
-checkNoLeakedHandles :: Environment -> QC.PropertyM IO ()
-checkNoLeakedHandles (Environment _ testInternals _ _ _ getNumOpenHandles _) = do
-  expected <- liftIO $ NumOpenHandles <$> LedgerDB.getNumLedgerTablesHandles testInternals
-  actual <- liftIO getNumOpenHandles
-  QC.assertWith (actual == expected) $
-    "leaked handles, expected " <> show expected <> ", but actual " <> show actual
+checkNoLeakedHandles :: Environment -> IO QC.Property
+checkNoLeakedHandles (Environment _ testInternals _ _ _ getNumOpenHandles _ _) = do
+  expected <- NumOpenHandles <$> LedgerDB.getNumLedgerTablesHandles testInternals
+  actual <- getNumOpenHandles
+  pure $
+    QC.counterexample
+      ("leaked handles, expected " <> show expected <> ", but actual " <> show actual)
+      (actual == expected)
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/V1/BackingStore.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/V1/BackingStore.hs
index 5d83cd924..7772d34d4 100644
--- a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/V1/BackingStore.hs
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/LedgerDB/V1/BackingStore.hs
@@ -36,11 +36,9 @@ import Data.Typeable
 import Ouroboros.Consensus.Ledger.Tables
 import qualified Ouroboros.Consensus.Ledger.Tables.Diff as Diff
 import Ouroboros.Consensus.Ledger.Tables.Utils
-import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.Args as BS
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore as BS
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.InMemory as InMemory
 import qualified Ouroboros.Consensus.Storage.LedgerDB.V1.BackingStore.Impl.LMDB as LMDB
-import Ouroboros.Consensus.Util.Args
 import Ouroboros.Consensus.Util.IOLike hiding
   ( MonadMask (..)
   , newMVar
@@ -80,19 +78,19 @@ tests =
     [ adjustOption (scaleQuickCheckTests 10) $
         testProperty "InMemory IO SimHasFS" $
           testWithIO $
-            setupBSEnv BS.InMemoryBackingStoreArgs setupSimHasFS (pure ())
+            setupBSEnv InMemory.InMemArgs setupSimHasFS (pure ())
     , adjustOption (scaleQuickCheckTests 10) $
         testProperty "InMemory IO IOHasFS" $
           testWithIO $ do
             (fp, cleanup) <- setupTempDir
-            setupBSEnv BS.InMemoryBackingStoreArgs (setupIOHasFS fp) cleanup
+            setupBSEnv InMemory.InMemArgs (setupIOHasFS fp) cleanup
     , adjustOption (scaleQuickCheckTests 2) $
         testProperty "LMDB IO IOHasFS" $
           testWithIO $ do
             (fp, cleanup) <- setupTempDir
             lmdbTmpDir <- (FilePath.</> "BS_LMDB") <$> Dir.getTemporaryDirectory
             setupBSEnv
-              (BS.LMDBBackingStoreArgs lmdbTmpDir (testLMDBLimits maxOpenValueHandles) Dict.Dict)
+              (LMDB.LMDBBackingStoreArgs lmdbTmpDir (testLMDBLimits maxOpenValueHandles) Dict.Dict)
               (setupIOHasFS fp)
               (cleanup >> Dir.removeDirectoryRecursive lmdbTmpDir)
     ]
@@ -142,8 +140,9 @@ setupTempDir = do
   pure (qsmTmpDir, liftIO $ Dir.removeDirectoryRecursive qsmTmpDir)
 
 setupBSEnv ::
+  BS.Backend m backend (OTLedgerState (QC.Fixed Word) (QC.Fixed Word)) =>
   IOLike m =>
-  Complete BS.BackingStoreArgs m ->
+  BS.Args m backend ->
   m (SomeHasFS m) ->
   m () ->
   m (BSEnv m K K' V D)
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB.hs
new file mode 100644
index 000000000..6a3f06bf9
--- /dev/null
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB.hs
@@ -0,0 +1,17 @@
+{-# LANGUAGE CPP #-}
+
+module Test.Ouroboros.Storage.PerasCertDB (tests) where
+
+import qualified Test.Ouroboros.Storage.PerasCertDB.StateMachine as StateMachine
+import Test.Tasty (TestTree, testGroup)
+
+--
+-- The list of all PerasCertDB tests
+--
+
+tests :: TestTree
+tests =
+  testGroup
+    "PerasCertDB"
+    [ StateMachine.tests
+    ]
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/Model.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/Model.hs
new file mode 100644
index 000000000..9808ffe21
--- /dev/null
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/Model.hs
@@ -0,0 +1,72 @@
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE NamedFieldPuns #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE UndecidableInstances #-}
+
+module Test.Ouroboros.Storage.PerasCertDB.Model
+  ( Model (..)
+  , initModel
+  , openDB
+  , closeDB
+  , addCert
+  , getWeightSnapshot
+  , garbageCollect
+  , hasRoundNo
+  ) where
+
+import Data.Set (Set)
+import qualified Data.Set as Set
+import GHC.Generics (Generic)
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight
+  ( PerasWeightSnapshot
+  , mkPerasWeightSnapshot
+  )
+
+data Model blk = Model
+  { certs :: Set (ValidatedPerasCert blk)
+  , open :: Bool
+  }
+  deriving Generic
+
+deriving instance StandardHash blk => Show (Model blk)
+
+initModel :: Model blk
+initModel = Model{open = False, certs = Set.empty}
+
+openDB :: Model blk -> Model blk
+openDB model = model{open = True}
+
+closeDB :: Model blk -> Model blk
+closeDB _ = Model{open = False, certs = Set.empty}
+
+addCert ::
+  StandardHash blk =>
+  Model blk -> ValidatedPerasCert blk -> Model blk
+addCert model@Model{certs} cert
+  | certs `hasRoundNo` cert = model
+  | otherwise = model{certs = Set.insert cert certs}
+
+hasRoundNo ::
+  StandardHash blk =>
+  Set (ValidatedPerasCert blk) ->
+  ValidatedPerasCert blk ->
+  Bool
+hasRoundNo certs cert =
+  (getPerasCertRound cert) `Set.member` (Set.map getPerasCertRound certs)
+
+getWeightSnapshot ::
+  StandardHash blk =>
+  Model blk -> PerasWeightSnapshot blk
+getWeightSnapshot Model{certs} =
+  mkPerasWeightSnapshot
+    [ (getPerasCertBoostedBlock cert, getPerasCertBoost cert)
+    | cert <- Set.toList certs
+    ]
+
+garbageCollect :: StandardHash blk => SlotNo -> Model blk -> Model blk
+garbageCollect slot model@Model{certs} =
+  model{certs = Set.filter keepCert certs}
+ where
+  keepCert cert = pointSlot (getPerasCertBoostedBlock cert) >= NotOrigin slot
diff --git a/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/StateMachine.hs b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/StateMachine.hs
new file mode 100644
index 000000000..5df29e3d2
--- /dev/null
+++ b/ouroboros-consensus/test/storage-test/Test/Ouroboros/Storage/PerasCertDB/StateMachine.hs
@@ -0,0 +1,167 @@
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE DeriveGeneric #-}
+{-# LANGUAGE DerivingStrategies #-}
+{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE OverloadedRecordDot #-}
+{-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances #-}
+
+#if !MIN_VERSION_QuickCheck(2,16,0)
+{-# OPTIONS_GHC -Wno-dodgy-imports #-}
+#endif
+
+module Test.Ouroboros.Storage.PerasCertDB.StateMachine (tests) where
+
+import Control.Monad.State
+import Control.Tracer (nullTracer)
+import Data.Function ((&))
+import qualified Data.List.NonEmpty as NE
+import qualified Data.Set as Set
+import Ouroboros.Consensus.Block
+import Ouroboros.Consensus.Peras.Weight (PerasWeightSnapshot)
+import qualified Ouroboros.Consensus.Storage.PerasCertDB as PerasCertDB
+import Ouroboros.Consensus.Storage.PerasCertDB.API (AddPerasCertResult (..), PerasCertDB)
+import Ouroboros.Consensus.Util.IOLike
+import Ouroboros.Consensus.Util.STM
+import qualified Test.Ouroboros.Storage.PerasCertDB.Model as Model
+import Test.QuickCheck hiding (Some (..))
+import qualified Test.QuickCheck.Monadic as QC
+import Test.QuickCheck.StateModel
+import Test.Tasty
+import Test.Tasty.QuickCheck hiding (Some (..))
+import Test.Util.TestBlock (TestBlock, TestHash (..))
+import Test.Util.TestEnv (adjustQuickCheckTests)
+
+tests :: TestTree
+tests =
+  testGroup
+    "PerasCertDB"
+    [ adjustQuickCheckTests (* 100) $ testProperty "q-d" $ prop_qd
+    ]
+
+prop_qd :: Actions Model -> Property
+prop_qd actions = QC.monadic f $ property () <$ runActions actions
+ where
+  f :: StateT (PerasCertDB IO TestBlock) IO Property -> Property
+  f = ioProperty . flip evalStateT (error "unreachable")
+
+newtype Model = Model (Model.Model TestBlock) deriving (Show, Generic)
+
+instance StateModel Model where
+  data Action Model a where
+    OpenDB :: Action Model ()
+    CloseDB :: Action Model ()
+    AddCert :: ValidatedPerasCert TestBlock -> Action Model AddPerasCertResult
+    GetWeightSnapshot :: Action Model (PerasWeightSnapshot TestBlock)
+    GarbageCollect :: SlotNo -> Action Model ()
+
+  arbitraryAction _ (Model model)
+    | model.open =
+        frequency
+          [ (1, pure $ Some CloseDB)
+          , (20, Some <$> genAddCert)
+          , (20, pure $ Some GetWeightSnapshot)
+          , (5, Some . GarbageCollect . SlotNo <$> arbitrary)
+          ]
+    | otherwise = pure $ Some OpenDB
+   where
+    genAddCert = do
+      roundNo <- genRoundNo
+      boostedBlock <- genPoint
+      pure $
+        AddCert
+          ValidatedPerasCert
+            { vpcCert =
+                PerasCert
+                  { pcCertRound = roundNo
+                  , pcCertBoostedBlock = boostedBlock
+                  }
+            , vpcCertBoost = boostPerCert
+            }
+
+    -- Generators are heavily skewed toward collisions, to get equivocating certificates
+    -- and certificates boosting the same block
+    genPoint :: Gen (Point TestBlock)
+    genPoint =
+      oneof
+        [ return GenesisPoint
+        , BlockPoint <$> (SlotNo <$> arbitrary) <*> genHash
+        ]
+    genRoundNo :: Gen (PerasRoundNo)
+    genRoundNo =
+      frequency
+        [ (1, pure $ PerasRoundNo 1)
+        , (1, pure $ PerasRoundNo 2)
+        , (8, PerasRoundNo <$> arbitrary)
+        ]
+    genHash = TestHash . NE.fromList . getNonEmpty <$> arbitrary
+
+  initialState = Model Model.initModel
+
+  nextState (Model model) action _ = Model $ case action of
+    OpenDB -> Model.openDB model
+    CloseDB -> Model.closeDB model
+    AddCert cert -> Model.addCert model cert
+    GetWeightSnapshot -> model
+    GarbageCollect slot -> Model.garbageCollect slot model
+
+  precondition (Model model) = \case
+    OpenDB -> not model.open
+    _ -> model.open
+
+deriving stock instance Show (Action Model a)
+deriving stock instance Eq (Action Model a)
+
+instance HasVariables (Action Model a) where
+  getAllVariables _ = mempty
+
+instance RunModel Model (StateT (PerasCertDB IO TestBlock) IO) where
+  perform _ action _ = case action of
+    OpenDB -> do
+      perasCertDB <- lift $ PerasCertDB.openDB (PerasCertDB.PerasCertDbArgs nullTracer)
+      put perasCertDB
+    CloseDB -> do
+      perasCertDB <- get
+      lift $ PerasCertDB.closeDB perasCertDB
+    AddCert cert -> do
+      perasCertDB <- get
+      lift $ PerasCertDB.addCert perasCertDB cert
+    GetWeightSnapshot -> do
+      perasCertDB <- get
+      lift $ atomically $ forgetFingerprint <$> PerasCertDB.getWeightSnapshot perasCertDB
+    GarbageCollect slot -> do
+      perasCertDB <- get
+      lift $ PerasCertDB.garbageCollect perasCertDB slot
+
+  postcondition (Model model, _) (AddCert cert) _ actual = do
+    let expected
+          | model.certs `Model.hasRoundNo` cert = PerasCertAlreadyInDB
+          | otherwise = AddedPerasCertToDB
+    counterexamplePost $ show expected <> " /= " <> show actual
+    pure $ expected == actual
+  postcondition (Model model, _) GetWeightSnapshot _ actual = do
+    let expected = Model.getWeightSnapshot model
+    counterexamplePost $ "Model: " <> show expected
+    counterexamplePost $ "SUT: " <> show actual
+    pure $ expected == actual
+  postcondition _ _ _ _ = pure True
+
+  monitoring (Model model, _) (AddCert cert) _ _ prop =
+    prop
+      & tabulate
+        "Certificate round collision"
+        [show $ model.certs `Model.hasRoundNo` cert]
+      & tabulate
+        "Certificate block collision"
+        [ show $
+            Set.member
+              (getPerasCertBoostedBlock cert)
+              (Set.map getPerasCertBoostedBlock model.certs)
+        ]
+  monitoring _ _ _ _ prop = prop
diff --git a/scripts/release/create-release.hs b/scripts/release/create-release.hs
index ff1be863f..9a785d9f2 100755
--- a/scripts/release/create-release.hs
+++ b/scripts/release/create-release.hs
@@ -97,10 +97,11 @@ main = withStdTerminalHandles $ sh do
 --   dependencies are located BEFORE that package in the list!
 packages :: [(FilePath, [FilePath])]
 packages =
-  [ ("ouroboros-consensus", [])
-  , ("ouroboros-consensus-diffusion", ["ouroboros-consensus"])
+  [ ("sop-extras", [])
+  , ("ouroboros-consensus", ["sop-extras"])
+  , ("ouroboros-consensus-diffusion", ["sop-extras", "ouroboros-consensus"])
   , ("ouroboros-consensus-protocol", ["ouroboros-consensus"])
-  , ("ouroboros-consensus-cardano", ["ouroboros-consensus", "ouroboros-consensus-protocol"])
+  , ("ouroboros-consensus-cardano", ["sop-extras", "ouroboros-consensus", "ouroboros-consensus-protocol"])
   ]
 
 helpDescription :: Description
@@ -187,8 +188,7 @@ findChangeSeverity frag = do
     Left markdownError -> do
       liftIO $ putStrLn $ "Failed to parse markdown file " <> frag <> ":"
       error $ show markdownError
-    Right (Headings Nothing) ->
-      error $ "Couldn't find any change severity headers in " <> frag <> ", exiting!"
+    Right (Headings Nothing) -> pure Patch
     Right (Headings (Just (Max sev))) -> pure sev
 
 collectSeverities :: Fold (FilePath, Maybe ChangeSeverity, [FilePath]) (Map FilePath (Maybe ChangeSeverity))
diff --git a/sop-extras/CHANGELOG.md b/sop-extras/CHANGELOG.md
index 254f2643d..dbc325ee5 100644
--- a/sop-extras/CHANGELOG.md
+++ b/sop-extras/CHANGELOG.md
@@ -2,6 +2,13 @@
 
 # Changelog entries
 
+<a id='changelog-0.4.1.0'></a>
+## 0.4.1.0 -- 2025-09-30
+
+### Non-Breaking
+
+- Add `ctraverse`, `traverse_`, and `HTraverse_` to `OptNP`
+
 <a id='changelog-0.4.0.0'></a>
 ## 0.4.0.0 -- 2025-04-16
 
diff --git a/sop-extras/sop-extras.cabal b/sop-extras/sop-extras.cabal
index 556cdf013..ffa5f5cd4 100644
--- a/sop-extras/sop-extras.cabal
+++ b/sop-extras/sop-extras.cabal
@@ -5,7 +5,7 @@ description:
   This package provides some more constructs that are not present on the
   @sop-core@ package but built upon the same foundations.
 
-version: 0.4.0.0
+version: 0.4.1.0
 license: Apache-2.0
 license-files:
   LICENSE
diff --git a/sop-extras/src/Data/SOP/OptNP.hs b/sop-extras/src/Data/SOP/OptNP.hs
index 9e11cc2e0..4142588aa 100644
--- a/sop-extras/src/Data/SOP/OptNP.hs
+++ b/sop-extras/src/Data/SOP/OptNP.hs
@@ -148,9 +148,30 @@ ctraverse' _ f = go
   go (OptSkip xs) = OptSkip <$> go xs
   go OptNil = pure OptNil
 
+ctraverse_ ::
+  forall c proxy empty xs f g.
+  (All c xs, Applicative g) =>
+  proxy c -> (forall a. c a => f a -> g ()) -> OptNP empty f xs -> g ()
+ctraverse_ _ f = go
+ where
+  go :: All c ys => OptNP empty' f ys -> g ()
+  go (OptCons x xs) = f x *> go xs
+  go (OptSkip xs) = go xs
+  go OptNil = pure ()
+
+traverse_ ::
+  forall empty xs f g.
+  (SListI xs, Applicative g) =>
+  (forall a. f a -> g ()) -> OptNP empty f xs -> g ()
+traverse_ f = ctraverse_ (Proxy @Top) f
+
 instance HAp (OptNP empty) where
   hap = ap
 
+instance HTraverse_ (OptNP empty) where
+  hctraverse_ = ctraverse_
+  htraverse_ = traverse_
+
 instance HSequence (OptNP empty) where
   hctraverse' = ctraverse'
   htraverse' = hctraverse' (Proxy @Top)
